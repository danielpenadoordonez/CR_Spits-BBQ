
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Perfil
 * 
 */
export type Perfil = {
  id: number
  descripcion: string
}

/**
 * Model Usuario
 * 
 */
export type Usuario = {
  id: string
  nombre: string
  apellido1: string
  apellido2: string
  correo: string
  username: string
  clave: string
  telefono: string
  direccion: string | null
  idPerfil: number
}

/**
 * Model MeseroOnSucursal
 * 
 */
export type MeseroOnSucursal = {
  idSucursal: bigint
  idMesero: string
}

/**
 * Model Sucursal
 * 
 */
export type Sucursal = {
  id: bigint
  codigo: string
  nombre: string
  ubicacion: string
  capacidad: bigint
}

/**
 * Model Mesa
 * 
 */
export type Mesa = {
  id: bigint
  codigo: string
  capacidad: number
  disponibilidad: number
  estado: boolean
  idSucursal: bigint
  idEstadoMesa: number
}

/**
 * Model EstadoMesa
 * 
 */
export type EstadoMesa = {
  id: number
  descripcion: string
}

/**
 * Model Reservacion
 * 
 */
export type Reservacion = {
  id: bigint
  fecha_hora: Date
  idSucursal: bigint
  idUsuario: string
}

/**
 * Model Reservacion_Mesa
 * 
 */
export type Reservacion_Mesa = {
  idMesa: bigint
  idReservacion: bigint
  cantidad: number
}

/**
 * Model Categoria_Producto
 * 
 */
export type Categoria_Producto = {
  id: number
  descripcion: string
}

/**
 * Model Producto
 * 
 */
export type Producto = {
  id: bigint
  nombre: string
  descripcion: string
  ingredientes: string | null
  precio: Prisma.Decimal
  imagen: string
  estado: number
  idCategoria: number
}

/**
 * Model Sucursal_Producto
 * 
 */
export type Sucursal_Producto = {
  idProducto: bigint
  idSucursal: bigint
}

/**
 * Model TipoPago
 * 
 */
export type TipoPago = {
  id: number
  descripcion: string
}

/**
 * Model Factura_Encabezado
 * 
 */
export type Factura_Encabezado = {
  id: bigint
  numero_tarjeta: string | null
  tarjeta: TipoTarjeta | null
  fecha: Date
  estado: boolean
  idUsuario: string
  idTipoPago: number
}

/**
 * Model Factura_Detalle
 * 
 */
export type Factura_Detalle = {
  id: bigint
  cantidad: number
  precio: Prisma.Decimal
  impuesto: Prisma.Decimal
  total_detalle: Prisma.Decimal
  idFactura_Encabezado: bigint
  idProducto: bigint
}

/**
 * Model Pedido
 * 
 */
export type Pedido = {
  id: bigint
  nombre: string | null
  precio: Prisma.Decimal
  idUsuario: string
}

/**
 * Model Pedido_Producto
 * 
 */
export type Pedido_Producto = {
  idPedido: bigint
  idProducto: bigint
  cantidad: number
  notas: string
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const TipoTarjeta: {
  VISA: 'VISA',
  MASTERCARD: 'MASTERCARD',
  AMERICAN_EXPRESS: 'AMERICAN_EXPRESS',
  JCB: 'JCB',
  DISCOVER: 'DISCOVER',
  NULL: 'NULL'
};

export type TipoTarjeta = (typeof TipoTarjeta)[keyof typeof TipoTarjeta]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Perfils
 * const perfils = await prisma.perfil.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Perfils
   * const perfils = await prisma.perfil.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.perfil`: Exposes CRUD operations for the **Perfil** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Perfils
    * const perfils = await prisma.perfil.findMany()
    * ```
    */
  get perfil(): Prisma.PerfilDelegate<GlobalReject>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<GlobalReject>;

  /**
   * `prisma.meseroOnSucursal`: Exposes CRUD operations for the **MeseroOnSucursal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeseroOnSucursals
    * const meseroOnSucursals = await prisma.meseroOnSucursal.findMany()
    * ```
    */
  get meseroOnSucursal(): Prisma.MeseroOnSucursalDelegate<GlobalReject>;

  /**
   * `prisma.sucursal`: Exposes CRUD operations for the **Sucursal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sucursals
    * const sucursals = await prisma.sucursal.findMany()
    * ```
    */
  get sucursal(): Prisma.SucursalDelegate<GlobalReject>;

  /**
   * `prisma.mesa`: Exposes CRUD operations for the **Mesa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mesas
    * const mesas = await prisma.mesa.findMany()
    * ```
    */
  get mesa(): Prisma.MesaDelegate<GlobalReject>;

  /**
   * `prisma.estadoMesa`: Exposes CRUD operations for the **EstadoMesa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EstadoMesas
    * const estadoMesas = await prisma.estadoMesa.findMany()
    * ```
    */
  get estadoMesa(): Prisma.EstadoMesaDelegate<GlobalReject>;

  /**
   * `prisma.reservacion`: Exposes CRUD operations for the **Reservacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservacions
    * const reservacions = await prisma.reservacion.findMany()
    * ```
    */
  get reservacion(): Prisma.ReservacionDelegate<GlobalReject>;

  /**
   * `prisma.reservacion_Mesa`: Exposes CRUD operations for the **Reservacion_Mesa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservacion_Mesas
    * const reservacion_Mesas = await prisma.reservacion_Mesa.findMany()
    * ```
    */
  get reservacion_Mesa(): Prisma.Reservacion_MesaDelegate<GlobalReject>;

  /**
   * `prisma.categoria_Producto`: Exposes CRUD operations for the **Categoria_Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categoria_Productos
    * const categoria_Productos = await prisma.categoria_Producto.findMany()
    * ```
    */
  get categoria_Producto(): Prisma.Categoria_ProductoDelegate<GlobalReject>;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.ProductoDelegate<GlobalReject>;

  /**
   * `prisma.sucursal_Producto`: Exposes CRUD operations for the **Sucursal_Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sucursal_Productos
    * const sucursal_Productos = await prisma.sucursal_Producto.findMany()
    * ```
    */
  get sucursal_Producto(): Prisma.Sucursal_ProductoDelegate<GlobalReject>;

  /**
   * `prisma.tipoPago`: Exposes CRUD operations for the **TipoPago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoPagos
    * const tipoPagos = await prisma.tipoPago.findMany()
    * ```
    */
  get tipoPago(): Prisma.TipoPagoDelegate<GlobalReject>;

  /**
   * `prisma.factura_Encabezado`: Exposes CRUD operations for the **Factura_Encabezado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Factura_Encabezados
    * const factura_Encabezados = await prisma.factura_Encabezado.findMany()
    * ```
    */
  get factura_Encabezado(): Prisma.Factura_EncabezadoDelegate<GlobalReject>;

  /**
   * `prisma.factura_Detalle`: Exposes CRUD operations for the **Factura_Detalle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Factura_Detalles
    * const factura_Detalles = await prisma.factura_Detalle.findMany()
    * ```
    */
  get factura_Detalle(): Prisma.Factura_DetalleDelegate<GlobalReject>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<GlobalReject>;

  /**
   * `prisma.pedido_Producto`: Exposes CRUD operations for the **Pedido_Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedido_Productos
    * const pedido_Productos = await prisma.pedido_Producto.findMany()
    * ```
    */
  get pedido_Producto(): Prisma.Pedido_ProductoDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.3.1
   * Query Engine version: c875e43600dfe042452e0b868f7a48b817b9640b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Perfil: 'Perfil',
    Usuario: 'Usuario',
    MeseroOnSucursal: 'MeseroOnSucursal',
    Sucursal: 'Sucursal',
    Mesa: 'Mesa',
    EstadoMesa: 'EstadoMesa',
    Reservacion: 'Reservacion',
    Reservacion_Mesa: 'Reservacion_Mesa',
    Categoria_Producto: 'Categoria_Producto',
    Producto: 'Producto',
    Sucursal_Producto: 'Sucursal_Producto',
    TipoPago: 'TipoPago',
    Factura_Encabezado: 'Factura_Encabezado',
    Factura_Detalle: 'Factura_Detalle',
    Pedido: 'Pedido',
    Pedido_Producto: 'Pedido_Producto'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PerfilCountOutputType
   */


  export type PerfilCountOutputType = {
    usuarios: number
  }

  export type PerfilCountOutputTypeSelect = {
    usuarios?: boolean
  }

  export type PerfilCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PerfilCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PerfilCountOutputType
    : S extends undefined
    ? never
    : S extends PerfilCountOutputTypeArgs
    ?'include' extends U
    ? PerfilCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PerfilCountOutputType ? PerfilCountOutputType[P] : never
  } 
    : PerfilCountOutputType
  : PerfilCountOutputType




  // Custom InputTypes

  /**
   * PerfilCountOutputType without action
   */
  export type PerfilCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PerfilCountOutputType
     * 
    **/
    select?: PerfilCountOutputTypeSelect | null
  }



  /**
   * Count Type UsuarioCountOutputType
   */


  export type UsuarioCountOutputType = {
    reservaciones: number
    facturas: number
    pedidos: number
    MeseroOnSucursal: number
  }

  export type UsuarioCountOutputTypeSelect = {
    reservaciones?: boolean
    facturas?: boolean
    pedidos?: boolean
    MeseroOnSucursal?: boolean
  }

  export type UsuarioCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsuarioCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsuarioCountOutputType
    : S extends undefined
    ? never
    : S extends UsuarioCountOutputTypeArgs
    ?'include' extends U
    ? UsuarioCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsuarioCountOutputType ? UsuarioCountOutputType[P] : never
  } 
    : UsuarioCountOutputType
  : UsuarioCountOutputType




  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     * 
    **/
    select?: UsuarioCountOutputTypeSelect | null
  }



  /**
   * Count Type SucursalCountOutputType
   */


  export type SucursalCountOutputType = {
    mesas: number
    reservaciones: number
    productos: number
    MeseroOnSucursal: number
  }

  export type SucursalCountOutputTypeSelect = {
    mesas?: boolean
    reservaciones?: boolean
    productos?: boolean
    MeseroOnSucursal?: boolean
  }

  export type SucursalCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SucursalCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SucursalCountOutputType
    : S extends undefined
    ? never
    : S extends SucursalCountOutputTypeArgs
    ?'include' extends U
    ? SucursalCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SucursalCountOutputType ? SucursalCountOutputType[P] : never
  } 
    : SucursalCountOutputType
  : SucursalCountOutputType




  // Custom InputTypes

  /**
   * SucursalCountOutputType without action
   */
  export type SucursalCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SucursalCountOutputType
     * 
    **/
    select?: SucursalCountOutputTypeSelect | null
  }



  /**
   * Count Type MesaCountOutputType
   */


  export type MesaCountOutputType = {
    reservaciones: number
  }

  export type MesaCountOutputTypeSelect = {
    reservaciones?: boolean
  }

  export type MesaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MesaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MesaCountOutputType
    : S extends undefined
    ? never
    : S extends MesaCountOutputTypeArgs
    ?'include' extends U
    ? MesaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MesaCountOutputType ? MesaCountOutputType[P] : never
  } 
    : MesaCountOutputType
  : MesaCountOutputType




  // Custom InputTypes

  /**
   * MesaCountOutputType without action
   */
  export type MesaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MesaCountOutputType
     * 
    **/
    select?: MesaCountOutputTypeSelect | null
  }



  /**
   * Count Type EstadoMesaCountOutputType
   */


  export type EstadoMesaCountOutputType = {
    mesas: number
  }

  export type EstadoMesaCountOutputTypeSelect = {
    mesas?: boolean
  }

  export type EstadoMesaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EstadoMesaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EstadoMesaCountOutputType
    : S extends undefined
    ? never
    : S extends EstadoMesaCountOutputTypeArgs
    ?'include' extends U
    ? EstadoMesaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EstadoMesaCountOutputType ? EstadoMesaCountOutputType[P] : never
  } 
    : EstadoMesaCountOutputType
  : EstadoMesaCountOutputType




  // Custom InputTypes

  /**
   * EstadoMesaCountOutputType without action
   */
  export type EstadoMesaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EstadoMesaCountOutputType
     * 
    **/
    select?: EstadoMesaCountOutputTypeSelect | null
  }



  /**
   * Count Type ReservacionCountOutputType
   */


  export type ReservacionCountOutputType = {
    mesas: number
  }

  export type ReservacionCountOutputTypeSelect = {
    mesas?: boolean
  }

  export type ReservacionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ReservacionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ReservacionCountOutputType
    : S extends undefined
    ? never
    : S extends ReservacionCountOutputTypeArgs
    ?'include' extends U
    ? ReservacionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ReservacionCountOutputType ? ReservacionCountOutputType[P] : never
  } 
    : ReservacionCountOutputType
  : ReservacionCountOutputType




  // Custom InputTypes

  /**
   * ReservacionCountOutputType without action
   */
  export type ReservacionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReservacionCountOutputType
     * 
    **/
    select?: ReservacionCountOutputTypeSelect | null
  }



  /**
   * Count Type Categoria_ProductoCountOutputType
   */


  export type Categoria_ProductoCountOutputType = {
    productos: number
  }

  export type Categoria_ProductoCountOutputTypeSelect = {
    productos?: boolean
  }

  export type Categoria_ProductoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Categoria_ProductoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Categoria_ProductoCountOutputType
    : S extends undefined
    ? never
    : S extends Categoria_ProductoCountOutputTypeArgs
    ?'include' extends U
    ? Categoria_ProductoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Categoria_ProductoCountOutputType ? Categoria_ProductoCountOutputType[P] : never
  } 
    : Categoria_ProductoCountOutputType
  : Categoria_ProductoCountOutputType




  // Custom InputTypes

  /**
   * Categoria_ProductoCountOutputType without action
   */
  export type Categoria_ProductoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Categoria_ProductoCountOutputType
     * 
    **/
    select?: Categoria_ProductoCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductoCountOutputType
   */


  export type ProductoCountOutputType = {
    detalles: number
    pedidos: number
    sucursales: number
  }

  export type ProductoCountOutputTypeSelect = {
    detalles?: boolean
    pedidos?: boolean
    sucursales?: boolean
  }

  export type ProductoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductoCountOutputType
    : S extends undefined
    ? never
    : S extends ProductoCountOutputTypeArgs
    ?'include' extends U
    ? ProductoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductoCountOutputType ? ProductoCountOutputType[P] : never
  } 
    : ProductoCountOutputType
  : ProductoCountOutputType




  // Custom InputTypes

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductoCountOutputType
     * 
    **/
    select?: ProductoCountOutputTypeSelect | null
  }



  /**
   * Count Type TipoPagoCountOutputType
   */


  export type TipoPagoCountOutputType = {
    facturas: number
  }

  export type TipoPagoCountOutputTypeSelect = {
    facturas?: boolean
  }

  export type TipoPagoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TipoPagoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TipoPagoCountOutputType
    : S extends undefined
    ? never
    : S extends TipoPagoCountOutputTypeArgs
    ?'include' extends U
    ? TipoPagoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TipoPagoCountOutputType ? TipoPagoCountOutputType[P] : never
  } 
    : TipoPagoCountOutputType
  : TipoPagoCountOutputType




  // Custom InputTypes

  /**
   * TipoPagoCountOutputType without action
   */
  export type TipoPagoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TipoPagoCountOutputType
     * 
    **/
    select?: TipoPagoCountOutputTypeSelect | null
  }



  /**
   * Count Type Factura_EncabezadoCountOutputType
   */


  export type Factura_EncabezadoCountOutputType = {
    detalles: number
  }

  export type Factura_EncabezadoCountOutputTypeSelect = {
    detalles?: boolean
  }

  export type Factura_EncabezadoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Factura_EncabezadoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Factura_EncabezadoCountOutputType
    : S extends undefined
    ? never
    : S extends Factura_EncabezadoCountOutputTypeArgs
    ?'include' extends U
    ? Factura_EncabezadoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Factura_EncabezadoCountOutputType ? Factura_EncabezadoCountOutputType[P] : never
  } 
    : Factura_EncabezadoCountOutputType
  : Factura_EncabezadoCountOutputType




  // Custom InputTypes

  /**
   * Factura_EncabezadoCountOutputType without action
   */
  export type Factura_EncabezadoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Factura_EncabezadoCountOutputType
     * 
    **/
    select?: Factura_EncabezadoCountOutputTypeSelect | null
  }



  /**
   * Count Type PedidoCountOutputType
   */


  export type PedidoCountOutputType = {
    productos: number
  }

  export type PedidoCountOutputTypeSelect = {
    productos?: boolean
  }

  export type PedidoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PedidoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PedidoCountOutputType
    : S extends undefined
    ? never
    : S extends PedidoCountOutputTypeArgs
    ?'include' extends U
    ? PedidoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PedidoCountOutputType ? PedidoCountOutputType[P] : never
  } 
    : PedidoCountOutputType
  : PedidoCountOutputType




  // Custom InputTypes

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     * 
    **/
    select?: PedidoCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Perfil
   */


  export type AggregatePerfil = {
    _count: PerfilCountAggregateOutputType | null
    _avg: PerfilAvgAggregateOutputType | null
    _sum: PerfilSumAggregateOutputType | null
    _min: PerfilMinAggregateOutputType | null
    _max: PerfilMaxAggregateOutputType | null
  }

  export type PerfilAvgAggregateOutputType = {
    id: number | null
  }

  export type PerfilSumAggregateOutputType = {
    id: number | null
  }

  export type PerfilMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type PerfilMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type PerfilCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type PerfilAvgAggregateInputType = {
    id?: true
  }

  export type PerfilSumAggregateInputType = {
    id?: true
  }

  export type PerfilMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type PerfilMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type PerfilCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type PerfilAggregateArgs = {
    /**
     * Filter which Perfil to aggregate.
     * 
    **/
    where?: PerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<PerfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Perfils.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Perfils
    **/
    _count?: true | PerfilCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerfilAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerfilSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerfilMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerfilMaxAggregateInputType
  }

  export type GetPerfilAggregateType<T extends PerfilAggregateArgs> = {
        [P in keyof T & keyof AggregatePerfil]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerfil[P]>
      : GetScalarType<T[P], AggregatePerfil[P]>
  }




  export type PerfilGroupByArgs = {
    where?: PerfilWhereInput
    orderBy?: Enumerable<PerfilOrderByWithAggregationInput>
    by: Array<PerfilScalarFieldEnum>
    having?: PerfilScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerfilCountAggregateInputType | true
    _avg?: PerfilAvgAggregateInputType
    _sum?: PerfilSumAggregateInputType
    _min?: PerfilMinAggregateInputType
    _max?: PerfilMaxAggregateInputType
  }


  export type PerfilGroupByOutputType = {
    id: number
    descripcion: string
    _count: PerfilCountAggregateOutputType | null
    _avg: PerfilAvgAggregateOutputType | null
    _sum: PerfilSumAggregateOutputType | null
    _min: PerfilMinAggregateOutputType | null
    _max: PerfilMaxAggregateOutputType | null
  }

  type GetPerfilGroupByPayload<T extends PerfilGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PerfilGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerfilGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerfilGroupByOutputType[P]>
            : GetScalarType<T[P], PerfilGroupByOutputType[P]>
        }
      >
    >


  export type PerfilSelect = {
    id?: boolean
    descripcion?: boolean
    usuarios?: boolean | UsuarioFindManyArgs
    _count?: boolean | PerfilCountOutputTypeArgs
  }

  export type PerfilInclude = {
    usuarios?: boolean | UsuarioFindManyArgs
    _count?: boolean | PerfilCountOutputTypeArgs
  }

  export type PerfilGetPayload<
    S extends boolean | null | undefined | PerfilArgs,
    U = keyof S
      > = S extends true
        ? Perfil
    : S extends undefined
    ? never
    : S extends PerfilArgs | PerfilFindManyArgs
    ?'include' extends U
    ? Perfil  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuarios' ? Array < UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PerfilCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuarios' ? Array < UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PerfilCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Perfil ? Perfil[P] : never
  } 
    : Perfil
  : Perfil


  type PerfilCountArgs = Merge<
    Omit<PerfilFindManyArgs, 'select' | 'include'> & {
      select?: PerfilCountAggregateInputType | true
    }
  >

  export interface PerfilDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Perfil that matches the filter.
     * @param {PerfilFindUniqueArgs} args - Arguments to find a Perfil
     * @example
     * // Get one Perfil
     * const perfil = await prisma.perfil.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PerfilFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PerfilFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Perfil'> extends True ? CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>> : CheckSelect<T, Prisma__PerfilClient<Perfil | null >, Prisma__PerfilClient<PerfilGetPayload<T> | null >>

    /**
     * Find the first Perfil that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilFindFirstArgs} args - Arguments to find a Perfil
     * @example
     * // Get one Perfil
     * const perfil = await prisma.perfil.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PerfilFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PerfilFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Perfil'> extends True ? CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>> : CheckSelect<T, Prisma__PerfilClient<Perfil | null >, Prisma__PerfilClient<PerfilGetPayload<T> | null >>

    /**
     * Find zero or more Perfils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Perfils
     * const perfils = await prisma.perfil.findMany()
     * 
     * // Get first 10 Perfils
     * const perfils = await prisma.perfil.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perfilWithIdOnly = await prisma.perfil.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PerfilFindManyArgs>(
      args?: SelectSubset<T, PerfilFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Perfil>>, PrismaPromise<Array<PerfilGetPayload<T>>>>

    /**
     * Create a Perfil.
     * @param {PerfilCreateArgs} args - Arguments to create a Perfil.
     * @example
     * // Create one Perfil
     * const Perfil = await prisma.perfil.create({
     *   data: {
     *     // ... data to create a Perfil
     *   }
     * })
     * 
    **/
    create<T extends PerfilCreateArgs>(
      args: SelectSubset<T, PerfilCreateArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Create many Perfils.
     *     @param {PerfilCreateManyArgs} args - Arguments to create many Perfils.
     *     @example
     *     // Create many Perfils
     *     const perfil = await prisma.perfil.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PerfilCreateManyArgs>(
      args?: SelectSubset<T, PerfilCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Perfil.
     * @param {PerfilDeleteArgs} args - Arguments to delete one Perfil.
     * @example
     * // Delete one Perfil
     * const Perfil = await prisma.perfil.delete({
     *   where: {
     *     // ... filter to delete one Perfil
     *   }
     * })
     * 
    **/
    delete<T extends PerfilDeleteArgs>(
      args: SelectSubset<T, PerfilDeleteArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Update one Perfil.
     * @param {PerfilUpdateArgs} args - Arguments to update one Perfil.
     * @example
     * // Update one Perfil
     * const perfil = await prisma.perfil.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PerfilUpdateArgs>(
      args: SelectSubset<T, PerfilUpdateArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Delete zero or more Perfils.
     * @param {PerfilDeleteManyArgs} args - Arguments to filter Perfils to delete.
     * @example
     * // Delete a few Perfils
     * const { count } = await prisma.perfil.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PerfilDeleteManyArgs>(
      args?: SelectSubset<T, PerfilDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Perfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Perfils
     * const perfil = await prisma.perfil.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PerfilUpdateManyArgs>(
      args: SelectSubset<T, PerfilUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Perfil.
     * @param {PerfilUpsertArgs} args - Arguments to update or create a Perfil.
     * @example
     * // Update or create a Perfil
     * const perfil = await prisma.perfil.upsert({
     *   create: {
     *     // ... data to create a Perfil
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Perfil we want to update
     *   }
     * })
    **/
    upsert<T extends PerfilUpsertArgs>(
      args: SelectSubset<T, PerfilUpsertArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Find one Perfil that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PerfilFindUniqueOrThrowArgs} args - Arguments to find a Perfil
     * @example
     * // Get one Perfil
     * const perfil = await prisma.perfil.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PerfilFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PerfilFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Find the first Perfil that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilFindFirstOrThrowArgs} args - Arguments to find a Perfil
     * @example
     * // Get one Perfil
     * const perfil = await prisma.perfil.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PerfilFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PerfilFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Count the number of Perfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilCountArgs} args - Arguments to filter Perfils to count.
     * @example
     * // Count the number of Perfils
     * const count = await prisma.perfil.count({
     *   where: {
     *     // ... the filter for the Perfils we want to count
     *   }
     * })
    **/
    count<T extends PerfilCountArgs>(
      args?: Subset<T, PerfilCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerfilCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Perfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerfilAggregateArgs>(args: Subset<T, PerfilAggregateArgs>): PrismaPromise<GetPerfilAggregateType<T>>

    /**
     * Group by Perfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerfilGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerfilGroupByArgs['orderBy'] }
        : { orderBy?: PerfilGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerfilGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerfilGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Perfil.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PerfilClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuarios<T extends UsuarioFindManyArgs = {}>(args?: Subset<T, UsuarioFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Usuario>>, PrismaPromise<Array<UsuarioGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Perfil base type for findUnique actions
   */
  export type PerfilFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * Filter, which Perfil to fetch.
     * 
    **/
    where: PerfilWhereUniqueInput
  }

  /**
   * Perfil: findUnique
   */
  export interface PerfilFindUniqueArgs extends PerfilFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Perfil base type for findFirst actions
   */
  export type PerfilFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * Filter, which Perfil to fetch.
     * 
    **/
    where?: PerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<PerfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Perfils.
     * 
    **/
    cursor?: PerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Perfils.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Perfils.
     * 
    **/
    distinct?: Enumerable<PerfilScalarFieldEnum>
  }

  /**
   * Perfil: findFirst
   */
  export interface PerfilFindFirstArgs extends PerfilFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Perfil findMany
   */
  export type PerfilFindManyArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * Filter, which Perfils to fetch.
     * 
    **/
    where?: PerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<PerfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Perfils.
     * 
    **/
    cursor?: PerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Perfils.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PerfilScalarFieldEnum>
  }


  /**
   * Perfil create
   */
  export type PerfilCreateArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * The data needed to create a Perfil.
     * 
    **/
    data: XOR<PerfilCreateInput, PerfilUncheckedCreateInput>
  }


  /**
   * Perfil createMany
   */
  export type PerfilCreateManyArgs = {
    /**
     * The data used to create many Perfils.
     * 
    **/
    data: Enumerable<PerfilCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Perfil update
   */
  export type PerfilUpdateArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * The data needed to update a Perfil.
     * 
    **/
    data: XOR<PerfilUpdateInput, PerfilUncheckedUpdateInput>
    /**
     * Choose, which Perfil to update.
     * 
    **/
    where: PerfilWhereUniqueInput
  }


  /**
   * Perfil updateMany
   */
  export type PerfilUpdateManyArgs = {
    /**
     * The data used to update Perfils.
     * 
    **/
    data: XOR<PerfilUpdateManyMutationInput, PerfilUncheckedUpdateManyInput>
    /**
     * Filter which Perfils to update
     * 
    **/
    where?: PerfilWhereInput
  }


  /**
   * Perfil upsert
   */
  export type PerfilUpsertArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * The filter to search for the Perfil to update in case it exists.
     * 
    **/
    where: PerfilWhereUniqueInput
    /**
     * In case the Perfil found by the `where` argument doesn't exist, create a new Perfil with this data.
     * 
    **/
    create: XOR<PerfilCreateInput, PerfilUncheckedCreateInput>
    /**
     * In case the Perfil was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PerfilUpdateInput, PerfilUncheckedUpdateInput>
  }


  /**
   * Perfil delete
   */
  export type PerfilDeleteArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * Filter which Perfil to delete.
     * 
    **/
    where: PerfilWhereUniqueInput
  }


  /**
   * Perfil deleteMany
   */
  export type PerfilDeleteManyArgs = {
    /**
     * Filter which Perfils to delete
     * 
    **/
    where?: PerfilWhereInput
  }


  /**
   * Perfil: findUniqueOrThrow
   */
  export type PerfilFindUniqueOrThrowArgs = PerfilFindUniqueArgsBase
      

  /**
   * Perfil: findFirstOrThrow
   */
  export type PerfilFindFirstOrThrowArgs = PerfilFindFirstArgsBase
      

  /**
   * Perfil without action
   */
  export type PerfilArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
  }



  /**
   * Model Usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    idPerfil: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    idPerfil: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido1: string | null
    apellido2: string | null
    correo: string | null
    username: string | null
    clave: string | null
    telefono: string | null
    direccion: string | null
    idPerfil: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido1: string | null
    apellido2: string | null
    correo: string | null
    username: string | null
    clave: string | null
    telefono: string | null
    direccion: string | null
    idPerfil: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    apellido1: number
    apellido2: number
    correo: number
    username: number
    clave: number
    telefono: number
    direccion: number
    idPerfil: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    idPerfil?: true
  }

  export type UsuarioSumAggregateInputType = {
    idPerfil?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido1?: true
    apellido2?: true
    correo?: true
    username?: true
    clave?: true
    telefono?: true
    direccion?: true
    idPerfil?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido1?: true
    apellido2?: true
    correo?: true
    username?: true
    clave?: true
    telefono?: true
    direccion?: true
    idPerfil?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido1?: true
    apellido2?: true
    correo?: true
    username?: true
    clave?: true
    telefono?: true
    direccion?: true
    idPerfil?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which Usuario to aggregate.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: UsuarioWhereInput
    orderBy?: Enumerable<UsuarioOrderByWithAggregationInput>
    by: Array<UsuarioScalarFieldEnum>
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion: string | null
    idPerfil: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect = {
    id?: boolean
    nombre?: boolean
    apellido1?: boolean
    apellido2?: boolean
    correo?: boolean
    username?: boolean
    clave?: boolean
    telefono?: boolean
    direccion?: boolean
    reservaciones?: boolean | ReservacionFindManyArgs
    facturas?: boolean | Factura_EncabezadoFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    Perfil?: boolean | PerfilArgs
    idPerfil?: boolean
    MeseroOnSucursal?: boolean | MeseroOnSucursalFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type UsuarioInclude = {
    reservaciones?: boolean | ReservacionFindManyArgs
    facturas?: boolean | Factura_EncabezadoFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    Perfil?: boolean | PerfilArgs
    MeseroOnSucursal?: boolean | MeseroOnSucursalFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type UsuarioGetPayload<
    S extends boolean | null | undefined | UsuarioArgs,
    U = keyof S
      > = S extends true
        ? Usuario
    : S extends undefined
    ? never
    : S extends UsuarioArgs | UsuarioFindManyArgs
    ?'include' extends U
    ? Usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'facturas' ? Array < Factura_EncabezadoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Perfil' ? PerfilGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'MeseroOnSucursal' ? Array < MeseroOnSucursalGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'facturas' ? Array < Factura_EncabezadoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Perfil' ? PerfilGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'MeseroOnSucursal' ? Array < MeseroOnSucursalGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Usuario ? Usuario[P] : never
  } 
    : Usuario
  : Usuario


  type UsuarioCountArgs = Merge<
    Omit<UsuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }
  >

  export interface UsuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Usuario'> extends True ? CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Usuario'> extends True ? CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs>(
      args?: SelectSubset<T, UsuarioFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Usuario>>, PrismaPromise<Array<UsuarioGetPayload<T>>>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs>(
      args: SelectSubset<T, UsuarioCreateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs>(
      args?: SelectSubset<T, UsuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs>(
      args: SelectSubset<T, UsuarioDeleteArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs>(
      args: SelectSubset<T, UsuarioUpdateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs>(
      args: SelectSubset<T, UsuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs>(
      args: SelectSubset<T, UsuarioUpsertArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Find one Usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsuarioClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    reservaciones<T extends ReservacionFindManyArgs = {}>(args?: Subset<T, ReservacionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reservacion>>, PrismaPromise<Array<ReservacionGetPayload<T>>>>;

    facturas<T extends Factura_EncabezadoFindManyArgs = {}>(args?: Subset<T, Factura_EncabezadoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Factura_Encabezado>>, PrismaPromise<Array<Factura_EncabezadoGetPayload<T>>>>;

    pedidos<T extends PedidoFindManyArgs = {}>(args?: Subset<T, PedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>;

    Perfil<T extends PerfilArgs = {}>(args?: Subset<T, PerfilArgs>): CheckSelect<T, Prisma__PerfilClient<Perfil | null >, Prisma__PerfilClient<PerfilGetPayload<T> | null >>;

    MeseroOnSucursal<T extends MeseroOnSucursalFindManyArgs = {}>(args?: Subset<T, MeseroOnSucursalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MeseroOnSucursal>>, PrismaPromise<Array<MeseroOnSucursalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Usuario base type for findUnique actions
   */
  export type UsuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario: findUnique
   */
  export interface UsuarioFindUniqueArgs extends UsuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario base type for findFirst actions
   */
  export type UsuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     * 
    **/
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * Usuario: findFirst
   */
  export interface UsuarioFindFirstArgs extends UsuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuarios to fetch.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * The data needed to create a Usuario.
     * 
    **/
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs = {
    /**
     * The data used to create many Usuarios.
     * 
    **/
    data: Enumerable<UsuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * The data needed to update a Usuario.
     * 
    **/
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs = {
    /**
     * The data used to update Usuarios.
     * 
    **/
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     * 
    **/
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     * 
    **/
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     * 
    **/
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter which Usuario to delete.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs = {
    /**
     * Filter which Usuarios to delete
     * 
    **/
    where?: UsuarioWhereInput
  }


  /**
   * Usuario: findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs = UsuarioFindUniqueArgsBase
      

  /**
   * Usuario: findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs = UsuarioFindFirstArgsBase
      

  /**
   * Usuario without action
   */
  export type UsuarioArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
  }



  /**
   * Model MeseroOnSucursal
   */


  export type AggregateMeseroOnSucursal = {
    _count: MeseroOnSucursalCountAggregateOutputType | null
    _avg: MeseroOnSucursalAvgAggregateOutputType | null
    _sum: MeseroOnSucursalSumAggregateOutputType | null
    _min: MeseroOnSucursalMinAggregateOutputType | null
    _max: MeseroOnSucursalMaxAggregateOutputType | null
  }

  export type MeseroOnSucursalAvgAggregateOutputType = {
    idSucursal: number | null
  }

  export type MeseroOnSucursalSumAggregateOutputType = {
    idSucursal: bigint | null
  }

  export type MeseroOnSucursalMinAggregateOutputType = {
    idSucursal: bigint | null
    idMesero: string | null
  }

  export type MeseroOnSucursalMaxAggregateOutputType = {
    idSucursal: bigint | null
    idMesero: string | null
  }

  export type MeseroOnSucursalCountAggregateOutputType = {
    idSucursal: number
    idMesero: number
    _all: number
  }


  export type MeseroOnSucursalAvgAggregateInputType = {
    idSucursal?: true
  }

  export type MeseroOnSucursalSumAggregateInputType = {
    idSucursal?: true
  }

  export type MeseroOnSucursalMinAggregateInputType = {
    idSucursal?: true
    idMesero?: true
  }

  export type MeseroOnSucursalMaxAggregateInputType = {
    idSucursal?: true
    idMesero?: true
  }

  export type MeseroOnSucursalCountAggregateInputType = {
    idSucursal?: true
    idMesero?: true
    _all?: true
  }

  export type MeseroOnSucursalAggregateArgs = {
    /**
     * Filter which MeseroOnSucursal to aggregate.
     * 
    **/
    where?: MeseroOnSucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeseroOnSucursals to fetch.
     * 
    **/
    orderBy?: Enumerable<MeseroOnSucursalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MeseroOnSucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeseroOnSucursals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeseroOnSucursals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeseroOnSucursals
    **/
    _count?: true | MeseroOnSucursalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeseroOnSucursalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeseroOnSucursalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeseroOnSucursalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeseroOnSucursalMaxAggregateInputType
  }

  export type GetMeseroOnSucursalAggregateType<T extends MeseroOnSucursalAggregateArgs> = {
        [P in keyof T & keyof AggregateMeseroOnSucursal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeseroOnSucursal[P]>
      : GetScalarType<T[P], AggregateMeseroOnSucursal[P]>
  }




  export type MeseroOnSucursalGroupByArgs = {
    where?: MeseroOnSucursalWhereInput
    orderBy?: Enumerable<MeseroOnSucursalOrderByWithAggregationInput>
    by: Array<MeseroOnSucursalScalarFieldEnum>
    having?: MeseroOnSucursalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeseroOnSucursalCountAggregateInputType | true
    _avg?: MeseroOnSucursalAvgAggregateInputType
    _sum?: MeseroOnSucursalSumAggregateInputType
    _min?: MeseroOnSucursalMinAggregateInputType
    _max?: MeseroOnSucursalMaxAggregateInputType
  }


  export type MeseroOnSucursalGroupByOutputType = {
    idSucursal: bigint
    idMesero: string
    _count: MeseroOnSucursalCountAggregateOutputType | null
    _avg: MeseroOnSucursalAvgAggregateOutputType | null
    _sum: MeseroOnSucursalSumAggregateOutputType | null
    _min: MeseroOnSucursalMinAggregateOutputType | null
    _max: MeseroOnSucursalMaxAggregateOutputType | null
  }

  type GetMeseroOnSucursalGroupByPayload<T extends MeseroOnSucursalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MeseroOnSucursalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeseroOnSucursalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeseroOnSucursalGroupByOutputType[P]>
            : GetScalarType<T[P], MeseroOnSucursalGroupByOutputType[P]>
        }
      >
    >


  export type MeseroOnSucursalSelect = {
    Sucursal?: boolean | SucursalArgs
    idSucursal?: boolean
    Usuario?: boolean | UsuarioArgs
    idMesero?: boolean
  }

  export type MeseroOnSucursalInclude = {
    Sucursal?: boolean | SucursalArgs
    Usuario?: boolean | UsuarioArgs
  }

  export type MeseroOnSucursalGetPayload<
    S extends boolean | null | undefined | MeseroOnSucursalArgs,
    U = keyof S
      > = S extends true
        ? MeseroOnSucursal
    : S extends undefined
    ? never
    : S extends MeseroOnSucursalArgs | MeseroOnSucursalFindManyArgs
    ?'include' extends U
    ? MeseroOnSucursal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof MeseroOnSucursal ? MeseroOnSucursal[P] : never
  } 
    : MeseroOnSucursal
  : MeseroOnSucursal


  type MeseroOnSucursalCountArgs = Merge<
    Omit<MeseroOnSucursalFindManyArgs, 'select' | 'include'> & {
      select?: MeseroOnSucursalCountAggregateInputType | true
    }
  >

  export interface MeseroOnSucursalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MeseroOnSucursal that matches the filter.
     * @param {MeseroOnSucursalFindUniqueArgs} args - Arguments to find a MeseroOnSucursal
     * @example
     * // Get one MeseroOnSucursal
     * const meseroOnSucursal = await prisma.meseroOnSucursal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MeseroOnSucursalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MeseroOnSucursalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MeseroOnSucursal'> extends True ? CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal>, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T>>> : CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal | null >, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T> | null >>

    /**
     * Find the first MeseroOnSucursal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeseroOnSucursalFindFirstArgs} args - Arguments to find a MeseroOnSucursal
     * @example
     * // Get one MeseroOnSucursal
     * const meseroOnSucursal = await prisma.meseroOnSucursal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MeseroOnSucursalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MeseroOnSucursalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MeseroOnSucursal'> extends True ? CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal>, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T>>> : CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal | null >, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T> | null >>

    /**
     * Find zero or more MeseroOnSucursals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeseroOnSucursalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeseroOnSucursals
     * const meseroOnSucursals = await prisma.meseroOnSucursal.findMany()
     * 
     * // Get first 10 MeseroOnSucursals
     * const meseroOnSucursals = await prisma.meseroOnSucursal.findMany({ take: 10 })
     * 
     * // Only select the `idSucursal`
     * const meseroOnSucursalWithIdSucursalOnly = await prisma.meseroOnSucursal.findMany({ select: { idSucursal: true } })
     * 
    **/
    findMany<T extends MeseroOnSucursalFindManyArgs>(
      args?: SelectSubset<T, MeseroOnSucursalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MeseroOnSucursal>>, PrismaPromise<Array<MeseroOnSucursalGetPayload<T>>>>

    /**
     * Create a MeseroOnSucursal.
     * @param {MeseroOnSucursalCreateArgs} args - Arguments to create a MeseroOnSucursal.
     * @example
     * // Create one MeseroOnSucursal
     * const MeseroOnSucursal = await prisma.meseroOnSucursal.create({
     *   data: {
     *     // ... data to create a MeseroOnSucursal
     *   }
     * })
     * 
    **/
    create<T extends MeseroOnSucursalCreateArgs>(
      args: SelectSubset<T, MeseroOnSucursalCreateArgs>
    ): CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal>, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T>>>

    /**
     * Create many MeseroOnSucursals.
     *     @param {MeseroOnSucursalCreateManyArgs} args - Arguments to create many MeseroOnSucursals.
     *     @example
     *     // Create many MeseroOnSucursals
     *     const meseroOnSucursal = await prisma.meseroOnSucursal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MeseroOnSucursalCreateManyArgs>(
      args?: SelectSubset<T, MeseroOnSucursalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MeseroOnSucursal.
     * @param {MeseroOnSucursalDeleteArgs} args - Arguments to delete one MeseroOnSucursal.
     * @example
     * // Delete one MeseroOnSucursal
     * const MeseroOnSucursal = await prisma.meseroOnSucursal.delete({
     *   where: {
     *     // ... filter to delete one MeseroOnSucursal
     *   }
     * })
     * 
    **/
    delete<T extends MeseroOnSucursalDeleteArgs>(
      args: SelectSubset<T, MeseroOnSucursalDeleteArgs>
    ): CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal>, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T>>>

    /**
     * Update one MeseroOnSucursal.
     * @param {MeseroOnSucursalUpdateArgs} args - Arguments to update one MeseroOnSucursal.
     * @example
     * // Update one MeseroOnSucursal
     * const meseroOnSucursal = await prisma.meseroOnSucursal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MeseroOnSucursalUpdateArgs>(
      args: SelectSubset<T, MeseroOnSucursalUpdateArgs>
    ): CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal>, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T>>>

    /**
     * Delete zero or more MeseroOnSucursals.
     * @param {MeseroOnSucursalDeleteManyArgs} args - Arguments to filter MeseroOnSucursals to delete.
     * @example
     * // Delete a few MeseroOnSucursals
     * const { count } = await prisma.meseroOnSucursal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MeseroOnSucursalDeleteManyArgs>(
      args?: SelectSubset<T, MeseroOnSucursalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeseroOnSucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeseroOnSucursalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeseroOnSucursals
     * const meseroOnSucursal = await prisma.meseroOnSucursal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MeseroOnSucursalUpdateManyArgs>(
      args: SelectSubset<T, MeseroOnSucursalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MeseroOnSucursal.
     * @param {MeseroOnSucursalUpsertArgs} args - Arguments to update or create a MeseroOnSucursal.
     * @example
     * // Update or create a MeseroOnSucursal
     * const meseroOnSucursal = await prisma.meseroOnSucursal.upsert({
     *   create: {
     *     // ... data to create a MeseroOnSucursal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeseroOnSucursal we want to update
     *   }
     * })
    **/
    upsert<T extends MeseroOnSucursalUpsertArgs>(
      args: SelectSubset<T, MeseroOnSucursalUpsertArgs>
    ): CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal>, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T>>>

    /**
     * Find one MeseroOnSucursal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {MeseroOnSucursalFindUniqueOrThrowArgs} args - Arguments to find a MeseroOnSucursal
     * @example
     * // Get one MeseroOnSucursal
     * const meseroOnSucursal = await prisma.meseroOnSucursal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MeseroOnSucursalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MeseroOnSucursalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal>, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T>>>

    /**
     * Find the first MeseroOnSucursal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeseroOnSucursalFindFirstOrThrowArgs} args - Arguments to find a MeseroOnSucursal
     * @example
     * // Get one MeseroOnSucursal
     * const meseroOnSucursal = await prisma.meseroOnSucursal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MeseroOnSucursalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MeseroOnSucursalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__MeseroOnSucursalClient<MeseroOnSucursal>, Prisma__MeseroOnSucursalClient<MeseroOnSucursalGetPayload<T>>>

    /**
     * Count the number of MeseroOnSucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeseroOnSucursalCountArgs} args - Arguments to filter MeseroOnSucursals to count.
     * @example
     * // Count the number of MeseroOnSucursals
     * const count = await prisma.meseroOnSucursal.count({
     *   where: {
     *     // ... the filter for the MeseroOnSucursals we want to count
     *   }
     * })
    **/
    count<T extends MeseroOnSucursalCountArgs>(
      args?: Subset<T, MeseroOnSucursalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeseroOnSucursalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeseroOnSucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeseroOnSucursalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeseroOnSucursalAggregateArgs>(args: Subset<T, MeseroOnSucursalAggregateArgs>): PrismaPromise<GetMeseroOnSucursalAggregateType<T>>

    /**
     * Group by MeseroOnSucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeseroOnSucursalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeseroOnSucursalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeseroOnSucursalGroupByArgs['orderBy'] }
        : { orderBy?: MeseroOnSucursalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeseroOnSucursalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeseroOnSucursalGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MeseroOnSucursal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MeseroOnSucursalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Sucursal<T extends SucursalArgs = {}>(args?: Subset<T, SucursalArgs>): CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>;

    Usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MeseroOnSucursal base type for findUnique actions
   */
  export type MeseroOnSucursalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MeseroOnSucursal
     * 
    **/
    select?: MeseroOnSucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeseroOnSucursalInclude | null
    /**
     * Filter, which MeseroOnSucursal to fetch.
     * 
    **/
    where: MeseroOnSucursalWhereUniqueInput
  }

  /**
   * MeseroOnSucursal: findUnique
   */
  export interface MeseroOnSucursalFindUniqueArgs extends MeseroOnSucursalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MeseroOnSucursal base type for findFirst actions
   */
  export type MeseroOnSucursalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MeseroOnSucursal
     * 
    **/
    select?: MeseroOnSucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeseroOnSucursalInclude | null
    /**
     * Filter, which MeseroOnSucursal to fetch.
     * 
    **/
    where?: MeseroOnSucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeseroOnSucursals to fetch.
     * 
    **/
    orderBy?: Enumerable<MeseroOnSucursalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeseroOnSucursals.
     * 
    **/
    cursor?: MeseroOnSucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeseroOnSucursals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeseroOnSucursals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeseroOnSucursals.
     * 
    **/
    distinct?: Enumerable<MeseroOnSucursalScalarFieldEnum>
  }

  /**
   * MeseroOnSucursal: findFirst
   */
  export interface MeseroOnSucursalFindFirstArgs extends MeseroOnSucursalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MeseroOnSucursal findMany
   */
  export type MeseroOnSucursalFindManyArgs = {
    /**
     * Select specific fields to fetch from the MeseroOnSucursal
     * 
    **/
    select?: MeseroOnSucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeseroOnSucursalInclude | null
    /**
     * Filter, which MeseroOnSucursals to fetch.
     * 
    **/
    where?: MeseroOnSucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeseroOnSucursals to fetch.
     * 
    **/
    orderBy?: Enumerable<MeseroOnSucursalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeseroOnSucursals.
     * 
    **/
    cursor?: MeseroOnSucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeseroOnSucursals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeseroOnSucursals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MeseroOnSucursalScalarFieldEnum>
  }


  /**
   * MeseroOnSucursal create
   */
  export type MeseroOnSucursalCreateArgs = {
    /**
     * Select specific fields to fetch from the MeseroOnSucursal
     * 
    **/
    select?: MeseroOnSucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeseroOnSucursalInclude | null
    /**
     * The data needed to create a MeseroOnSucursal.
     * 
    **/
    data: XOR<MeseroOnSucursalCreateInput, MeseroOnSucursalUncheckedCreateInput>
  }


  /**
   * MeseroOnSucursal createMany
   */
  export type MeseroOnSucursalCreateManyArgs = {
    /**
     * The data used to create many MeseroOnSucursals.
     * 
    **/
    data: Enumerable<MeseroOnSucursalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MeseroOnSucursal update
   */
  export type MeseroOnSucursalUpdateArgs = {
    /**
     * Select specific fields to fetch from the MeseroOnSucursal
     * 
    **/
    select?: MeseroOnSucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeseroOnSucursalInclude | null
    /**
     * The data needed to update a MeseroOnSucursal.
     * 
    **/
    data: XOR<MeseroOnSucursalUpdateInput, MeseroOnSucursalUncheckedUpdateInput>
    /**
     * Choose, which MeseroOnSucursal to update.
     * 
    **/
    where: MeseroOnSucursalWhereUniqueInput
  }


  /**
   * MeseroOnSucursal updateMany
   */
  export type MeseroOnSucursalUpdateManyArgs = {
    /**
     * The data used to update MeseroOnSucursals.
     * 
    **/
    data: XOR<MeseroOnSucursalUpdateManyMutationInput, MeseroOnSucursalUncheckedUpdateManyInput>
    /**
     * Filter which MeseroOnSucursals to update
     * 
    **/
    where?: MeseroOnSucursalWhereInput
  }


  /**
   * MeseroOnSucursal upsert
   */
  export type MeseroOnSucursalUpsertArgs = {
    /**
     * Select specific fields to fetch from the MeseroOnSucursal
     * 
    **/
    select?: MeseroOnSucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeseroOnSucursalInclude | null
    /**
     * The filter to search for the MeseroOnSucursal to update in case it exists.
     * 
    **/
    where: MeseroOnSucursalWhereUniqueInput
    /**
     * In case the MeseroOnSucursal found by the `where` argument doesn't exist, create a new MeseroOnSucursal with this data.
     * 
    **/
    create: XOR<MeseroOnSucursalCreateInput, MeseroOnSucursalUncheckedCreateInput>
    /**
     * In case the MeseroOnSucursal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MeseroOnSucursalUpdateInput, MeseroOnSucursalUncheckedUpdateInput>
  }


  /**
   * MeseroOnSucursal delete
   */
  export type MeseroOnSucursalDeleteArgs = {
    /**
     * Select specific fields to fetch from the MeseroOnSucursal
     * 
    **/
    select?: MeseroOnSucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeseroOnSucursalInclude | null
    /**
     * Filter which MeseroOnSucursal to delete.
     * 
    **/
    where: MeseroOnSucursalWhereUniqueInput
  }


  /**
   * MeseroOnSucursal deleteMany
   */
  export type MeseroOnSucursalDeleteManyArgs = {
    /**
     * Filter which MeseroOnSucursals to delete
     * 
    **/
    where?: MeseroOnSucursalWhereInput
  }


  /**
   * MeseroOnSucursal: findUniqueOrThrow
   */
  export type MeseroOnSucursalFindUniqueOrThrowArgs = MeseroOnSucursalFindUniqueArgsBase
      

  /**
   * MeseroOnSucursal: findFirstOrThrow
   */
  export type MeseroOnSucursalFindFirstOrThrowArgs = MeseroOnSucursalFindFirstArgsBase
      

  /**
   * MeseroOnSucursal without action
   */
  export type MeseroOnSucursalArgs = {
    /**
     * Select specific fields to fetch from the MeseroOnSucursal
     * 
    **/
    select?: MeseroOnSucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeseroOnSucursalInclude | null
  }



  /**
   * Model Sucursal
   */


  export type AggregateSucursal = {
    _count: SucursalCountAggregateOutputType | null
    _avg: SucursalAvgAggregateOutputType | null
    _sum: SucursalSumAggregateOutputType | null
    _min: SucursalMinAggregateOutputType | null
    _max: SucursalMaxAggregateOutputType | null
  }

  export type SucursalAvgAggregateOutputType = {
    id: number | null
    capacidad: number | null
  }

  export type SucursalSumAggregateOutputType = {
    id: bigint | null
    capacidad: bigint | null
  }

  export type SucursalMinAggregateOutputType = {
    id: bigint | null
    codigo: string | null
    nombre: string | null
    ubicacion: string | null
    capacidad: bigint | null
  }

  export type SucursalMaxAggregateOutputType = {
    id: bigint | null
    codigo: string | null
    nombre: string | null
    ubicacion: string | null
    capacidad: bigint | null
  }

  export type SucursalCountAggregateOutputType = {
    id: number
    codigo: number
    nombre: number
    ubicacion: number
    capacidad: number
    _all: number
  }


  export type SucursalAvgAggregateInputType = {
    id?: true
    capacidad?: true
  }

  export type SucursalSumAggregateInputType = {
    id?: true
    capacidad?: true
  }

  export type SucursalMinAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    ubicacion?: true
    capacidad?: true
  }

  export type SucursalMaxAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    ubicacion?: true
    capacidad?: true
  }

  export type SucursalCountAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    ubicacion?: true
    capacidad?: true
    _all?: true
  }

  export type SucursalAggregateArgs = {
    /**
     * Filter which Sucursal to aggregate.
     * 
    **/
    where?: SucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sucursals to fetch.
     * 
    **/
    orderBy?: Enumerable<SucursalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sucursals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sucursals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sucursals
    **/
    _count?: true | SucursalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SucursalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SucursalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SucursalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SucursalMaxAggregateInputType
  }

  export type GetSucursalAggregateType<T extends SucursalAggregateArgs> = {
        [P in keyof T & keyof AggregateSucursal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSucursal[P]>
      : GetScalarType<T[P], AggregateSucursal[P]>
  }




  export type SucursalGroupByArgs = {
    where?: SucursalWhereInput
    orderBy?: Enumerable<SucursalOrderByWithAggregationInput>
    by: Array<SucursalScalarFieldEnum>
    having?: SucursalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SucursalCountAggregateInputType | true
    _avg?: SucursalAvgAggregateInputType
    _sum?: SucursalSumAggregateInputType
    _min?: SucursalMinAggregateInputType
    _max?: SucursalMaxAggregateInputType
  }


  export type SucursalGroupByOutputType = {
    id: bigint
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint
    _count: SucursalCountAggregateOutputType | null
    _avg: SucursalAvgAggregateOutputType | null
    _sum: SucursalSumAggregateOutputType | null
    _min: SucursalMinAggregateOutputType | null
    _max: SucursalMaxAggregateOutputType | null
  }

  type GetSucursalGroupByPayload<T extends SucursalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SucursalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SucursalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SucursalGroupByOutputType[P]>
            : GetScalarType<T[P], SucursalGroupByOutputType[P]>
        }
      >
    >


  export type SucursalSelect = {
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    ubicacion?: boolean
    capacidad?: boolean
    mesas?: boolean | MesaFindManyArgs
    reservaciones?: boolean | ReservacionFindManyArgs
    productos?: boolean | Sucursal_ProductoFindManyArgs
    MeseroOnSucursal?: boolean | MeseroOnSucursalFindManyArgs
    _count?: boolean | SucursalCountOutputTypeArgs
  }

  export type SucursalInclude = {
    mesas?: boolean | MesaFindManyArgs
    reservaciones?: boolean | ReservacionFindManyArgs
    productos?: boolean | Sucursal_ProductoFindManyArgs
    MeseroOnSucursal?: boolean | MeseroOnSucursalFindManyArgs
    _count?: boolean | SucursalCountOutputTypeArgs
  }

  export type SucursalGetPayload<
    S extends boolean | null | undefined | SucursalArgs,
    U = keyof S
      > = S extends true
        ? Sucursal
    : S extends undefined
    ? never
    : S extends SucursalArgs | SucursalFindManyArgs
    ?'include' extends U
    ? Sucursal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'productos' ? Array < Sucursal_ProductoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'MeseroOnSucursal' ? Array < MeseroOnSucursalGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? SucursalCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'productos' ? Array < Sucursal_ProductoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'MeseroOnSucursal' ? Array < MeseroOnSucursalGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? SucursalCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Sucursal ? Sucursal[P] : never
  } 
    : Sucursal
  : Sucursal


  type SucursalCountArgs = Merge<
    Omit<SucursalFindManyArgs, 'select' | 'include'> & {
      select?: SucursalCountAggregateInputType | true
    }
  >

  export interface SucursalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Sucursal that matches the filter.
     * @param {SucursalFindUniqueArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SucursalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SucursalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sucursal'> extends True ? CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>> : CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>

    /**
     * Find the first Sucursal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalFindFirstArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SucursalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SucursalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sucursal'> extends True ? CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>> : CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>

    /**
     * Find zero or more Sucursals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sucursals
     * const sucursals = await prisma.sucursal.findMany()
     * 
     * // Get first 10 Sucursals
     * const sucursals = await prisma.sucursal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sucursalWithIdOnly = await prisma.sucursal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SucursalFindManyArgs>(
      args?: SelectSubset<T, SucursalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Sucursal>>, PrismaPromise<Array<SucursalGetPayload<T>>>>

    /**
     * Create a Sucursal.
     * @param {SucursalCreateArgs} args - Arguments to create a Sucursal.
     * @example
     * // Create one Sucursal
     * const Sucursal = await prisma.sucursal.create({
     *   data: {
     *     // ... data to create a Sucursal
     *   }
     * })
     * 
    **/
    create<T extends SucursalCreateArgs>(
      args: SelectSubset<T, SucursalCreateArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Create many Sucursals.
     *     @param {SucursalCreateManyArgs} args - Arguments to create many Sucursals.
     *     @example
     *     // Create many Sucursals
     *     const sucursal = await prisma.sucursal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SucursalCreateManyArgs>(
      args?: SelectSubset<T, SucursalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sucursal.
     * @param {SucursalDeleteArgs} args - Arguments to delete one Sucursal.
     * @example
     * // Delete one Sucursal
     * const Sucursal = await prisma.sucursal.delete({
     *   where: {
     *     // ... filter to delete one Sucursal
     *   }
     * })
     * 
    **/
    delete<T extends SucursalDeleteArgs>(
      args: SelectSubset<T, SucursalDeleteArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Update one Sucursal.
     * @param {SucursalUpdateArgs} args - Arguments to update one Sucursal.
     * @example
     * // Update one Sucursal
     * const sucursal = await prisma.sucursal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SucursalUpdateArgs>(
      args: SelectSubset<T, SucursalUpdateArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Delete zero or more Sucursals.
     * @param {SucursalDeleteManyArgs} args - Arguments to filter Sucursals to delete.
     * @example
     * // Delete a few Sucursals
     * const { count } = await prisma.sucursal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SucursalDeleteManyArgs>(
      args?: SelectSubset<T, SucursalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sucursals
     * const sucursal = await prisma.sucursal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SucursalUpdateManyArgs>(
      args: SelectSubset<T, SucursalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sucursal.
     * @param {SucursalUpsertArgs} args - Arguments to update or create a Sucursal.
     * @example
     * // Update or create a Sucursal
     * const sucursal = await prisma.sucursal.upsert({
     *   create: {
     *     // ... data to create a Sucursal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sucursal we want to update
     *   }
     * })
    **/
    upsert<T extends SucursalUpsertArgs>(
      args: SelectSubset<T, SucursalUpsertArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Find one Sucursal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SucursalFindUniqueOrThrowArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SucursalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SucursalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Find the first Sucursal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalFindFirstOrThrowArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SucursalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SucursalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Count the number of Sucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalCountArgs} args - Arguments to filter Sucursals to count.
     * @example
     * // Count the number of Sucursals
     * const count = await prisma.sucursal.count({
     *   where: {
     *     // ... the filter for the Sucursals we want to count
     *   }
     * })
    **/
    count<T extends SucursalCountArgs>(
      args?: Subset<T, SucursalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SucursalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SucursalAggregateArgs>(args: Subset<T, SucursalAggregateArgs>): PrismaPromise<GetSucursalAggregateType<T>>

    /**
     * Group by Sucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SucursalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SucursalGroupByArgs['orderBy'] }
        : { orderBy?: SucursalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SucursalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSucursalGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Sucursal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SucursalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    mesas<T extends MesaFindManyArgs = {}>(args?: Subset<T, MesaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mesa>>, PrismaPromise<Array<MesaGetPayload<T>>>>;

    reservaciones<T extends ReservacionFindManyArgs = {}>(args?: Subset<T, ReservacionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reservacion>>, PrismaPromise<Array<ReservacionGetPayload<T>>>>;

    productos<T extends Sucursal_ProductoFindManyArgs = {}>(args?: Subset<T, Sucursal_ProductoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Sucursal_Producto>>, PrismaPromise<Array<Sucursal_ProductoGetPayload<T>>>>;

    MeseroOnSucursal<T extends MeseroOnSucursalFindManyArgs = {}>(args?: Subset<T, MeseroOnSucursalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MeseroOnSucursal>>, PrismaPromise<Array<MeseroOnSucursalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Sucursal base type for findUnique actions
   */
  export type SucursalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * Filter, which Sucursal to fetch.
     * 
    **/
    where: SucursalWhereUniqueInput
  }

  /**
   * Sucursal: findUnique
   */
  export interface SucursalFindUniqueArgs extends SucursalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sucursal base type for findFirst actions
   */
  export type SucursalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * Filter, which Sucursal to fetch.
     * 
    **/
    where?: SucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sucursals to fetch.
     * 
    **/
    orderBy?: Enumerable<SucursalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sucursals.
     * 
    **/
    cursor?: SucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sucursals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sucursals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sucursals.
     * 
    **/
    distinct?: Enumerable<SucursalScalarFieldEnum>
  }

  /**
   * Sucursal: findFirst
   */
  export interface SucursalFindFirstArgs extends SucursalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sucursal findMany
   */
  export type SucursalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * Filter, which Sucursals to fetch.
     * 
    **/
    where?: SucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sucursals to fetch.
     * 
    **/
    orderBy?: Enumerable<SucursalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sucursals.
     * 
    **/
    cursor?: SucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sucursals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sucursals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SucursalScalarFieldEnum>
  }


  /**
   * Sucursal create
   */
  export type SucursalCreateArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * The data needed to create a Sucursal.
     * 
    **/
    data: XOR<SucursalCreateInput, SucursalUncheckedCreateInput>
  }


  /**
   * Sucursal createMany
   */
  export type SucursalCreateManyArgs = {
    /**
     * The data used to create many Sucursals.
     * 
    **/
    data: Enumerable<SucursalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Sucursal update
   */
  export type SucursalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * The data needed to update a Sucursal.
     * 
    **/
    data: XOR<SucursalUpdateInput, SucursalUncheckedUpdateInput>
    /**
     * Choose, which Sucursal to update.
     * 
    **/
    where: SucursalWhereUniqueInput
  }


  /**
   * Sucursal updateMany
   */
  export type SucursalUpdateManyArgs = {
    /**
     * The data used to update Sucursals.
     * 
    **/
    data: XOR<SucursalUpdateManyMutationInput, SucursalUncheckedUpdateManyInput>
    /**
     * Filter which Sucursals to update
     * 
    **/
    where?: SucursalWhereInput
  }


  /**
   * Sucursal upsert
   */
  export type SucursalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * The filter to search for the Sucursal to update in case it exists.
     * 
    **/
    where: SucursalWhereUniqueInput
    /**
     * In case the Sucursal found by the `where` argument doesn't exist, create a new Sucursal with this data.
     * 
    **/
    create: XOR<SucursalCreateInput, SucursalUncheckedCreateInput>
    /**
     * In case the Sucursal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SucursalUpdateInput, SucursalUncheckedUpdateInput>
  }


  /**
   * Sucursal delete
   */
  export type SucursalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * Filter which Sucursal to delete.
     * 
    **/
    where: SucursalWhereUniqueInput
  }


  /**
   * Sucursal deleteMany
   */
  export type SucursalDeleteManyArgs = {
    /**
     * Filter which Sucursals to delete
     * 
    **/
    where?: SucursalWhereInput
  }


  /**
   * Sucursal: findUniqueOrThrow
   */
  export type SucursalFindUniqueOrThrowArgs = SucursalFindUniqueArgsBase
      

  /**
   * Sucursal: findFirstOrThrow
   */
  export type SucursalFindFirstOrThrowArgs = SucursalFindFirstArgsBase
      

  /**
   * Sucursal without action
   */
  export type SucursalArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
  }



  /**
   * Model Mesa
   */


  export type AggregateMesa = {
    _count: MesaCountAggregateOutputType | null
    _avg: MesaAvgAggregateOutputType | null
    _sum: MesaSumAggregateOutputType | null
    _min: MesaMinAggregateOutputType | null
    _max: MesaMaxAggregateOutputType | null
  }

  export type MesaAvgAggregateOutputType = {
    id: number | null
    capacidad: number | null
    disponibilidad: number | null
    idSucursal: number | null
    idEstadoMesa: number | null
  }

  export type MesaSumAggregateOutputType = {
    id: bigint | null
    capacidad: number | null
    disponibilidad: number | null
    idSucursal: bigint | null
    idEstadoMesa: number | null
  }

  export type MesaMinAggregateOutputType = {
    id: bigint | null
    codigo: string | null
    capacidad: number | null
    disponibilidad: number | null
    estado: boolean | null
    idSucursal: bigint | null
    idEstadoMesa: number | null
  }

  export type MesaMaxAggregateOutputType = {
    id: bigint | null
    codigo: string | null
    capacidad: number | null
    disponibilidad: number | null
    estado: boolean | null
    idSucursal: bigint | null
    idEstadoMesa: number | null
  }

  export type MesaCountAggregateOutputType = {
    id: number
    codigo: number
    capacidad: number
    disponibilidad: number
    estado: number
    idSucursal: number
    idEstadoMesa: number
    _all: number
  }


  export type MesaAvgAggregateInputType = {
    id?: true
    capacidad?: true
    disponibilidad?: true
    idSucursal?: true
    idEstadoMesa?: true
  }

  export type MesaSumAggregateInputType = {
    id?: true
    capacidad?: true
    disponibilidad?: true
    idSucursal?: true
    idEstadoMesa?: true
  }

  export type MesaMinAggregateInputType = {
    id?: true
    codigo?: true
    capacidad?: true
    disponibilidad?: true
    estado?: true
    idSucursal?: true
    idEstadoMesa?: true
  }

  export type MesaMaxAggregateInputType = {
    id?: true
    codigo?: true
    capacidad?: true
    disponibilidad?: true
    estado?: true
    idSucursal?: true
    idEstadoMesa?: true
  }

  export type MesaCountAggregateInputType = {
    id?: true
    codigo?: true
    capacidad?: true
    disponibilidad?: true
    estado?: true
    idSucursal?: true
    idEstadoMesa?: true
    _all?: true
  }

  export type MesaAggregateArgs = {
    /**
     * Filter which Mesa to aggregate.
     * 
    **/
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     * 
    **/
    orderBy?: Enumerable<MesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mesas
    **/
    _count?: true | MesaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MesaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MesaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MesaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MesaMaxAggregateInputType
  }

  export type GetMesaAggregateType<T extends MesaAggregateArgs> = {
        [P in keyof T & keyof AggregateMesa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMesa[P]>
      : GetScalarType<T[P], AggregateMesa[P]>
  }




  export type MesaGroupByArgs = {
    where?: MesaWhereInput
    orderBy?: Enumerable<MesaOrderByWithAggregationInput>
    by: Array<MesaScalarFieldEnum>
    having?: MesaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MesaCountAggregateInputType | true
    _avg?: MesaAvgAggregateInputType
    _sum?: MesaSumAggregateInputType
    _min?: MesaMinAggregateInputType
    _max?: MesaMaxAggregateInputType
  }


  export type MesaGroupByOutputType = {
    id: bigint
    codigo: string
    capacidad: number
    disponibilidad: number
    estado: boolean
    idSucursal: bigint
    idEstadoMesa: number
    _count: MesaCountAggregateOutputType | null
    _avg: MesaAvgAggregateOutputType | null
    _sum: MesaSumAggregateOutputType | null
    _min: MesaMinAggregateOutputType | null
    _max: MesaMaxAggregateOutputType | null
  }

  type GetMesaGroupByPayload<T extends MesaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MesaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MesaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MesaGroupByOutputType[P]>
            : GetScalarType<T[P], MesaGroupByOutputType[P]>
        }
      >
    >


  export type MesaSelect = {
    id?: boolean
    codigo?: boolean
    capacidad?: boolean
    disponibilidad?: boolean
    estado?: boolean
    reservaciones?: boolean | Reservacion_MesaFindManyArgs
    Sucursal?: boolean | SucursalArgs
    idSucursal?: boolean
    EstadoMesa?: boolean | EstadoMesaArgs
    idEstadoMesa?: boolean
    _count?: boolean | MesaCountOutputTypeArgs
  }

  export type MesaInclude = {
    reservaciones?: boolean | Reservacion_MesaFindManyArgs
    Sucursal?: boolean | SucursalArgs
    EstadoMesa?: boolean | EstadoMesaArgs
    _count?: boolean | MesaCountOutputTypeArgs
  }

  export type MesaGetPayload<
    S extends boolean | null | undefined | MesaArgs,
    U = keyof S
      > = S extends true
        ? Mesa
    : S extends undefined
    ? never
    : S extends MesaArgs | MesaFindManyArgs
    ?'include' extends U
    ? Mesa  & {
    [P in TrueKeys<S['include']>]:
        P extends 'reservaciones' ? Array < Reservacion_MesaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'EstadoMesa' ? EstadoMesaGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? MesaCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'reservaciones' ? Array < Reservacion_MesaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'EstadoMesa' ? EstadoMesaGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? MesaCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Mesa ? Mesa[P] : never
  } 
    : Mesa
  : Mesa


  type MesaCountArgs = Merge<
    Omit<MesaFindManyArgs, 'select' | 'include'> & {
      select?: MesaCountAggregateInputType | true
    }
  >

  export interface MesaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Mesa that matches the filter.
     * @param {MesaFindUniqueArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MesaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MesaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Mesa'> extends True ? CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>> : CheckSelect<T, Prisma__MesaClient<Mesa | null >, Prisma__MesaClient<MesaGetPayload<T> | null >>

    /**
     * Find the first Mesa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaFindFirstArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MesaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MesaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Mesa'> extends True ? CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>> : CheckSelect<T, Prisma__MesaClient<Mesa | null >, Prisma__MesaClient<MesaGetPayload<T> | null >>

    /**
     * Find zero or more Mesas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mesas
     * const mesas = await prisma.mesa.findMany()
     * 
     * // Get first 10 Mesas
     * const mesas = await prisma.mesa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mesaWithIdOnly = await prisma.mesa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MesaFindManyArgs>(
      args?: SelectSubset<T, MesaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Mesa>>, PrismaPromise<Array<MesaGetPayload<T>>>>

    /**
     * Create a Mesa.
     * @param {MesaCreateArgs} args - Arguments to create a Mesa.
     * @example
     * // Create one Mesa
     * const Mesa = await prisma.mesa.create({
     *   data: {
     *     // ... data to create a Mesa
     *   }
     * })
     * 
    **/
    create<T extends MesaCreateArgs>(
      args: SelectSubset<T, MesaCreateArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Create many Mesas.
     *     @param {MesaCreateManyArgs} args - Arguments to create many Mesas.
     *     @example
     *     // Create many Mesas
     *     const mesa = await prisma.mesa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MesaCreateManyArgs>(
      args?: SelectSubset<T, MesaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Mesa.
     * @param {MesaDeleteArgs} args - Arguments to delete one Mesa.
     * @example
     * // Delete one Mesa
     * const Mesa = await prisma.mesa.delete({
     *   where: {
     *     // ... filter to delete one Mesa
     *   }
     * })
     * 
    **/
    delete<T extends MesaDeleteArgs>(
      args: SelectSubset<T, MesaDeleteArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Update one Mesa.
     * @param {MesaUpdateArgs} args - Arguments to update one Mesa.
     * @example
     * // Update one Mesa
     * const mesa = await prisma.mesa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MesaUpdateArgs>(
      args: SelectSubset<T, MesaUpdateArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Delete zero or more Mesas.
     * @param {MesaDeleteManyArgs} args - Arguments to filter Mesas to delete.
     * @example
     * // Delete a few Mesas
     * const { count } = await prisma.mesa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MesaDeleteManyArgs>(
      args?: SelectSubset<T, MesaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mesas
     * const mesa = await prisma.mesa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MesaUpdateManyArgs>(
      args: SelectSubset<T, MesaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Mesa.
     * @param {MesaUpsertArgs} args - Arguments to update or create a Mesa.
     * @example
     * // Update or create a Mesa
     * const mesa = await prisma.mesa.upsert({
     *   create: {
     *     // ... data to create a Mesa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mesa we want to update
     *   }
     * })
    **/
    upsert<T extends MesaUpsertArgs>(
      args: SelectSubset<T, MesaUpsertArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Find one Mesa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {MesaFindUniqueOrThrowArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MesaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MesaFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Find the first Mesa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaFindFirstOrThrowArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MesaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MesaFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Count the number of Mesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaCountArgs} args - Arguments to filter Mesas to count.
     * @example
     * // Count the number of Mesas
     * const count = await prisma.mesa.count({
     *   where: {
     *     // ... the filter for the Mesas we want to count
     *   }
     * })
    **/
    count<T extends MesaCountArgs>(
      args?: Subset<T, MesaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MesaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MesaAggregateArgs>(args: Subset<T, MesaAggregateArgs>): PrismaPromise<GetMesaAggregateType<T>>

    /**
     * Group by Mesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MesaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MesaGroupByArgs['orderBy'] }
        : { orderBy?: MesaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MesaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMesaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Mesa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MesaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    reservaciones<T extends Reservacion_MesaFindManyArgs = {}>(args?: Subset<T, Reservacion_MesaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reservacion_Mesa>>, PrismaPromise<Array<Reservacion_MesaGetPayload<T>>>>;

    Sucursal<T extends SucursalArgs = {}>(args?: Subset<T, SucursalArgs>): CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>;

    EstadoMesa<T extends EstadoMesaArgs = {}>(args?: Subset<T, EstadoMesaArgs>): CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa | null >, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Mesa base type for findUnique actions
   */
  export type MesaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * Filter, which Mesa to fetch.
     * 
    **/
    where: MesaWhereUniqueInput
  }

  /**
   * Mesa: findUnique
   */
  export interface MesaFindUniqueArgs extends MesaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Mesa base type for findFirst actions
   */
  export type MesaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * Filter, which Mesa to fetch.
     * 
    **/
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     * 
    **/
    orderBy?: Enumerable<MesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mesas.
     * 
    **/
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mesas.
     * 
    **/
    distinct?: Enumerable<MesaScalarFieldEnum>
  }

  /**
   * Mesa: findFirst
   */
  export interface MesaFindFirstArgs extends MesaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Mesa findMany
   */
  export type MesaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * Filter, which Mesas to fetch.
     * 
    **/
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     * 
    **/
    orderBy?: Enumerable<MesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mesas.
     * 
    **/
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MesaScalarFieldEnum>
  }


  /**
   * Mesa create
   */
  export type MesaCreateArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * The data needed to create a Mesa.
     * 
    **/
    data: XOR<MesaCreateInput, MesaUncheckedCreateInput>
  }


  /**
   * Mesa createMany
   */
  export type MesaCreateManyArgs = {
    /**
     * The data used to create many Mesas.
     * 
    **/
    data: Enumerable<MesaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Mesa update
   */
  export type MesaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * The data needed to update a Mesa.
     * 
    **/
    data: XOR<MesaUpdateInput, MesaUncheckedUpdateInput>
    /**
     * Choose, which Mesa to update.
     * 
    **/
    where: MesaWhereUniqueInput
  }


  /**
   * Mesa updateMany
   */
  export type MesaUpdateManyArgs = {
    /**
     * The data used to update Mesas.
     * 
    **/
    data: XOR<MesaUpdateManyMutationInput, MesaUncheckedUpdateManyInput>
    /**
     * Filter which Mesas to update
     * 
    **/
    where?: MesaWhereInput
  }


  /**
   * Mesa upsert
   */
  export type MesaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * The filter to search for the Mesa to update in case it exists.
     * 
    **/
    where: MesaWhereUniqueInput
    /**
     * In case the Mesa found by the `where` argument doesn't exist, create a new Mesa with this data.
     * 
    **/
    create: XOR<MesaCreateInput, MesaUncheckedCreateInput>
    /**
     * In case the Mesa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MesaUpdateInput, MesaUncheckedUpdateInput>
  }


  /**
   * Mesa delete
   */
  export type MesaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * Filter which Mesa to delete.
     * 
    **/
    where: MesaWhereUniqueInput
  }


  /**
   * Mesa deleteMany
   */
  export type MesaDeleteManyArgs = {
    /**
     * Filter which Mesas to delete
     * 
    **/
    where?: MesaWhereInput
  }


  /**
   * Mesa: findUniqueOrThrow
   */
  export type MesaFindUniqueOrThrowArgs = MesaFindUniqueArgsBase
      

  /**
   * Mesa: findFirstOrThrow
   */
  export type MesaFindFirstOrThrowArgs = MesaFindFirstArgsBase
      

  /**
   * Mesa without action
   */
  export type MesaArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
  }



  /**
   * Model EstadoMesa
   */


  export type AggregateEstadoMesa = {
    _count: EstadoMesaCountAggregateOutputType | null
    _avg: EstadoMesaAvgAggregateOutputType | null
    _sum: EstadoMesaSumAggregateOutputType | null
    _min: EstadoMesaMinAggregateOutputType | null
    _max: EstadoMesaMaxAggregateOutputType | null
  }

  export type EstadoMesaAvgAggregateOutputType = {
    id: number | null
  }

  export type EstadoMesaSumAggregateOutputType = {
    id: number | null
  }

  export type EstadoMesaMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type EstadoMesaMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type EstadoMesaCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type EstadoMesaAvgAggregateInputType = {
    id?: true
  }

  export type EstadoMesaSumAggregateInputType = {
    id?: true
  }

  export type EstadoMesaMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type EstadoMesaMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type EstadoMesaCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type EstadoMesaAggregateArgs = {
    /**
     * Filter which EstadoMesa to aggregate.
     * 
    **/
    where?: EstadoMesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoMesas to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoMesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EstadoMesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoMesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoMesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EstadoMesas
    **/
    _count?: true | EstadoMesaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoMesaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoMesaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoMesaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoMesaMaxAggregateInputType
  }

  export type GetEstadoMesaAggregateType<T extends EstadoMesaAggregateArgs> = {
        [P in keyof T & keyof AggregateEstadoMesa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstadoMesa[P]>
      : GetScalarType<T[P], AggregateEstadoMesa[P]>
  }




  export type EstadoMesaGroupByArgs = {
    where?: EstadoMesaWhereInput
    orderBy?: Enumerable<EstadoMesaOrderByWithAggregationInput>
    by: Array<EstadoMesaScalarFieldEnum>
    having?: EstadoMesaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoMesaCountAggregateInputType | true
    _avg?: EstadoMesaAvgAggregateInputType
    _sum?: EstadoMesaSumAggregateInputType
    _min?: EstadoMesaMinAggregateInputType
    _max?: EstadoMesaMaxAggregateInputType
  }


  export type EstadoMesaGroupByOutputType = {
    id: number
    descripcion: string
    _count: EstadoMesaCountAggregateOutputType | null
    _avg: EstadoMesaAvgAggregateOutputType | null
    _sum: EstadoMesaSumAggregateOutputType | null
    _min: EstadoMesaMinAggregateOutputType | null
    _max: EstadoMesaMaxAggregateOutputType | null
  }

  type GetEstadoMesaGroupByPayload<T extends EstadoMesaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EstadoMesaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoMesaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoMesaGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoMesaGroupByOutputType[P]>
        }
      >
    >


  export type EstadoMesaSelect = {
    id?: boolean
    descripcion?: boolean
    mesas?: boolean | MesaFindManyArgs
    _count?: boolean | EstadoMesaCountOutputTypeArgs
  }

  export type EstadoMesaInclude = {
    mesas?: boolean | MesaFindManyArgs
    _count?: boolean | EstadoMesaCountOutputTypeArgs
  }

  export type EstadoMesaGetPayload<
    S extends boolean | null | undefined | EstadoMesaArgs,
    U = keyof S
      > = S extends true
        ? EstadoMesa
    : S extends undefined
    ? never
    : S extends EstadoMesaArgs | EstadoMesaFindManyArgs
    ?'include' extends U
    ? EstadoMesa  & {
    [P in TrueKeys<S['include']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? EstadoMesaCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? EstadoMesaCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof EstadoMesa ? EstadoMesa[P] : never
  } 
    : EstadoMesa
  : EstadoMesa


  type EstadoMesaCountArgs = Merge<
    Omit<EstadoMesaFindManyArgs, 'select' | 'include'> & {
      select?: EstadoMesaCountAggregateInputType | true
    }
  >

  export interface EstadoMesaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EstadoMesa that matches the filter.
     * @param {EstadoMesaFindUniqueArgs} args - Arguments to find a EstadoMesa
     * @example
     * // Get one EstadoMesa
     * const estadoMesa = await prisma.estadoMesa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EstadoMesaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EstadoMesaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EstadoMesa'> extends True ? CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa>, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T>>> : CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa | null >, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T> | null >>

    /**
     * Find the first EstadoMesa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoMesaFindFirstArgs} args - Arguments to find a EstadoMesa
     * @example
     * // Get one EstadoMesa
     * const estadoMesa = await prisma.estadoMesa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EstadoMesaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EstadoMesaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EstadoMesa'> extends True ? CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa>, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T>>> : CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa | null >, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T> | null >>

    /**
     * Find zero or more EstadoMesas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoMesaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EstadoMesas
     * const estadoMesas = await prisma.estadoMesa.findMany()
     * 
     * // Get first 10 EstadoMesas
     * const estadoMesas = await prisma.estadoMesa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estadoMesaWithIdOnly = await prisma.estadoMesa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EstadoMesaFindManyArgs>(
      args?: SelectSubset<T, EstadoMesaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EstadoMesa>>, PrismaPromise<Array<EstadoMesaGetPayload<T>>>>

    /**
     * Create a EstadoMesa.
     * @param {EstadoMesaCreateArgs} args - Arguments to create a EstadoMesa.
     * @example
     * // Create one EstadoMesa
     * const EstadoMesa = await prisma.estadoMesa.create({
     *   data: {
     *     // ... data to create a EstadoMesa
     *   }
     * })
     * 
    **/
    create<T extends EstadoMesaCreateArgs>(
      args: SelectSubset<T, EstadoMesaCreateArgs>
    ): CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa>, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T>>>

    /**
     * Create many EstadoMesas.
     *     @param {EstadoMesaCreateManyArgs} args - Arguments to create many EstadoMesas.
     *     @example
     *     // Create many EstadoMesas
     *     const estadoMesa = await prisma.estadoMesa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EstadoMesaCreateManyArgs>(
      args?: SelectSubset<T, EstadoMesaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EstadoMesa.
     * @param {EstadoMesaDeleteArgs} args - Arguments to delete one EstadoMesa.
     * @example
     * // Delete one EstadoMesa
     * const EstadoMesa = await prisma.estadoMesa.delete({
     *   where: {
     *     // ... filter to delete one EstadoMesa
     *   }
     * })
     * 
    **/
    delete<T extends EstadoMesaDeleteArgs>(
      args: SelectSubset<T, EstadoMesaDeleteArgs>
    ): CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa>, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T>>>

    /**
     * Update one EstadoMesa.
     * @param {EstadoMesaUpdateArgs} args - Arguments to update one EstadoMesa.
     * @example
     * // Update one EstadoMesa
     * const estadoMesa = await prisma.estadoMesa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EstadoMesaUpdateArgs>(
      args: SelectSubset<T, EstadoMesaUpdateArgs>
    ): CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa>, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T>>>

    /**
     * Delete zero or more EstadoMesas.
     * @param {EstadoMesaDeleteManyArgs} args - Arguments to filter EstadoMesas to delete.
     * @example
     * // Delete a few EstadoMesas
     * const { count } = await prisma.estadoMesa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EstadoMesaDeleteManyArgs>(
      args?: SelectSubset<T, EstadoMesaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstadoMesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoMesaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EstadoMesas
     * const estadoMesa = await prisma.estadoMesa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EstadoMesaUpdateManyArgs>(
      args: SelectSubset<T, EstadoMesaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EstadoMesa.
     * @param {EstadoMesaUpsertArgs} args - Arguments to update or create a EstadoMesa.
     * @example
     * // Update or create a EstadoMesa
     * const estadoMesa = await prisma.estadoMesa.upsert({
     *   create: {
     *     // ... data to create a EstadoMesa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EstadoMesa we want to update
     *   }
     * })
    **/
    upsert<T extends EstadoMesaUpsertArgs>(
      args: SelectSubset<T, EstadoMesaUpsertArgs>
    ): CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa>, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T>>>

    /**
     * Find one EstadoMesa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {EstadoMesaFindUniqueOrThrowArgs} args - Arguments to find a EstadoMesa
     * @example
     * // Get one EstadoMesa
     * const estadoMesa = await prisma.estadoMesa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EstadoMesaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EstadoMesaFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa>, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T>>>

    /**
     * Find the first EstadoMesa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoMesaFindFirstOrThrowArgs} args - Arguments to find a EstadoMesa
     * @example
     * // Get one EstadoMesa
     * const estadoMesa = await prisma.estadoMesa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EstadoMesaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EstadoMesaFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__EstadoMesaClient<EstadoMesa>, Prisma__EstadoMesaClient<EstadoMesaGetPayload<T>>>

    /**
     * Count the number of EstadoMesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoMesaCountArgs} args - Arguments to filter EstadoMesas to count.
     * @example
     * // Count the number of EstadoMesas
     * const count = await prisma.estadoMesa.count({
     *   where: {
     *     // ... the filter for the EstadoMesas we want to count
     *   }
     * })
    **/
    count<T extends EstadoMesaCountArgs>(
      args?: Subset<T, EstadoMesaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoMesaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EstadoMesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoMesaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoMesaAggregateArgs>(args: Subset<T, EstadoMesaAggregateArgs>): PrismaPromise<GetEstadoMesaAggregateType<T>>

    /**
     * Group by EstadoMesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoMesaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstadoMesaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstadoMesaGroupByArgs['orderBy'] }
        : { orderBy?: EstadoMesaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstadoMesaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoMesaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EstadoMesa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EstadoMesaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    mesas<T extends MesaFindManyArgs = {}>(args?: Subset<T, MesaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mesa>>, PrismaPromise<Array<MesaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EstadoMesa base type for findUnique actions
   */
  export type EstadoMesaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EstadoMesa
     * 
    **/
    select?: EstadoMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoMesaInclude | null
    /**
     * Filter, which EstadoMesa to fetch.
     * 
    **/
    where: EstadoMesaWhereUniqueInput
  }

  /**
   * EstadoMesa: findUnique
   */
  export interface EstadoMesaFindUniqueArgs extends EstadoMesaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EstadoMesa base type for findFirst actions
   */
  export type EstadoMesaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EstadoMesa
     * 
    **/
    select?: EstadoMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoMesaInclude | null
    /**
     * Filter, which EstadoMesa to fetch.
     * 
    **/
    where?: EstadoMesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoMesas to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoMesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstadoMesas.
     * 
    **/
    cursor?: EstadoMesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoMesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoMesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstadoMesas.
     * 
    **/
    distinct?: Enumerable<EstadoMesaScalarFieldEnum>
  }

  /**
   * EstadoMesa: findFirst
   */
  export interface EstadoMesaFindFirstArgs extends EstadoMesaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EstadoMesa findMany
   */
  export type EstadoMesaFindManyArgs = {
    /**
     * Select specific fields to fetch from the EstadoMesa
     * 
    **/
    select?: EstadoMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoMesaInclude | null
    /**
     * Filter, which EstadoMesas to fetch.
     * 
    **/
    where?: EstadoMesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoMesas to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoMesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EstadoMesas.
     * 
    **/
    cursor?: EstadoMesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoMesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoMesas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EstadoMesaScalarFieldEnum>
  }


  /**
   * EstadoMesa create
   */
  export type EstadoMesaCreateArgs = {
    /**
     * Select specific fields to fetch from the EstadoMesa
     * 
    **/
    select?: EstadoMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoMesaInclude | null
    /**
     * The data needed to create a EstadoMesa.
     * 
    **/
    data: XOR<EstadoMesaCreateInput, EstadoMesaUncheckedCreateInput>
  }


  /**
   * EstadoMesa createMany
   */
  export type EstadoMesaCreateManyArgs = {
    /**
     * The data used to create many EstadoMesas.
     * 
    **/
    data: Enumerable<EstadoMesaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EstadoMesa update
   */
  export type EstadoMesaUpdateArgs = {
    /**
     * Select specific fields to fetch from the EstadoMesa
     * 
    **/
    select?: EstadoMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoMesaInclude | null
    /**
     * The data needed to update a EstadoMesa.
     * 
    **/
    data: XOR<EstadoMesaUpdateInput, EstadoMesaUncheckedUpdateInput>
    /**
     * Choose, which EstadoMesa to update.
     * 
    **/
    where: EstadoMesaWhereUniqueInput
  }


  /**
   * EstadoMesa updateMany
   */
  export type EstadoMesaUpdateManyArgs = {
    /**
     * The data used to update EstadoMesas.
     * 
    **/
    data: XOR<EstadoMesaUpdateManyMutationInput, EstadoMesaUncheckedUpdateManyInput>
    /**
     * Filter which EstadoMesas to update
     * 
    **/
    where?: EstadoMesaWhereInput
  }


  /**
   * EstadoMesa upsert
   */
  export type EstadoMesaUpsertArgs = {
    /**
     * Select specific fields to fetch from the EstadoMesa
     * 
    **/
    select?: EstadoMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoMesaInclude | null
    /**
     * The filter to search for the EstadoMesa to update in case it exists.
     * 
    **/
    where: EstadoMesaWhereUniqueInput
    /**
     * In case the EstadoMesa found by the `where` argument doesn't exist, create a new EstadoMesa with this data.
     * 
    **/
    create: XOR<EstadoMesaCreateInput, EstadoMesaUncheckedCreateInput>
    /**
     * In case the EstadoMesa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EstadoMesaUpdateInput, EstadoMesaUncheckedUpdateInput>
  }


  /**
   * EstadoMesa delete
   */
  export type EstadoMesaDeleteArgs = {
    /**
     * Select specific fields to fetch from the EstadoMesa
     * 
    **/
    select?: EstadoMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoMesaInclude | null
    /**
     * Filter which EstadoMesa to delete.
     * 
    **/
    where: EstadoMesaWhereUniqueInput
  }


  /**
   * EstadoMesa deleteMany
   */
  export type EstadoMesaDeleteManyArgs = {
    /**
     * Filter which EstadoMesas to delete
     * 
    **/
    where?: EstadoMesaWhereInput
  }


  /**
   * EstadoMesa: findUniqueOrThrow
   */
  export type EstadoMesaFindUniqueOrThrowArgs = EstadoMesaFindUniqueArgsBase
      

  /**
   * EstadoMesa: findFirstOrThrow
   */
  export type EstadoMesaFindFirstOrThrowArgs = EstadoMesaFindFirstArgsBase
      

  /**
   * EstadoMesa without action
   */
  export type EstadoMesaArgs = {
    /**
     * Select specific fields to fetch from the EstadoMesa
     * 
    **/
    select?: EstadoMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoMesaInclude | null
  }



  /**
   * Model Reservacion
   */


  export type AggregateReservacion = {
    _count: ReservacionCountAggregateOutputType | null
    _avg: ReservacionAvgAggregateOutputType | null
    _sum: ReservacionSumAggregateOutputType | null
    _min: ReservacionMinAggregateOutputType | null
    _max: ReservacionMaxAggregateOutputType | null
  }

  export type ReservacionAvgAggregateOutputType = {
    id: number | null
    idSucursal: number | null
  }

  export type ReservacionSumAggregateOutputType = {
    id: bigint | null
    idSucursal: bigint | null
  }

  export type ReservacionMinAggregateOutputType = {
    id: bigint | null
    fecha_hora: Date | null
    idSucursal: bigint | null
    idUsuario: string | null
  }

  export type ReservacionMaxAggregateOutputType = {
    id: bigint | null
    fecha_hora: Date | null
    idSucursal: bigint | null
    idUsuario: string | null
  }

  export type ReservacionCountAggregateOutputType = {
    id: number
    fecha_hora: number
    idSucursal: number
    idUsuario: number
    _all: number
  }


  export type ReservacionAvgAggregateInputType = {
    id?: true
    idSucursal?: true
  }

  export type ReservacionSumAggregateInputType = {
    id?: true
    idSucursal?: true
  }

  export type ReservacionMinAggregateInputType = {
    id?: true
    fecha_hora?: true
    idSucursal?: true
    idUsuario?: true
  }

  export type ReservacionMaxAggregateInputType = {
    id?: true
    fecha_hora?: true
    idSucursal?: true
    idUsuario?: true
  }

  export type ReservacionCountAggregateInputType = {
    id?: true
    fecha_hora?: true
    idSucursal?: true
    idUsuario?: true
    _all?: true
  }

  export type ReservacionAggregateArgs = {
    /**
     * Filter which Reservacion to aggregate.
     * 
    **/
    where?: ReservacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservacions to fetch.
     * 
    **/
    orderBy?: Enumerable<ReservacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReservacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservacions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservacions
    **/
    _count?: true | ReservacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservacionMaxAggregateInputType
  }

  export type GetReservacionAggregateType<T extends ReservacionAggregateArgs> = {
        [P in keyof T & keyof AggregateReservacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservacion[P]>
      : GetScalarType<T[P], AggregateReservacion[P]>
  }




  export type ReservacionGroupByArgs = {
    where?: ReservacionWhereInput
    orderBy?: Enumerable<ReservacionOrderByWithAggregationInput>
    by: Array<ReservacionScalarFieldEnum>
    having?: ReservacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservacionCountAggregateInputType | true
    _avg?: ReservacionAvgAggregateInputType
    _sum?: ReservacionSumAggregateInputType
    _min?: ReservacionMinAggregateInputType
    _max?: ReservacionMaxAggregateInputType
  }


  export type ReservacionGroupByOutputType = {
    id: bigint
    fecha_hora: Date
    idSucursal: bigint
    idUsuario: string
    _count: ReservacionCountAggregateOutputType | null
    _avg: ReservacionAvgAggregateOutputType | null
    _sum: ReservacionSumAggregateOutputType | null
    _min: ReservacionMinAggregateOutputType | null
    _max: ReservacionMaxAggregateOutputType | null
  }

  type GetReservacionGroupByPayload<T extends ReservacionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReservacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservacionGroupByOutputType[P]>
            : GetScalarType<T[P], ReservacionGroupByOutputType[P]>
        }
      >
    >


  export type ReservacionSelect = {
    id?: boolean
    fecha_hora?: boolean
    mesas?: boolean | Reservacion_MesaFindManyArgs
    Sucursal?: boolean | SucursalArgs
    idSucursal?: boolean
    Usuario?: boolean | UsuarioArgs
    idUsuario?: boolean
    _count?: boolean | ReservacionCountOutputTypeArgs
  }

  export type ReservacionInclude = {
    mesas?: boolean | Reservacion_MesaFindManyArgs
    Sucursal?: boolean | SucursalArgs
    Usuario?: boolean | UsuarioArgs
    _count?: boolean | ReservacionCountOutputTypeArgs
  }

  export type ReservacionGetPayload<
    S extends boolean | null | undefined | ReservacionArgs,
    U = keyof S
      > = S extends true
        ? Reservacion
    : S extends undefined
    ? never
    : S extends ReservacionArgs | ReservacionFindManyArgs
    ?'include' extends U
    ? Reservacion  & {
    [P in TrueKeys<S['include']>]:
        P extends 'mesas' ? Array < Reservacion_MesaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? ReservacionCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'mesas' ? Array < Reservacion_MesaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? ReservacionCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Reservacion ? Reservacion[P] : never
  } 
    : Reservacion
  : Reservacion


  type ReservacionCountArgs = Merge<
    Omit<ReservacionFindManyArgs, 'select' | 'include'> & {
      select?: ReservacionCountAggregateInputType | true
    }
  >

  export interface ReservacionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reservacion that matches the filter.
     * @param {ReservacionFindUniqueArgs} args - Arguments to find a Reservacion
     * @example
     * // Get one Reservacion
     * const reservacion = await prisma.reservacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReservacionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReservacionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reservacion'> extends True ? CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>> : CheckSelect<T, Prisma__ReservacionClient<Reservacion | null >, Prisma__ReservacionClient<ReservacionGetPayload<T> | null >>

    /**
     * Find the first Reservacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionFindFirstArgs} args - Arguments to find a Reservacion
     * @example
     * // Get one Reservacion
     * const reservacion = await prisma.reservacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReservacionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReservacionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reservacion'> extends True ? CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>> : CheckSelect<T, Prisma__ReservacionClient<Reservacion | null >, Prisma__ReservacionClient<ReservacionGetPayload<T> | null >>

    /**
     * Find zero or more Reservacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservacions
     * const reservacions = await prisma.reservacion.findMany()
     * 
     * // Get first 10 Reservacions
     * const reservacions = await prisma.reservacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservacionWithIdOnly = await prisma.reservacion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReservacionFindManyArgs>(
      args?: SelectSubset<T, ReservacionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Reservacion>>, PrismaPromise<Array<ReservacionGetPayload<T>>>>

    /**
     * Create a Reservacion.
     * @param {ReservacionCreateArgs} args - Arguments to create a Reservacion.
     * @example
     * // Create one Reservacion
     * const Reservacion = await prisma.reservacion.create({
     *   data: {
     *     // ... data to create a Reservacion
     *   }
     * })
     * 
    **/
    create<T extends ReservacionCreateArgs>(
      args: SelectSubset<T, ReservacionCreateArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Create many Reservacions.
     *     @param {ReservacionCreateManyArgs} args - Arguments to create many Reservacions.
     *     @example
     *     // Create many Reservacions
     *     const reservacion = await prisma.reservacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReservacionCreateManyArgs>(
      args?: SelectSubset<T, ReservacionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reservacion.
     * @param {ReservacionDeleteArgs} args - Arguments to delete one Reservacion.
     * @example
     * // Delete one Reservacion
     * const Reservacion = await prisma.reservacion.delete({
     *   where: {
     *     // ... filter to delete one Reservacion
     *   }
     * })
     * 
    **/
    delete<T extends ReservacionDeleteArgs>(
      args: SelectSubset<T, ReservacionDeleteArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Update one Reservacion.
     * @param {ReservacionUpdateArgs} args - Arguments to update one Reservacion.
     * @example
     * // Update one Reservacion
     * const reservacion = await prisma.reservacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReservacionUpdateArgs>(
      args: SelectSubset<T, ReservacionUpdateArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Delete zero or more Reservacions.
     * @param {ReservacionDeleteManyArgs} args - Arguments to filter Reservacions to delete.
     * @example
     * // Delete a few Reservacions
     * const { count } = await prisma.reservacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReservacionDeleteManyArgs>(
      args?: SelectSubset<T, ReservacionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservacions
     * const reservacion = await prisma.reservacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReservacionUpdateManyArgs>(
      args: SelectSubset<T, ReservacionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservacion.
     * @param {ReservacionUpsertArgs} args - Arguments to update or create a Reservacion.
     * @example
     * // Update or create a Reservacion
     * const reservacion = await prisma.reservacion.upsert({
     *   create: {
     *     // ... data to create a Reservacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservacion we want to update
     *   }
     * })
    **/
    upsert<T extends ReservacionUpsertArgs>(
      args: SelectSubset<T, ReservacionUpsertArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Find one Reservacion that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ReservacionFindUniqueOrThrowArgs} args - Arguments to find a Reservacion
     * @example
     * // Get one Reservacion
     * const reservacion = await prisma.reservacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReservacionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReservacionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Find the first Reservacion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionFindFirstOrThrowArgs} args - Arguments to find a Reservacion
     * @example
     * // Get one Reservacion
     * const reservacion = await prisma.reservacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReservacionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReservacionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Count the number of Reservacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionCountArgs} args - Arguments to filter Reservacions to count.
     * @example
     * // Count the number of Reservacions
     * const count = await prisma.reservacion.count({
     *   where: {
     *     // ... the filter for the Reservacions we want to count
     *   }
     * })
    **/
    count<T extends ReservacionCountArgs>(
      args?: Subset<T, ReservacionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservacionAggregateArgs>(args: Subset<T, ReservacionAggregateArgs>): PrismaPromise<GetReservacionAggregateType<T>>

    /**
     * Group by Reservacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservacionGroupByArgs['orderBy'] }
        : { orderBy?: ReservacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservacionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReservacionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    mesas<T extends Reservacion_MesaFindManyArgs = {}>(args?: Subset<T, Reservacion_MesaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reservacion_Mesa>>, PrismaPromise<Array<Reservacion_MesaGetPayload<T>>>>;

    Sucursal<T extends SucursalArgs = {}>(args?: Subset<T, SucursalArgs>): CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>;

    Usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reservacion base type for findUnique actions
   */
  export type ReservacionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * Filter, which Reservacion to fetch.
     * 
    **/
    where: ReservacionWhereUniqueInput
  }

  /**
   * Reservacion: findUnique
   */
  export interface ReservacionFindUniqueArgs extends ReservacionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reservacion base type for findFirst actions
   */
  export type ReservacionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * Filter, which Reservacion to fetch.
     * 
    **/
    where?: ReservacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservacions to fetch.
     * 
    **/
    orderBy?: Enumerable<ReservacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservacions.
     * 
    **/
    cursor?: ReservacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservacions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservacions.
     * 
    **/
    distinct?: Enumerable<ReservacionScalarFieldEnum>
  }

  /**
   * Reservacion: findFirst
   */
  export interface ReservacionFindFirstArgs extends ReservacionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reservacion findMany
   */
  export type ReservacionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * Filter, which Reservacions to fetch.
     * 
    **/
    where?: ReservacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservacions to fetch.
     * 
    **/
    orderBy?: Enumerable<ReservacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservacions.
     * 
    **/
    cursor?: ReservacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservacions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReservacionScalarFieldEnum>
  }


  /**
   * Reservacion create
   */
  export type ReservacionCreateArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * The data needed to create a Reservacion.
     * 
    **/
    data: XOR<ReservacionCreateInput, ReservacionUncheckedCreateInput>
  }


  /**
   * Reservacion createMany
   */
  export type ReservacionCreateManyArgs = {
    /**
     * The data used to create many Reservacions.
     * 
    **/
    data: Enumerable<ReservacionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reservacion update
   */
  export type ReservacionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * The data needed to update a Reservacion.
     * 
    **/
    data: XOR<ReservacionUpdateInput, ReservacionUncheckedUpdateInput>
    /**
     * Choose, which Reservacion to update.
     * 
    **/
    where: ReservacionWhereUniqueInput
  }


  /**
   * Reservacion updateMany
   */
  export type ReservacionUpdateManyArgs = {
    /**
     * The data used to update Reservacions.
     * 
    **/
    data: XOR<ReservacionUpdateManyMutationInput, ReservacionUncheckedUpdateManyInput>
    /**
     * Filter which Reservacions to update
     * 
    **/
    where?: ReservacionWhereInput
  }


  /**
   * Reservacion upsert
   */
  export type ReservacionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * The filter to search for the Reservacion to update in case it exists.
     * 
    **/
    where: ReservacionWhereUniqueInput
    /**
     * In case the Reservacion found by the `where` argument doesn't exist, create a new Reservacion with this data.
     * 
    **/
    create: XOR<ReservacionCreateInput, ReservacionUncheckedCreateInput>
    /**
     * In case the Reservacion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReservacionUpdateInput, ReservacionUncheckedUpdateInput>
  }


  /**
   * Reservacion delete
   */
  export type ReservacionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * Filter which Reservacion to delete.
     * 
    **/
    where: ReservacionWhereUniqueInput
  }


  /**
   * Reservacion deleteMany
   */
  export type ReservacionDeleteManyArgs = {
    /**
     * Filter which Reservacions to delete
     * 
    **/
    where?: ReservacionWhereInput
  }


  /**
   * Reservacion: findUniqueOrThrow
   */
  export type ReservacionFindUniqueOrThrowArgs = ReservacionFindUniqueArgsBase
      

  /**
   * Reservacion: findFirstOrThrow
   */
  export type ReservacionFindFirstOrThrowArgs = ReservacionFindFirstArgsBase
      

  /**
   * Reservacion without action
   */
  export type ReservacionArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
  }



  /**
   * Model Reservacion_Mesa
   */


  export type AggregateReservacion_Mesa = {
    _count: Reservacion_MesaCountAggregateOutputType | null
    _avg: Reservacion_MesaAvgAggregateOutputType | null
    _sum: Reservacion_MesaSumAggregateOutputType | null
    _min: Reservacion_MesaMinAggregateOutputType | null
    _max: Reservacion_MesaMaxAggregateOutputType | null
  }

  export type Reservacion_MesaAvgAggregateOutputType = {
    idMesa: number | null
    idReservacion: number | null
    cantidad: number | null
  }

  export type Reservacion_MesaSumAggregateOutputType = {
    idMesa: bigint | null
    idReservacion: bigint | null
    cantidad: number | null
  }

  export type Reservacion_MesaMinAggregateOutputType = {
    idMesa: bigint | null
    idReservacion: bigint | null
    cantidad: number | null
  }

  export type Reservacion_MesaMaxAggregateOutputType = {
    idMesa: bigint | null
    idReservacion: bigint | null
    cantidad: number | null
  }

  export type Reservacion_MesaCountAggregateOutputType = {
    idMesa: number
    idReservacion: number
    cantidad: number
    _all: number
  }


  export type Reservacion_MesaAvgAggregateInputType = {
    idMesa?: true
    idReservacion?: true
    cantidad?: true
  }

  export type Reservacion_MesaSumAggregateInputType = {
    idMesa?: true
    idReservacion?: true
    cantidad?: true
  }

  export type Reservacion_MesaMinAggregateInputType = {
    idMesa?: true
    idReservacion?: true
    cantidad?: true
  }

  export type Reservacion_MesaMaxAggregateInputType = {
    idMesa?: true
    idReservacion?: true
    cantidad?: true
  }

  export type Reservacion_MesaCountAggregateInputType = {
    idMesa?: true
    idReservacion?: true
    cantidad?: true
    _all?: true
  }

  export type Reservacion_MesaAggregateArgs = {
    /**
     * Filter which Reservacion_Mesa to aggregate.
     * 
    **/
    where?: Reservacion_MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservacion_Mesas to fetch.
     * 
    **/
    orderBy?: Enumerable<Reservacion_MesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Reservacion_MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservacion_Mesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservacion_Mesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservacion_Mesas
    **/
    _count?: true | Reservacion_MesaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Reservacion_MesaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Reservacion_MesaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reservacion_MesaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reservacion_MesaMaxAggregateInputType
  }

  export type GetReservacion_MesaAggregateType<T extends Reservacion_MesaAggregateArgs> = {
        [P in keyof T & keyof AggregateReservacion_Mesa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservacion_Mesa[P]>
      : GetScalarType<T[P], AggregateReservacion_Mesa[P]>
  }




  export type Reservacion_MesaGroupByArgs = {
    where?: Reservacion_MesaWhereInput
    orderBy?: Enumerable<Reservacion_MesaOrderByWithAggregationInput>
    by: Array<Reservacion_MesaScalarFieldEnum>
    having?: Reservacion_MesaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reservacion_MesaCountAggregateInputType | true
    _avg?: Reservacion_MesaAvgAggregateInputType
    _sum?: Reservacion_MesaSumAggregateInputType
    _min?: Reservacion_MesaMinAggregateInputType
    _max?: Reservacion_MesaMaxAggregateInputType
  }


  export type Reservacion_MesaGroupByOutputType = {
    idMesa: bigint
    idReservacion: bigint
    cantidad: number
    _count: Reservacion_MesaCountAggregateOutputType | null
    _avg: Reservacion_MesaAvgAggregateOutputType | null
    _sum: Reservacion_MesaSumAggregateOutputType | null
    _min: Reservacion_MesaMinAggregateOutputType | null
    _max: Reservacion_MesaMaxAggregateOutputType | null
  }

  type GetReservacion_MesaGroupByPayload<T extends Reservacion_MesaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Reservacion_MesaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reservacion_MesaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reservacion_MesaGroupByOutputType[P]>
            : GetScalarType<T[P], Reservacion_MesaGroupByOutputType[P]>
        }
      >
    >


  export type Reservacion_MesaSelect = {
    Mesa?: boolean | MesaArgs
    idMesa?: boolean
    Reservacion?: boolean | ReservacionArgs
    idReservacion?: boolean
    cantidad?: boolean
  }

  export type Reservacion_MesaInclude = {
    Mesa?: boolean | MesaArgs
    Reservacion?: boolean | ReservacionArgs
  }

  export type Reservacion_MesaGetPayload<
    S extends boolean | null | undefined | Reservacion_MesaArgs,
    U = keyof S
      > = S extends true
        ? Reservacion_Mesa
    : S extends undefined
    ? never
    : S extends Reservacion_MesaArgs | Reservacion_MesaFindManyArgs
    ?'include' extends U
    ? Reservacion_Mesa  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Mesa' ? MesaGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Reservacion' ? ReservacionGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Mesa' ? MesaGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Reservacion' ? ReservacionGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Reservacion_Mesa ? Reservacion_Mesa[P] : never
  } 
    : Reservacion_Mesa
  : Reservacion_Mesa


  type Reservacion_MesaCountArgs = Merge<
    Omit<Reservacion_MesaFindManyArgs, 'select' | 'include'> & {
      select?: Reservacion_MesaCountAggregateInputType | true
    }
  >

  export interface Reservacion_MesaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reservacion_Mesa that matches the filter.
     * @param {Reservacion_MesaFindUniqueArgs} args - Arguments to find a Reservacion_Mesa
     * @example
     * // Get one Reservacion_Mesa
     * const reservacion_Mesa = await prisma.reservacion_Mesa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Reservacion_MesaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Reservacion_MesaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reservacion_Mesa'> extends True ? CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa>, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T>>> : CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa | null >, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T> | null >>

    /**
     * Find the first Reservacion_Mesa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reservacion_MesaFindFirstArgs} args - Arguments to find a Reservacion_Mesa
     * @example
     * // Get one Reservacion_Mesa
     * const reservacion_Mesa = await prisma.reservacion_Mesa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Reservacion_MesaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Reservacion_MesaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reservacion_Mesa'> extends True ? CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa>, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T>>> : CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa | null >, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T> | null >>

    /**
     * Find zero or more Reservacion_Mesas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reservacion_MesaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservacion_Mesas
     * const reservacion_Mesas = await prisma.reservacion_Mesa.findMany()
     * 
     * // Get first 10 Reservacion_Mesas
     * const reservacion_Mesas = await prisma.reservacion_Mesa.findMany({ take: 10 })
     * 
     * // Only select the `idMesa`
     * const reservacion_MesaWithIdMesaOnly = await prisma.reservacion_Mesa.findMany({ select: { idMesa: true } })
     * 
    **/
    findMany<T extends Reservacion_MesaFindManyArgs>(
      args?: SelectSubset<T, Reservacion_MesaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Reservacion_Mesa>>, PrismaPromise<Array<Reservacion_MesaGetPayload<T>>>>

    /**
     * Create a Reservacion_Mesa.
     * @param {Reservacion_MesaCreateArgs} args - Arguments to create a Reservacion_Mesa.
     * @example
     * // Create one Reservacion_Mesa
     * const Reservacion_Mesa = await prisma.reservacion_Mesa.create({
     *   data: {
     *     // ... data to create a Reservacion_Mesa
     *   }
     * })
     * 
    **/
    create<T extends Reservacion_MesaCreateArgs>(
      args: SelectSubset<T, Reservacion_MesaCreateArgs>
    ): CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa>, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T>>>

    /**
     * Create many Reservacion_Mesas.
     *     @param {Reservacion_MesaCreateManyArgs} args - Arguments to create many Reservacion_Mesas.
     *     @example
     *     // Create many Reservacion_Mesas
     *     const reservacion_Mesa = await prisma.reservacion_Mesa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Reservacion_MesaCreateManyArgs>(
      args?: SelectSubset<T, Reservacion_MesaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reservacion_Mesa.
     * @param {Reservacion_MesaDeleteArgs} args - Arguments to delete one Reservacion_Mesa.
     * @example
     * // Delete one Reservacion_Mesa
     * const Reservacion_Mesa = await prisma.reservacion_Mesa.delete({
     *   where: {
     *     // ... filter to delete one Reservacion_Mesa
     *   }
     * })
     * 
    **/
    delete<T extends Reservacion_MesaDeleteArgs>(
      args: SelectSubset<T, Reservacion_MesaDeleteArgs>
    ): CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa>, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T>>>

    /**
     * Update one Reservacion_Mesa.
     * @param {Reservacion_MesaUpdateArgs} args - Arguments to update one Reservacion_Mesa.
     * @example
     * // Update one Reservacion_Mesa
     * const reservacion_Mesa = await prisma.reservacion_Mesa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Reservacion_MesaUpdateArgs>(
      args: SelectSubset<T, Reservacion_MesaUpdateArgs>
    ): CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa>, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T>>>

    /**
     * Delete zero or more Reservacion_Mesas.
     * @param {Reservacion_MesaDeleteManyArgs} args - Arguments to filter Reservacion_Mesas to delete.
     * @example
     * // Delete a few Reservacion_Mesas
     * const { count } = await prisma.reservacion_Mesa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Reservacion_MesaDeleteManyArgs>(
      args?: SelectSubset<T, Reservacion_MesaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservacion_Mesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reservacion_MesaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservacion_Mesas
     * const reservacion_Mesa = await prisma.reservacion_Mesa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Reservacion_MesaUpdateManyArgs>(
      args: SelectSubset<T, Reservacion_MesaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservacion_Mesa.
     * @param {Reservacion_MesaUpsertArgs} args - Arguments to update or create a Reservacion_Mesa.
     * @example
     * // Update or create a Reservacion_Mesa
     * const reservacion_Mesa = await prisma.reservacion_Mesa.upsert({
     *   create: {
     *     // ... data to create a Reservacion_Mesa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservacion_Mesa we want to update
     *   }
     * })
    **/
    upsert<T extends Reservacion_MesaUpsertArgs>(
      args: SelectSubset<T, Reservacion_MesaUpsertArgs>
    ): CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa>, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T>>>

    /**
     * Find one Reservacion_Mesa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Reservacion_MesaFindUniqueOrThrowArgs} args - Arguments to find a Reservacion_Mesa
     * @example
     * // Get one Reservacion_Mesa
     * const reservacion_Mesa = await prisma.reservacion_Mesa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Reservacion_MesaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Reservacion_MesaFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa>, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T>>>

    /**
     * Find the first Reservacion_Mesa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reservacion_MesaFindFirstOrThrowArgs} args - Arguments to find a Reservacion_Mesa
     * @example
     * // Get one Reservacion_Mesa
     * const reservacion_Mesa = await prisma.reservacion_Mesa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Reservacion_MesaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Reservacion_MesaFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Reservacion_MesaClient<Reservacion_Mesa>, Prisma__Reservacion_MesaClient<Reservacion_MesaGetPayload<T>>>

    /**
     * Count the number of Reservacion_Mesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reservacion_MesaCountArgs} args - Arguments to filter Reservacion_Mesas to count.
     * @example
     * // Count the number of Reservacion_Mesas
     * const count = await prisma.reservacion_Mesa.count({
     *   where: {
     *     // ... the filter for the Reservacion_Mesas we want to count
     *   }
     * })
    **/
    count<T extends Reservacion_MesaCountArgs>(
      args?: Subset<T, Reservacion_MesaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reservacion_MesaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservacion_Mesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reservacion_MesaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reservacion_MesaAggregateArgs>(args: Subset<T, Reservacion_MesaAggregateArgs>): PrismaPromise<GetReservacion_MesaAggregateType<T>>

    /**
     * Group by Reservacion_Mesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reservacion_MesaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Reservacion_MesaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Reservacion_MesaGroupByArgs['orderBy'] }
        : { orderBy?: Reservacion_MesaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Reservacion_MesaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservacion_MesaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservacion_Mesa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Reservacion_MesaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Mesa<T extends MesaArgs = {}>(args?: Subset<T, MesaArgs>): CheckSelect<T, Prisma__MesaClient<Mesa | null >, Prisma__MesaClient<MesaGetPayload<T> | null >>;

    Reservacion<T extends ReservacionArgs = {}>(args?: Subset<T, ReservacionArgs>): CheckSelect<T, Prisma__ReservacionClient<Reservacion | null >, Prisma__ReservacionClient<ReservacionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reservacion_Mesa base type for findUnique actions
   */
  export type Reservacion_MesaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Reservacion_Mesa
     * 
    **/
    select?: Reservacion_MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Reservacion_MesaInclude | null
    /**
     * Filter, which Reservacion_Mesa to fetch.
     * 
    **/
    where: Reservacion_MesaWhereUniqueInput
  }

  /**
   * Reservacion_Mesa: findUnique
   */
  export interface Reservacion_MesaFindUniqueArgs extends Reservacion_MesaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reservacion_Mesa base type for findFirst actions
   */
  export type Reservacion_MesaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Reservacion_Mesa
     * 
    **/
    select?: Reservacion_MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Reservacion_MesaInclude | null
    /**
     * Filter, which Reservacion_Mesa to fetch.
     * 
    **/
    where?: Reservacion_MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservacion_Mesas to fetch.
     * 
    **/
    orderBy?: Enumerable<Reservacion_MesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservacion_Mesas.
     * 
    **/
    cursor?: Reservacion_MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservacion_Mesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservacion_Mesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservacion_Mesas.
     * 
    **/
    distinct?: Enumerable<Reservacion_MesaScalarFieldEnum>
  }

  /**
   * Reservacion_Mesa: findFirst
   */
  export interface Reservacion_MesaFindFirstArgs extends Reservacion_MesaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reservacion_Mesa findMany
   */
  export type Reservacion_MesaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Reservacion_Mesa
     * 
    **/
    select?: Reservacion_MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Reservacion_MesaInclude | null
    /**
     * Filter, which Reservacion_Mesas to fetch.
     * 
    **/
    where?: Reservacion_MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservacion_Mesas to fetch.
     * 
    **/
    orderBy?: Enumerable<Reservacion_MesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservacion_Mesas.
     * 
    **/
    cursor?: Reservacion_MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservacion_Mesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservacion_Mesas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Reservacion_MesaScalarFieldEnum>
  }


  /**
   * Reservacion_Mesa create
   */
  export type Reservacion_MesaCreateArgs = {
    /**
     * Select specific fields to fetch from the Reservacion_Mesa
     * 
    **/
    select?: Reservacion_MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Reservacion_MesaInclude | null
    /**
     * The data needed to create a Reservacion_Mesa.
     * 
    **/
    data: XOR<Reservacion_MesaCreateInput, Reservacion_MesaUncheckedCreateInput>
  }


  /**
   * Reservacion_Mesa createMany
   */
  export type Reservacion_MesaCreateManyArgs = {
    /**
     * The data used to create many Reservacion_Mesas.
     * 
    **/
    data: Enumerable<Reservacion_MesaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reservacion_Mesa update
   */
  export type Reservacion_MesaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reservacion_Mesa
     * 
    **/
    select?: Reservacion_MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Reservacion_MesaInclude | null
    /**
     * The data needed to update a Reservacion_Mesa.
     * 
    **/
    data: XOR<Reservacion_MesaUpdateInput, Reservacion_MesaUncheckedUpdateInput>
    /**
     * Choose, which Reservacion_Mesa to update.
     * 
    **/
    where: Reservacion_MesaWhereUniqueInput
  }


  /**
   * Reservacion_Mesa updateMany
   */
  export type Reservacion_MesaUpdateManyArgs = {
    /**
     * The data used to update Reservacion_Mesas.
     * 
    **/
    data: XOR<Reservacion_MesaUpdateManyMutationInput, Reservacion_MesaUncheckedUpdateManyInput>
    /**
     * Filter which Reservacion_Mesas to update
     * 
    **/
    where?: Reservacion_MesaWhereInput
  }


  /**
   * Reservacion_Mesa upsert
   */
  export type Reservacion_MesaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reservacion_Mesa
     * 
    **/
    select?: Reservacion_MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Reservacion_MesaInclude | null
    /**
     * The filter to search for the Reservacion_Mesa to update in case it exists.
     * 
    **/
    where: Reservacion_MesaWhereUniqueInput
    /**
     * In case the Reservacion_Mesa found by the `where` argument doesn't exist, create a new Reservacion_Mesa with this data.
     * 
    **/
    create: XOR<Reservacion_MesaCreateInput, Reservacion_MesaUncheckedCreateInput>
    /**
     * In case the Reservacion_Mesa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Reservacion_MesaUpdateInput, Reservacion_MesaUncheckedUpdateInput>
  }


  /**
   * Reservacion_Mesa delete
   */
  export type Reservacion_MesaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reservacion_Mesa
     * 
    **/
    select?: Reservacion_MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Reservacion_MesaInclude | null
    /**
     * Filter which Reservacion_Mesa to delete.
     * 
    **/
    where: Reservacion_MesaWhereUniqueInput
  }


  /**
   * Reservacion_Mesa deleteMany
   */
  export type Reservacion_MesaDeleteManyArgs = {
    /**
     * Filter which Reservacion_Mesas to delete
     * 
    **/
    where?: Reservacion_MesaWhereInput
  }


  /**
   * Reservacion_Mesa: findUniqueOrThrow
   */
  export type Reservacion_MesaFindUniqueOrThrowArgs = Reservacion_MesaFindUniqueArgsBase
      

  /**
   * Reservacion_Mesa: findFirstOrThrow
   */
  export type Reservacion_MesaFindFirstOrThrowArgs = Reservacion_MesaFindFirstArgsBase
      

  /**
   * Reservacion_Mesa without action
   */
  export type Reservacion_MesaArgs = {
    /**
     * Select specific fields to fetch from the Reservacion_Mesa
     * 
    **/
    select?: Reservacion_MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Reservacion_MesaInclude | null
  }



  /**
   * Model Categoria_Producto
   */


  export type AggregateCategoria_Producto = {
    _count: Categoria_ProductoCountAggregateOutputType | null
    _avg: Categoria_ProductoAvgAggregateOutputType | null
    _sum: Categoria_ProductoSumAggregateOutputType | null
    _min: Categoria_ProductoMinAggregateOutputType | null
    _max: Categoria_ProductoMaxAggregateOutputType | null
  }

  export type Categoria_ProductoAvgAggregateOutputType = {
    id: number | null
  }

  export type Categoria_ProductoSumAggregateOutputType = {
    id: number | null
  }

  export type Categoria_ProductoMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type Categoria_ProductoMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type Categoria_ProductoCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type Categoria_ProductoAvgAggregateInputType = {
    id?: true
  }

  export type Categoria_ProductoSumAggregateInputType = {
    id?: true
  }

  export type Categoria_ProductoMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type Categoria_ProductoMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type Categoria_ProductoCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type Categoria_ProductoAggregateArgs = {
    /**
     * Filter which Categoria_Producto to aggregate.
     * 
    **/
    where?: Categoria_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Categoria_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Categoria_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categoria_Productos
    **/
    _count?: true | Categoria_ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Categoria_ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Categoria_ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Categoria_ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Categoria_ProductoMaxAggregateInputType
  }

  export type GetCategoria_ProductoAggregateType<T extends Categoria_ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria_Producto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria_Producto[P]>
      : GetScalarType<T[P], AggregateCategoria_Producto[P]>
  }




  export type Categoria_ProductoGroupByArgs = {
    where?: Categoria_ProductoWhereInput
    orderBy?: Enumerable<Categoria_ProductoOrderByWithAggregationInput>
    by: Array<Categoria_ProductoScalarFieldEnum>
    having?: Categoria_ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Categoria_ProductoCountAggregateInputType | true
    _avg?: Categoria_ProductoAvgAggregateInputType
    _sum?: Categoria_ProductoSumAggregateInputType
    _min?: Categoria_ProductoMinAggregateInputType
    _max?: Categoria_ProductoMaxAggregateInputType
  }


  export type Categoria_ProductoGroupByOutputType = {
    id: number
    descripcion: string
    _count: Categoria_ProductoCountAggregateOutputType | null
    _avg: Categoria_ProductoAvgAggregateOutputType | null
    _sum: Categoria_ProductoSumAggregateOutputType | null
    _min: Categoria_ProductoMinAggregateOutputType | null
    _max: Categoria_ProductoMaxAggregateOutputType | null
  }

  type GetCategoria_ProductoGroupByPayload<T extends Categoria_ProductoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Categoria_ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Categoria_ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Categoria_ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], Categoria_ProductoGroupByOutputType[P]>
        }
      >
    >


  export type Categoria_ProductoSelect = {
    id?: boolean
    descripcion?: boolean
    productos?: boolean | ProductoFindManyArgs
    _count?: boolean | Categoria_ProductoCountOutputTypeArgs
  }

  export type Categoria_ProductoInclude = {
    productos?: boolean | ProductoFindManyArgs
    _count?: boolean | Categoria_ProductoCountOutputTypeArgs
  }

  export type Categoria_ProductoGetPayload<
    S extends boolean | null | undefined | Categoria_ProductoArgs,
    U = keyof S
      > = S extends true
        ? Categoria_Producto
    : S extends undefined
    ? never
    : S extends Categoria_ProductoArgs | Categoria_ProductoFindManyArgs
    ?'include' extends U
    ? Categoria_Producto  & {
    [P in TrueKeys<S['include']>]:
        P extends 'productos' ? Array < ProductoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Categoria_ProductoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'productos' ? Array < ProductoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Categoria_ProductoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Categoria_Producto ? Categoria_Producto[P] : never
  } 
    : Categoria_Producto
  : Categoria_Producto


  type Categoria_ProductoCountArgs = Merge<
    Omit<Categoria_ProductoFindManyArgs, 'select' | 'include'> & {
      select?: Categoria_ProductoCountAggregateInputType | true
    }
  >

  export interface Categoria_ProductoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Categoria_Producto that matches the filter.
     * @param {Categoria_ProductoFindUniqueArgs} args - Arguments to find a Categoria_Producto
     * @example
     * // Get one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Categoria_ProductoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Categoria_ProductoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Categoria_Producto'> extends True ? CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto | null >, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T> | null >>

    /**
     * Find the first Categoria_Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoFindFirstArgs} args - Arguments to find a Categoria_Producto
     * @example
     * // Get one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Categoria_ProductoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Categoria_ProductoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Categoria_Producto'> extends True ? CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto | null >, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T> | null >>

    /**
     * Find zero or more Categoria_Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categoria_Productos
     * const categoria_Productos = await prisma.categoria_Producto.findMany()
     * 
     * // Get first 10 Categoria_Productos
     * const categoria_Productos = await prisma.categoria_Producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoria_ProductoWithIdOnly = await prisma.categoria_Producto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Categoria_ProductoFindManyArgs>(
      args?: SelectSubset<T, Categoria_ProductoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Categoria_Producto>>, PrismaPromise<Array<Categoria_ProductoGetPayload<T>>>>

    /**
     * Create a Categoria_Producto.
     * @param {Categoria_ProductoCreateArgs} args - Arguments to create a Categoria_Producto.
     * @example
     * // Create one Categoria_Producto
     * const Categoria_Producto = await prisma.categoria_Producto.create({
     *   data: {
     *     // ... data to create a Categoria_Producto
     *   }
     * })
     * 
    **/
    create<T extends Categoria_ProductoCreateArgs>(
      args: SelectSubset<T, Categoria_ProductoCreateArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Create many Categoria_Productos.
     *     @param {Categoria_ProductoCreateManyArgs} args - Arguments to create many Categoria_Productos.
     *     @example
     *     // Create many Categoria_Productos
     *     const categoria_Producto = await prisma.categoria_Producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Categoria_ProductoCreateManyArgs>(
      args?: SelectSubset<T, Categoria_ProductoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria_Producto.
     * @param {Categoria_ProductoDeleteArgs} args - Arguments to delete one Categoria_Producto.
     * @example
     * // Delete one Categoria_Producto
     * const Categoria_Producto = await prisma.categoria_Producto.delete({
     *   where: {
     *     // ... filter to delete one Categoria_Producto
     *   }
     * })
     * 
    **/
    delete<T extends Categoria_ProductoDeleteArgs>(
      args: SelectSubset<T, Categoria_ProductoDeleteArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Update one Categoria_Producto.
     * @param {Categoria_ProductoUpdateArgs} args - Arguments to update one Categoria_Producto.
     * @example
     * // Update one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Categoria_ProductoUpdateArgs>(
      args: SelectSubset<T, Categoria_ProductoUpdateArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Delete zero or more Categoria_Productos.
     * @param {Categoria_ProductoDeleteManyArgs} args - Arguments to filter Categoria_Productos to delete.
     * @example
     * // Delete a few Categoria_Productos
     * const { count } = await prisma.categoria_Producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Categoria_ProductoDeleteManyArgs>(
      args?: SelectSubset<T, Categoria_ProductoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categoria_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categoria_Productos
     * const categoria_Producto = await prisma.categoria_Producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Categoria_ProductoUpdateManyArgs>(
      args: SelectSubset<T, Categoria_ProductoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria_Producto.
     * @param {Categoria_ProductoUpsertArgs} args - Arguments to update or create a Categoria_Producto.
     * @example
     * // Update or create a Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.upsert({
     *   create: {
     *     // ... data to create a Categoria_Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria_Producto we want to update
     *   }
     * })
    **/
    upsert<T extends Categoria_ProductoUpsertArgs>(
      args: SelectSubset<T, Categoria_ProductoUpsertArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Find one Categoria_Producto that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Categoria_ProductoFindUniqueOrThrowArgs} args - Arguments to find a Categoria_Producto
     * @example
     * // Get one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Categoria_ProductoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Categoria_ProductoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Find the first Categoria_Producto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoFindFirstOrThrowArgs} args - Arguments to find a Categoria_Producto
     * @example
     * // Get one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Categoria_ProductoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Categoria_ProductoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Count the number of Categoria_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoCountArgs} args - Arguments to filter Categoria_Productos to count.
     * @example
     * // Count the number of Categoria_Productos
     * const count = await prisma.categoria_Producto.count({
     *   where: {
     *     // ... the filter for the Categoria_Productos we want to count
     *   }
     * })
    **/
    count<T extends Categoria_ProductoCountArgs>(
      args?: Subset<T, Categoria_ProductoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Categoria_ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Categoria_ProductoAggregateArgs>(args: Subset<T, Categoria_ProductoAggregateArgs>): PrismaPromise<GetCategoria_ProductoAggregateType<T>>

    /**
     * Group by Categoria_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Categoria_ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Categoria_ProductoGroupByArgs['orderBy'] }
        : { orderBy?: Categoria_ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Categoria_ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoria_ProductoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria_Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Categoria_ProductoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    productos<T extends ProductoFindManyArgs = {}>(args?: Subset<T, ProductoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Producto>>, PrismaPromise<Array<ProductoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Categoria_Producto base type for findUnique actions
   */
  export type Categoria_ProductoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * Filter, which Categoria_Producto to fetch.
     * 
    **/
    where: Categoria_ProductoWhereUniqueInput
  }

  /**
   * Categoria_Producto: findUnique
   */
  export interface Categoria_ProductoFindUniqueArgs extends Categoria_ProductoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Categoria_Producto base type for findFirst actions
   */
  export type Categoria_ProductoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * Filter, which Categoria_Producto to fetch.
     * 
    **/
    where?: Categoria_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Categoria_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categoria_Productos.
     * 
    **/
    cursor?: Categoria_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categoria_Productos.
     * 
    **/
    distinct?: Enumerable<Categoria_ProductoScalarFieldEnum>
  }

  /**
   * Categoria_Producto: findFirst
   */
  export interface Categoria_ProductoFindFirstArgs extends Categoria_ProductoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Categoria_Producto findMany
   */
  export type Categoria_ProductoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * Filter, which Categoria_Productos to fetch.
     * 
    **/
    where?: Categoria_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Categoria_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categoria_Productos.
     * 
    **/
    cursor?: Categoria_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_Productos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Categoria_ProductoScalarFieldEnum>
  }


  /**
   * Categoria_Producto create
   */
  export type Categoria_ProductoCreateArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * The data needed to create a Categoria_Producto.
     * 
    **/
    data: XOR<Categoria_ProductoCreateInput, Categoria_ProductoUncheckedCreateInput>
  }


  /**
   * Categoria_Producto createMany
   */
  export type Categoria_ProductoCreateManyArgs = {
    /**
     * The data used to create many Categoria_Productos.
     * 
    **/
    data: Enumerable<Categoria_ProductoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Categoria_Producto update
   */
  export type Categoria_ProductoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * The data needed to update a Categoria_Producto.
     * 
    **/
    data: XOR<Categoria_ProductoUpdateInput, Categoria_ProductoUncheckedUpdateInput>
    /**
     * Choose, which Categoria_Producto to update.
     * 
    **/
    where: Categoria_ProductoWhereUniqueInput
  }


  /**
   * Categoria_Producto updateMany
   */
  export type Categoria_ProductoUpdateManyArgs = {
    /**
     * The data used to update Categoria_Productos.
     * 
    **/
    data: XOR<Categoria_ProductoUpdateManyMutationInput, Categoria_ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Categoria_Productos to update
     * 
    **/
    where?: Categoria_ProductoWhereInput
  }


  /**
   * Categoria_Producto upsert
   */
  export type Categoria_ProductoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * The filter to search for the Categoria_Producto to update in case it exists.
     * 
    **/
    where: Categoria_ProductoWhereUniqueInput
    /**
     * In case the Categoria_Producto found by the `where` argument doesn't exist, create a new Categoria_Producto with this data.
     * 
    **/
    create: XOR<Categoria_ProductoCreateInput, Categoria_ProductoUncheckedCreateInput>
    /**
     * In case the Categoria_Producto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Categoria_ProductoUpdateInput, Categoria_ProductoUncheckedUpdateInput>
  }


  /**
   * Categoria_Producto delete
   */
  export type Categoria_ProductoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * Filter which Categoria_Producto to delete.
     * 
    **/
    where: Categoria_ProductoWhereUniqueInput
  }


  /**
   * Categoria_Producto deleteMany
   */
  export type Categoria_ProductoDeleteManyArgs = {
    /**
     * Filter which Categoria_Productos to delete
     * 
    **/
    where?: Categoria_ProductoWhereInput
  }


  /**
   * Categoria_Producto: findUniqueOrThrow
   */
  export type Categoria_ProductoFindUniqueOrThrowArgs = Categoria_ProductoFindUniqueArgsBase
      

  /**
   * Categoria_Producto: findFirstOrThrow
   */
  export type Categoria_ProductoFindFirstOrThrowArgs = Categoria_ProductoFindFirstArgsBase
      

  /**
   * Categoria_Producto without action
   */
  export type Categoria_ProductoArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
  }



  /**
   * Model Producto
   */


  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoAvgAggregateOutputType = {
    id: number | null
    precio: Decimal | null
    estado: number | null
    idCategoria: number | null
  }

  export type ProductoSumAggregateOutputType = {
    id: bigint | null
    precio: Decimal | null
    estado: number | null
    idCategoria: number | null
  }

  export type ProductoMinAggregateOutputType = {
    id: bigint | null
    nombre: string | null
    descripcion: string | null
    ingredientes: string | null
    precio: Decimal | null
    imagen: string | null
    estado: number | null
    idCategoria: number | null
  }

  export type ProductoMaxAggregateOutputType = {
    id: bigint | null
    nombre: string | null
    descripcion: string | null
    ingredientes: string | null
    precio: Decimal | null
    imagen: string | null
    estado: number | null
    idCategoria: number | null
  }

  export type ProductoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    ingredientes: number
    precio: number
    imagen: number
    estado: number
    idCategoria: number
    _all: number
  }


  export type ProductoAvgAggregateInputType = {
    id?: true
    precio?: true
    estado?: true
    idCategoria?: true
  }

  export type ProductoSumAggregateInputType = {
    id?: true
    precio?: true
    estado?: true
    idCategoria?: true
  }

  export type ProductoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    ingredientes?: true
    precio?: true
    imagen?: true
    estado?: true
    idCategoria?: true
  }

  export type ProductoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    ingredientes?: true
    precio?: true
    imagen?: true
    estado?: true
    idCategoria?: true
  }

  export type ProductoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    ingredientes?: true
    precio?: true
    imagen?: true
    estado?: true
    idCategoria?: true
    _all?: true
  }

  export type ProductoAggregateArgs = {
    /**
     * Filter which Producto to aggregate.
     * 
    **/
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type ProductoGroupByArgs = {
    where?: ProductoWhereInput
    orderBy?: Enumerable<ProductoOrderByWithAggregationInput>
    by: Array<ProductoScalarFieldEnum>
    having?: ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _avg?: ProductoAvgAggregateInputType
    _sum?: ProductoSumAggregateInputType
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }


  export type ProductoGroupByOutputType = {
    id: bigint
    nombre: string
    descripcion: string
    ingredientes: string | null
    precio: Decimal
    imagen: string
    estado: number
    idCategoria: number
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type ProductoSelect = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    ingredientes?: boolean
    precio?: boolean
    imagen?: boolean
    estado?: boolean
    Categoria_Producto?: boolean | Categoria_ProductoArgs
    idCategoria?: boolean
    detalles?: boolean | Factura_DetalleFindManyArgs
    pedidos?: boolean | Pedido_ProductoFindManyArgs
    sucursales?: boolean | Sucursal_ProductoFindManyArgs
    _count?: boolean | ProductoCountOutputTypeArgs
  }

  export type ProductoInclude = {
    Categoria_Producto?: boolean | Categoria_ProductoArgs
    detalles?: boolean | Factura_DetalleFindManyArgs
    pedidos?: boolean | Pedido_ProductoFindManyArgs
    sucursales?: boolean | Sucursal_ProductoFindManyArgs
    _count?: boolean | ProductoCountOutputTypeArgs
  }

  export type ProductoGetPayload<
    S extends boolean | null | undefined | ProductoArgs,
    U = keyof S
      > = S extends true
        ? Producto
    : S extends undefined
    ? never
    : S extends ProductoArgs | ProductoFindManyArgs
    ?'include' extends U
    ? Producto  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Categoria_Producto' ? Categoria_ProductoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'detalles' ? Array < Factura_DetalleGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < Pedido_ProductoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sucursales' ? Array < Sucursal_ProductoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ProductoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Categoria_Producto' ? Categoria_ProductoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'detalles' ? Array < Factura_DetalleGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < Pedido_ProductoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sucursales' ? Array < Sucursal_ProductoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ProductoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Producto ? Producto[P] : never
  } 
    : Producto
  : Producto


  type ProductoCountArgs = Merge<
    Omit<ProductoFindManyArgs, 'select' | 'include'> & {
      select?: ProductoCountAggregateInputType | true
    }
  >

  export interface ProductoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Producto'> extends True ? CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>> : CheckSelect<T, Prisma__ProductoClient<Producto | null >, Prisma__ProductoClient<ProductoGetPayload<T> | null >>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Producto'> extends True ? CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>> : CheckSelect<T, Prisma__ProductoClient<Producto | null >, Prisma__ProductoClient<ProductoGetPayload<T> | null >>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productoWithIdOnly = await prisma.producto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductoFindManyArgs>(
      args?: SelectSubset<T, ProductoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Producto>>, PrismaPromise<Array<ProductoGetPayload<T>>>>

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
    **/
    create<T extends ProductoCreateArgs>(
      args: SelectSubset<T, ProductoCreateArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Create many Productos.
     *     @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     *     @example
     *     // Create many Productos
     *     const producto = await prisma.producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductoCreateManyArgs>(
      args?: SelectSubset<T, ProductoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
    **/
    delete<T extends ProductoDeleteArgs>(
      args: SelectSubset<T, ProductoDeleteArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductoUpdateArgs>(
      args: SelectSubset<T, ProductoUpdateArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductoDeleteManyArgs>(
      args?: SelectSubset<T, ProductoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductoUpdateManyArgs>(
      args: SelectSubset<T, ProductoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
    **/
    upsert<T extends ProductoUpsertArgs>(
      args: SelectSubset<T, ProductoUpsertArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Find one Producto that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Find the first Producto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Categoria_Producto<T extends Categoria_ProductoArgs = {}>(args?: Subset<T, Categoria_ProductoArgs>): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto | null >, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T> | null >>;

    detalles<T extends Factura_DetalleFindManyArgs = {}>(args?: Subset<T, Factura_DetalleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Factura_Detalle>>, PrismaPromise<Array<Factura_DetalleGetPayload<T>>>>;

    pedidos<T extends Pedido_ProductoFindManyArgs = {}>(args?: Subset<T, Pedido_ProductoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido_Producto>>, PrismaPromise<Array<Pedido_ProductoGetPayload<T>>>>;

    sucursales<T extends Sucursal_ProductoFindManyArgs = {}>(args?: Subset<T, Sucursal_ProductoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Sucursal_Producto>>, PrismaPromise<Array<Sucursal_ProductoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Producto base type for findUnique actions
   */
  export type ProductoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter, which Producto to fetch.
     * 
    **/
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto: findUnique
   */
  export interface ProductoFindUniqueArgs extends ProductoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Producto base type for findFirst actions
   */
  export type ProductoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter, which Producto to fetch.
     * 
    **/
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     * 
    **/
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     * 
    **/
    distinct?: Enumerable<ProductoScalarFieldEnum>
  }

  /**
   * Producto: findFirst
   */
  export interface ProductoFindFirstArgs extends ProductoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter, which Productos to fetch.
     * 
    **/
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     * 
    **/
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductoScalarFieldEnum>
  }


  /**
   * Producto create
   */
  export type ProductoCreateArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * The data needed to create a Producto.
     * 
    **/
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
  }


  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs = {
    /**
     * The data used to create many Productos.
     * 
    **/
    data: Enumerable<ProductoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Producto update
   */
  export type ProductoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * The data needed to update a Producto.
     * 
    **/
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
    /**
     * Choose, which Producto to update.
     * 
    **/
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs = {
    /**
     * The data used to update Productos.
     * 
    **/
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     * 
    **/
    where?: ProductoWhereInput
  }


  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * The filter to search for the Producto to update in case it exists.
     * 
    **/
    where: ProductoWhereUniqueInput
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     * 
    **/
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
  }


  /**
   * Producto delete
   */
  export type ProductoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter which Producto to delete.
     * 
    **/
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs = {
    /**
     * Filter which Productos to delete
     * 
    **/
    where?: ProductoWhereInput
  }


  /**
   * Producto: findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs = ProductoFindUniqueArgsBase
      

  /**
   * Producto: findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs = ProductoFindFirstArgsBase
      

  /**
   * Producto without action
   */
  export type ProductoArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
  }



  /**
   * Model Sucursal_Producto
   */


  export type AggregateSucursal_Producto = {
    _count: Sucursal_ProductoCountAggregateOutputType | null
    _avg: Sucursal_ProductoAvgAggregateOutputType | null
    _sum: Sucursal_ProductoSumAggregateOutputType | null
    _min: Sucursal_ProductoMinAggregateOutputType | null
    _max: Sucursal_ProductoMaxAggregateOutputType | null
  }

  export type Sucursal_ProductoAvgAggregateOutputType = {
    idProducto: number | null
    idSucursal: number | null
  }

  export type Sucursal_ProductoSumAggregateOutputType = {
    idProducto: bigint | null
    idSucursal: bigint | null
  }

  export type Sucursal_ProductoMinAggregateOutputType = {
    idProducto: bigint | null
    idSucursal: bigint | null
  }

  export type Sucursal_ProductoMaxAggregateOutputType = {
    idProducto: bigint | null
    idSucursal: bigint | null
  }

  export type Sucursal_ProductoCountAggregateOutputType = {
    idProducto: number
    idSucursal: number
    _all: number
  }


  export type Sucursal_ProductoAvgAggregateInputType = {
    idProducto?: true
    idSucursal?: true
  }

  export type Sucursal_ProductoSumAggregateInputType = {
    idProducto?: true
    idSucursal?: true
  }

  export type Sucursal_ProductoMinAggregateInputType = {
    idProducto?: true
    idSucursal?: true
  }

  export type Sucursal_ProductoMaxAggregateInputType = {
    idProducto?: true
    idSucursal?: true
  }

  export type Sucursal_ProductoCountAggregateInputType = {
    idProducto?: true
    idSucursal?: true
    _all?: true
  }

  export type Sucursal_ProductoAggregateArgs = {
    /**
     * Filter which Sucursal_Producto to aggregate.
     * 
    **/
    where?: Sucursal_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sucursal_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Sucursal_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Sucursal_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sucursal_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sucursal_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sucursal_Productos
    **/
    _count?: true | Sucursal_ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sucursal_ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sucursal_ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sucursal_ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sucursal_ProductoMaxAggregateInputType
  }

  export type GetSucursal_ProductoAggregateType<T extends Sucursal_ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateSucursal_Producto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSucursal_Producto[P]>
      : GetScalarType<T[P], AggregateSucursal_Producto[P]>
  }




  export type Sucursal_ProductoGroupByArgs = {
    where?: Sucursal_ProductoWhereInput
    orderBy?: Enumerable<Sucursal_ProductoOrderByWithAggregationInput>
    by: Array<Sucursal_ProductoScalarFieldEnum>
    having?: Sucursal_ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sucursal_ProductoCountAggregateInputType | true
    _avg?: Sucursal_ProductoAvgAggregateInputType
    _sum?: Sucursal_ProductoSumAggregateInputType
    _min?: Sucursal_ProductoMinAggregateInputType
    _max?: Sucursal_ProductoMaxAggregateInputType
  }


  export type Sucursal_ProductoGroupByOutputType = {
    idProducto: bigint
    idSucursal: bigint
    _count: Sucursal_ProductoCountAggregateOutputType | null
    _avg: Sucursal_ProductoAvgAggregateOutputType | null
    _sum: Sucursal_ProductoSumAggregateOutputType | null
    _min: Sucursal_ProductoMinAggregateOutputType | null
    _max: Sucursal_ProductoMaxAggregateOutputType | null
  }

  type GetSucursal_ProductoGroupByPayload<T extends Sucursal_ProductoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Sucursal_ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sucursal_ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sucursal_ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], Sucursal_ProductoGroupByOutputType[P]>
        }
      >
    >


  export type Sucursal_ProductoSelect = {
    Producto?: boolean | ProductoArgs
    idProducto?: boolean
    Sucursal?: boolean | SucursalArgs
    idSucursal?: boolean
  }

  export type Sucursal_ProductoInclude = {
    Producto?: boolean | ProductoArgs
    Sucursal?: boolean | SucursalArgs
  }

  export type Sucursal_ProductoGetPayload<
    S extends boolean | null | undefined | Sucursal_ProductoArgs,
    U = keyof S
      > = S extends true
        ? Sucursal_Producto
    : S extends undefined
    ? never
    : S extends Sucursal_ProductoArgs | Sucursal_ProductoFindManyArgs
    ?'include' extends U
    ? Sucursal_Producto  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Sucursal_Producto ? Sucursal_Producto[P] : never
  } 
    : Sucursal_Producto
  : Sucursal_Producto


  type Sucursal_ProductoCountArgs = Merge<
    Omit<Sucursal_ProductoFindManyArgs, 'select' | 'include'> & {
      select?: Sucursal_ProductoCountAggregateInputType | true
    }
  >

  export interface Sucursal_ProductoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Sucursal_Producto that matches the filter.
     * @param {Sucursal_ProductoFindUniqueArgs} args - Arguments to find a Sucursal_Producto
     * @example
     * // Get one Sucursal_Producto
     * const sucursal_Producto = await prisma.sucursal_Producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Sucursal_ProductoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Sucursal_ProductoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sucursal_Producto'> extends True ? CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto>, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto | null >, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T> | null >>

    /**
     * Find the first Sucursal_Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sucursal_ProductoFindFirstArgs} args - Arguments to find a Sucursal_Producto
     * @example
     * // Get one Sucursal_Producto
     * const sucursal_Producto = await prisma.sucursal_Producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Sucursal_ProductoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Sucursal_ProductoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sucursal_Producto'> extends True ? CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto>, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto | null >, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T> | null >>

    /**
     * Find zero or more Sucursal_Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sucursal_ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sucursal_Productos
     * const sucursal_Productos = await prisma.sucursal_Producto.findMany()
     * 
     * // Get first 10 Sucursal_Productos
     * const sucursal_Productos = await prisma.sucursal_Producto.findMany({ take: 10 })
     * 
     * // Only select the `idProducto`
     * const sucursal_ProductoWithIdProductoOnly = await prisma.sucursal_Producto.findMany({ select: { idProducto: true } })
     * 
    **/
    findMany<T extends Sucursal_ProductoFindManyArgs>(
      args?: SelectSubset<T, Sucursal_ProductoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Sucursal_Producto>>, PrismaPromise<Array<Sucursal_ProductoGetPayload<T>>>>

    /**
     * Create a Sucursal_Producto.
     * @param {Sucursal_ProductoCreateArgs} args - Arguments to create a Sucursal_Producto.
     * @example
     * // Create one Sucursal_Producto
     * const Sucursal_Producto = await prisma.sucursal_Producto.create({
     *   data: {
     *     // ... data to create a Sucursal_Producto
     *   }
     * })
     * 
    **/
    create<T extends Sucursal_ProductoCreateArgs>(
      args: SelectSubset<T, Sucursal_ProductoCreateArgs>
    ): CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto>, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T>>>

    /**
     * Create many Sucursal_Productos.
     *     @param {Sucursal_ProductoCreateManyArgs} args - Arguments to create many Sucursal_Productos.
     *     @example
     *     // Create many Sucursal_Productos
     *     const sucursal_Producto = await prisma.sucursal_Producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Sucursal_ProductoCreateManyArgs>(
      args?: SelectSubset<T, Sucursal_ProductoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sucursal_Producto.
     * @param {Sucursal_ProductoDeleteArgs} args - Arguments to delete one Sucursal_Producto.
     * @example
     * // Delete one Sucursal_Producto
     * const Sucursal_Producto = await prisma.sucursal_Producto.delete({
     *   where: {
     *     // ... filter to delete one Sucursal_Producto
     *   }
     * })
     * 
    **/
    delete<T extends Sucursal_ProductoDeleteArgs>(
      args: SelectSubset<T, Sucursal_ProductoDeleteArgs>
    ): CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto>, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T>>>

    /**
     * Update one Sucursal_Producto.
     * @param {Sucursal_ProductoUpdateArgs} args - Arguments to update one Sucursal_Producto.
     * @example
     * // Update one Sucursal_Producto
     * const sucursal_Producto = await prisma.sucursal_Producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Sucursal_ProductoUpdateArgs>(
      args: SelectSubset<T, Sucursal_ProductoUpdateArgs>
    ): CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto>, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T>>>

    /**
     * Delete zero or more Sucursal_Productos.
     * @param {Sucursal_ProductoDeleteManyArgs} args - Arguments to filter Sucursal_Productos to delete.
     * @example
     * // Delete a few Sucursal_Productos
     * const { count } = await prisma.sucursal_Producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Sucursal_ProductoDeleteManyArgs>(
      args?: SelectSubset<T, Sucursal_ProductoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sucursal_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sucursal_ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sucursal_Productos
     * const sucursal_Producto = await prisma.sucursal_Producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Sucursal_ProductoUpdateManyArgs>(
      args: SelectSubset<T, Sucursal_ProductoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sucursal_Producto.
     * @param {Sucursal_ProductoUpsertArgs} args - Arguments to update or create a Sucursal_Producto.
     * @example
     * // Update or create a Sucursal_Producto
     * const sucursal_Producto = await prisma.sucursal_Producto.upsert({
     *   create: {
     *     // ... data to create a Sucursal_Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sucursal_Producto we want to update
     *   }
     * })
    **/
    upsert<T extends Sucursal_ProductoUpsertArgs>(
      args: SelectSubset<T, Sucursal_ProductoUpsertArgs>
    ): CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto>, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T>>>

    /**
     * Find one Sucursal_Producto that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Sucursal_ProductoFindUniqueOrThrowArgs} args - Arguments to find a Sucursal_Producto
     * @example
     * // Get one Sucursal_Producto
     * const sucursal_Producto = await prisma.sucursal_Producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Sucursal_ProductoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Sucursal_ProductoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto>, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T>>>

    /**
     * Find the first Sucursal_Producto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sucursal_ProductoFindFirstOrThrowArgs} args - Arguments to find a Sucursal_Producto
     * @example
     * // Get one Sucursal_Producto
     * const sucursal_Producto = await prisma.sucursal_Producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Sucursal_ProductoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Sucursal_ProductoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Sucursal_ProductoClient<Sucursal_Producto>, Prisma__Sucursal_ProductoClient<Sucursal_ProductoGetPayload<T>>>

    /**
     * Count the number of Sucursal_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sucursal_ProductoCountArgs} args - Arguments to filter Sucursal_Productos to count.
     * @example
     * // Count the number of Sucursal_Productos
     * const count = await prisma.sucursal_Producto.count({
     *   where: {
     *     // ... the filter for the Sucursal_Productos we want to count
     *   }
     * })
    **/
    count<T extends Sucursal_ProductoCountArgs>(
      args?: Subset<T, Sucursal_ProductoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sucursal_ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sucursal_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sucursal_ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sucursal_ProductoAggregateArgs>(args: Subset<T, Sucursal_ProductoAggregateArgs>): PrismaPromise<GetSucursal_ProductoAggregateType<T>>

    /**
     * Group by Sucursal_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sucursal_ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Sucursal_ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Sucursal_ProductoGroupByArgs['orderBy'] }
        : { orderBy?: Sucursal_ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Sucursal_ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSucursal_ProductoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Sucursal_Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Sucursal_ProductoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Producto<T extends ProductoArgs = {}>(args?: Subset<T, ProductoArgs>): CheckSelect<T, Prisma__ProductoClient<Producto | null >, Prisma__ProductoClient<ProductoGetPayload<T> | null >>;

    Sucursal<T extends SucursalArgs = {}>(args?: Subset<T, SucursalArgs>): CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Sucursal_Producto base type for findUnique actions
   */
  export type Sucursal_ProductoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Sucursal_Producto
     * 
    **/
    select?: Sucursal_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Sucursal_ProductoInclude | null
    /**
     * Filter, which Sucursal_Producto to fetch.
     * 
    **/
    where: Sucursal_ProductoWhereUniqueInput
  }

  /**
   * Sucursal_Producto: findUnique
   */
  export interface Sucursal_ProductoFindUniqueArgs extends Sucursal_ProductoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sucursal_Producto base type for findFirst actions
   */
  export type Sucursal_ProductoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Sucursal_Producto
     * 
    **/
    select?: Sucursal_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Sucursal_ProductoInclude | null
    /**
     * Filter, which Sucursal_Producto to fetch.
     * 
    **/
    where?: Sucursal_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sucursal_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Sucursal_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sucursal_Productos.
     * 
    **/
    cursor?: Sucursal_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sucursal_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sucursal_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sucursal_Productos.
     * 
    **/
    distinct?: Enumerable<Sucursal_ProductoScalarFieldEnum>
  }

  /**
   * Sucursal_Producto: findFirst
   */
  export interface Sucursal_ProductoFindFirstArgs extends Sucursal_ProductoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sucursal_Producto findMany
   */
  export type Sucursal_ProductoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Sucursal_Producto
     * 
    **/
    select?: Sucursal_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Sucursal_ProductoInclude | null
    /**
     * Filter, which Sucursal_Productos to fetch.
     * 
    **/
    where?: Sucursal_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sucursal_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Sucursal_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sucursal_Productos.
     * 
    **/
    cursor?: Sucursal_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sucursal_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sucursal_Productos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Sucursal_ProductoScalarFieldEnum>
  }


  /**
   * Sucursal_Producto create
   */
  export type Sucursal_ProductoCreateArgs = {
    /**
     * Select specific fields to fetch from the Sucursal_Producto
     * 
    **/
    select?: Sucursal_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Sucursal_ProductoInclude | null
    /**
     * The data needed to create a Sucursal_Producto.
     * 
    **/
    data: XOR<Sucursal_ProductoCreateInput, Sucursal_ProductoUncheckedCreateInput>
  }


  /**
   * Sucursal_Producto createMany
   */
  export type Sucursal_ProductoCreateManyArgs = {
    /**
     * The data used to create many Sucursal_Productos.
     * 
    **/
    data: Enumerable<Sucursal_ProductoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Sucursal_Producto update
   */
  export type Sucursal_ProductoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Sucursal_Producto
     * 
    **/
    select?: Sucursal_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Sucursal_ProductoInclude | null
    /**
     * The data needed to update a Sucursal_Producto.
     * 
    **/
    data: XOR<Sucursal_ProductoUpdateInput, Sucursal_ProductoUncheckedUpdateInput>
    /**
     * Choose, which Sucursal_Producto to update.
     * 
    **/
    where: Sucursal_ProductoWhereUniqueInput
  }


  /**
   * Sucursal_Producto updateMany
   */
  export type Sucursal_ProductoUpdateManyArgs = {
    /**
     * The data used to update Sucursal_Productos.
     * 
    **/
    data: XOR<Sucursal_ProductoUpdateManyMutationInput, Sucursal_ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Sucursal_Productos to update
     * 
    **/
    where?: Sucursal_ProductoWhereInput
  }


  /**
   * Sucursal_Producto upsert
   */
  export type Sucursal_ProductoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Sucursal_Producto
     * 
    **/
    select?: Sucursal_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Sucursal_ProductoInclude | null
    /**
     * The filter to search for the Sucursal_Producto to update in case it exists.
     * 
    **/
    where: Sucursal_ProductoWhereUniqueInput
    /**
     * In case the Sucursal_Producto found by the `where` argument doesn't exist, create a new Sucursal_Producto with this data.
     * 
    **/
    create: XOR<Sucursal_ProductoCreateInput, Sucursal_ProductoUncheckedCreateInput>
    /**
     * In case the Sucursal_Producto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Sucursal_ProductoUpdateInput, Sucursal_ProductoUncheckedUpdateInput>
  }


  /**
   * Sucursal_Producto delete
   */
  export type Sucursal_ProductoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Sucursal_Producto
     * 
    **/
    select?: Sucursal_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Sucursal_ProductoInclude | null
    /**
     * Filter which Sucursal_Producto to delete.
     * 
    **/
    where: Sucursal_ProductoWhereUniqueInput
  }


  /**
   * Sucursal_Producto deleteMany
   */
  export type Sucursal_ProductoDeleteManyArgs = {
    /**
     * Filter which Sucursal_Productos to delete
     * 
    **/
    where?: Sucursal_ProductoWhereInput
  }


  /**
   * Sucursal_Producto: findUniqueOrThrow
   */
  export type Sucursal_ProductoFindUniqueOrThrowArgs = Sucursal_ProductoFindUniqueArgsBase
      

  /**
   * Sucursal_Producto: findFirstOrThrow
   */
  export type Sucursal_ProductoFindFirstOrThrowArgs = Sucursal_ProductoFindFirstArgsBase
      

  /**
   * Sucursal_Producto without action
   */
  export type Sucursal_ProductoArgs = {
    /**
     * Select specific fields to fetch from the Sucursal_Producto
     * 
    **/
    select?: Sucursal_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Sucursal_ProductoInclude | null
  }



  /**
   * Model TipoPago
   */


  export type AggregateTipoPago = {
    _count: TipoPagoCountAggregateOutputType | null
    _avg: TipoPagoAvgAggregateOutputType | null
    _sum: TipoPagoSumAggregateOutputType | null
    _min: TipoPagoMinAggregateOutputType | null
    _max: TipoPagoMaxAggregateOutputType | null
  }

  export type TipoPagoAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoPagoSumAggregateOutputType = {
    id: number | null
  }

  export type TipoPagoMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type TipoPagoMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type TipoPagoCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type TipoPagoAvgAggregateInputType = {
    id?: true
  }

  export type TipoPagoSumAggregateInputType = {
    id?: true
  }

  export type TipoPagoMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type TipoPagoMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type TipoPagoCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type TipoPagoAggregateArgs = {
    /**
     * Filter which TipoPago to aggregate.
     * 
    **/
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoPagos
    **/
    _count?: true | TipoPagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoPagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoPagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoPagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoPagoMaxAggregateInputType
  }

  export type GetTipoPagoAggregateType<T extends TipoPagoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoPago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoPago[P]>
      : GetScalarType<T[P], AggregateTipoPago[P]>
  }




  export type TipoPagoGroupByArgs = {
    where?: TipoPagoWhereInput
    orderBy?: Enumerable<TipoPagoOrderByWithAggregationInput>
    by: Array<TipoPagoScalarFieldEnum>
    having?: TipoPagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoPagoCountAggregateInputType | true
    _avg?: TipoPagoAvgAggregateInputType
    _sum?: TipoPagoSumAggregateInputType
    _min?: TipoPagoMinAggregateInputType
    _max?: TipoPagoMaxAggregateInputType
  }


  export type TipoPagoGroupByOutputType = {
    id: number
    descripcion: string
    _count: TipoPagoCountAggregateOutputType | null
    _avg: TipoPagoAvgAggregateOutputType | null
    _sum: TipoPagoSumAggregateOutputType | null
    _min: TipoPagoMinAggregateOutputType | null
    _max: TipoPagoMaxAggregateOutputType | null
  }

  type GetTipoPagoGroupByPayload<T extends TipoPagoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TipoPagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoPagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoPagoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoPagoGroupByOutputType[P]>
        }
      >
    >


  export type TipoPagoSelect = {
    id?: boolean
    descripcion?: boolean
    facturas?: boolean | Factura_EncabezadoFindManyArgs
    _count?: boolean | TipoPagoCountOutputTypeArgs
  }

  export type TipoPagoInclude = {
    facturas?: boolean | Factura_EncabezadoFindManyArgs
    _count?: boolean | TipoPagoCountOutputTypeArgs
  }

  export type TipoPagoGetPayload<
    S extends boolean | null | undefined | TipoPagoArgs,
    U = keyof S
      > = S extends true
        ? TipoPago
    : S extends undefined
    ? never
    : S extends TipoPagoArgs | TipoPagoFindManyArgs
    ?'include' extends U
    ? TipoPago  & {
    [P in TrueKeys<S['include']>]:
        P extends 'facturas' ? Array < Factura_EncabezadoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TipoPagoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'facturas' ? Array < Factura_EncabezadoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TipoPagoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof TipoPago ? TipoPago[P] : never
  } 
    : TipoPago
  : TipoPago


  type TipoPagoCountArgs = Merge<
    Omit<TipoPagoFindManyArgs, 'select' | 'include'> & {
      select?: TipoPagoCountAggregateInputType | true
    }
  >

  export interface TipoPagoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TipoPago that matches the filter.
     * @param {TipoPagoFindUniqueArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TipoPagoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TipoPagoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TipoPago'> extends True ? CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>> : CheckSelect<T, Prisma__TipoPagoClient<TipoPago | null >, Prisma__TipoPagoClient<TipoPagoGetPayload<T> | null >>

    /**
     * Find the first TipoPago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoFindFirstArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TipoPagoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TipoPagoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TipoPago'> extends True ? CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>> : CheckSelect<T, Prisma__TipoPagoClient<TipoPago | null >, Prisma__TipoPagoClient<TipoPagoGetPayload<T> | null >>

    /**
     * Find zero or more TipoPagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoPagos
     * const tipoPagos = await prisma.tipoPago.findMany()
     * 
     * // Get first 10 TipoPagos
     * const tipoPagos = await prisma.tipoPago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoPagoWithIdOnly = await prisma.tipoPago.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TipoPagoFindManyArgs>(
      args?: SelectSubset<T, TipoPagoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TipoPago>>, PrismaPromise<Array<TipoPagoGetPayload<T>>>>

    /**
     * Create a TipoPago.
     * @param {TipoPagoCreateArgs} args - Arguments to create a TipoPago.
     * @example
     * // Create one TipoPago
     * const TipoPago = await prisma.tipoPago.create({
     *   data: {
     *     // ... data to create a TipoPago
     *   }
     * })
     * 
    **/
    create<T extends TipoPagoCreateArgs>(
      args: SelectSubset<T, TipoPagoCreateArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Create many TipoPagos.
     *     @param {TipoPagoCreateManyArgs} args - Arguments to create many TipoPagos.
     *     @example
     *     // Create many TipoPagos
     *     const tipoPago = await prisma.tipoPago.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TipoPagoCreateManyArgs>(
      args?: SelectSubset<T, TipoPagoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TipoPago.
     * @param {TipoPagoDeleteArgs} args - Arguments to delete one TipoPago.
     * @example
     * // Delete one TipoPago
     * const TipoPago = await prisma.tipoPago.delete({
     *   where: {
     *     // ... filter to delete one TipoPago
     *   }
     * })
     * 
    **/
    delete<T extends TipoPagoDeleteArgs>(
      args: SelectSubset<T, TipoPagoDeleteArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Update one TipoPago.
     * @param {TipoPagoUpdateArgs} args - Arguments to update one TipoPago.
     * @example
     * // Update one TipoPago
     * const tipoPago = await prisma.tipoPago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TipoPagoUpdateArgs>(
      args: SelectSubset<T, TipoPagoUpdateArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Delete zero or more TipoPagos.
     * @param {TipoPagoDeleteManyArgs} args - Arguments to filter TipoPagos to delete.
     * @example
     * // Delete a few TipoPagos
     * const { count } = await prisma.tipoPago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TipoPagoDeleteManyArgs>(
      args?: SelectSubset<T, TipoPagoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoPagos
     * const tipoPago = await prisma.tipoPago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TipoPagoUpdateManyArgs>(
      args: SelectSubset<T, TipoPagoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoPago.
     * @param {TipoPagoUpsertArgs} args - Arguments to update or create a TipoPago.
     * @example
     * // Update or create a TipoPago
     * const tipoPago = await prisma.tipoPago.upsert({
     *   create: {
     *     // ... data to create a TipoPago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoPago we want to update
     *   }
     * })
    **/
    upsert<T extends TipoPagoUpsertArgs>(
      args: SelectSubset<T, TipoPagoUpsertArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Find one TipoPago that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TipoPagoFindUniqueOrThrowArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TipoPagoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TipoPagoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Find the first TipoPago that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoFindFirstOrThrowArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TipoPagoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TipoPagoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Count the number of TipoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoCountArgs} args - Arguments to filter TipoPagos to count.
     * @example
     * // Count the number of TipoPagos
     * const count = await prisma.tipoPago.count({
     *   where: {
     *     // ... the filter for the TipoPagos we want to count
     *   }
     * })
    **/
    count<T extends TipoPagoCountArgs>(
      args?: Subset<T, TipoPagoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoPagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoPagoAggregateArgs>(args: Subset<T, TipoPagoAggregateArgs>): PrismaPromise<GetTipoPagoAggregateType<T>>

    /**
     * Group by TipoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoPagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoPagoGroupByArgs['orderBy'] }
        : { orderBy?: TipoPagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoPagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoPagoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoPago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TipoPagoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    facturas<T extends Factura_EncabezadoFindManyArgs = {}>(args?: Subset<T, Factura_EncabezadoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Factura_Encabezado>>, PrismaPromise<Array<Factura_EncabezadoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TipoPago base type for findUnique actions
   */
  export type TipoPagoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * Filter, which TipoPago to fetch.
     * 
    **/
    where: TipoPagoWhereUniqueInput
  }

  /**
   * TipoPago: findUnique
   */
  export interface TipoPagoFindUniqueArgs extends TipoPagoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoPago base type for findFirst actions
   */
  export type TipoPagoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * Filter, which TipoPago to fetch.
     * 
    **/
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoPagos.
     * 
    **/
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoPagos.
     * 
    **/
    distinct?: Enumerable<TipoPagoScalarFieldEnum>
  }

  /**
   * TipoPago: findFirst
   */
  export interface TipoPagoFindFirstArgs extends TipoPagoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoPago findMany
   */
  export type TipoPagoFindManyArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * Filter, which TipoPagos to fetch.
     * 
    **/
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoPagos.
     * 
    **/
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TipoPagoScalarFieldEnum>
  }


  /**
   * TipoPago create
   */
  export type TipoPagoCreateArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * The data needed to create a TipoPago.
     * 
    **/
    data: XOR<TipoPagoCreateInput, TipoPagoUncheckedCreateInput>
  }


  /**
   * TipoPago createMany
   */
  export type TipoPagoCreateManyArgs = {
    /**
     * The data used to create many TipoPagos.
     * 
    **/
    data: Enumerable<TipoPagoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TipoPago update
   */
  export type TipoPagoUpdateArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * The data needed to update a TipoPago.
     * 
    **/
    data: XOR<TipoPagoUpdateInput, TipoPagoUncheckedUpdateInput>
    /**
     * Choose, which TipoPago to update.
     * 
    **/
    where: TipoPagoWhereUniqueInput
  }


  /**
   * TipoPago updateMany
   */
  export type TipoPagoUpdateManyArgs = {
    /**
     * The data used to update TipoPagos.
     * 
    **/
    data: XOR<TipoPagoUpdateManyMutationInput, TipoPagoUncheckedUpdateManyInput>
    /**
     * Filter which TipoPagos to update
     * 
    **/
    where?: TipoPagoWhereInput
  }


  /**
   * TipoPago upsert
   */
  export type TipoPagoUpsertArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * The filter to search for the TipoPago to update in case it exists.
     * 
    **/
    where: TipoPagoWhereUniqueInput
    /**
     * In case the TipoPago found by the `where` argument doesn't exist, create a new TipoPago with this data.
     * 
    **/
    create: XOR<TipoPagoCreateInput, TipoPagoUncheckedCreateInput>
    /**
     * In case the TipoPago was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TipoPagoUpdateInput, TipoPagoUncheckedUpdateInput>
  }


  /**
   * TipoPago delete
   */
  export type TipoPagoDeleteArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * Filter which TipoPago to delete.
     * 
    **/
    where: TipoPagoWhereUniqueInput
  }


  /**
   * TipoPago deleteMany
   */
  export type TipoPagoDeleteManyArgs = {
    /**
     * Filter which TipoPagos to delete
     * 
    **/
    where?: TipoPagoWhereInput
  }


  /**
   * TipoPago: findUniqueOrThrow
   */
  export type TipoPagoFindUniqueOrThrowArgs = TipoPagoFindUniqueArgsBase
      

  /**
   * TipoPago: findFirstOrThrow
   */
  export type TipoPagoFindFirstOrThrowArgs = TipoPagoFindFirstArgsBase
      

  /**
   * TipoPago without action
   */
  export type TipoPagoArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
  }



  /**
   * Model Factura_Encabezado
   */


  export type AggregateFactura_Encabezado = {
    _count: Factura_EncabezadoCountAggregateOutputType | null
    _avg: Factura_EncabezadoAvgAggregateOutputType | null
    _sum: Factura_EncabezadoSumAggregateOutputType | null
    _min: Factura_EncabezadoMinAggregateOutputType | null
    _max: Factura_EncabezadoMaxAggregateOutputType | null
  }

  export type Factura_EncabezadoAvgAggregateOutputType = {
    id: number | null
    idTipoPago: number | null
  }

  export type Factura_EncabezadoSumAggregateOutputType = {
    id: bigint | null
    idTipoPago: number | null
  }

  export type Factura_EncabezadoMinAggregateOutputType = {
    id: bigint | null
    numero_tarjeta: string | null
    tarjeta: TipoTarjeta | null
    fecha: Date | null
    estado: boolean | null
    idUsuario: string | null
    idTipoPago: number | null
  }

  export type Factura_EncabezadoMaxAggregateOutputType = {
    id: bigint | null
    numero_tarjeta: string | null
    tarjeta: TipoTarjeta | null
    fecha: Date | null
    estado: boolean | null
    idUsuario: string | null
    idTipoPago: number | null
  }

  export type Factura_EncabezadoCountAggregateOutputType = {
    id: number
    numero_tarjeta: number
    tarjeta: number
    fecha: number
    estado: number
    idUsuario: number
    idTipoPago: number
    _all: number
  }


  export type Factura_EncabezadoAvgAggregateInputType = {
    id?: true
    idTipoPago?: true
  }

  export type Factura_EncabezadoSumAggregateInputType = {
    id?: true
    idTipoPago?: true
  }

  export type Factura_EncabezadoMinAggregateInputType = {
    id?: true
    numero_tarjeta?: true
    tarjeta?: true
    fecha?: true
    estado?: true
    idUsuario?: true
    idTipoPago?: true
  }

  export type Factura_EncabezadoMaxAggregateInputType = {
    id?: true
    numero_tarjeta?: true
    tarjeta?: true
    fecha?: true
    estado?: true
    idUsuario?: true
    idTipoPago?: true
  }

  export type Factura_EncabezadoCountAggregateInputType = {
    id?: true
    numero_tarjeta?: true
    tarjeta?: true
    fecha?: true
    estado?: true
    idUsuario?: true
    idTipoPago?: true
    _all?: true
  }

  export type Factura_EncabezadoAggregateArgs = {
    /**
     * Filter which Factura_Encabezado to aggregate.
     * 
    **/
    where?: Factura_EncabezadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Encabezados to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_EncabezadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Factura_EncabezadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Encabezados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Encabezados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Factura_Encabezados
    **/
    _count?: true | Factura_EncabezadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Factura_EncabezadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Factura_EncabezadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Factura_EncabezadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Factura_EncabezadoMaxAggregateInputType
  }

  export type GetFactura_EncabezadoAggregateType<T extends Factura_EncabezadoAggregateArgs> = {
        [P in keyof T & keyof AggregateFactura_Encabezado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactura_Encabezado[P]>
      : GetScalarType<T[P], AggregateFactura_Encabezado[P]>
  }




  export type Factura_EncabezadoGroupByArgs = {
    where?: Factura_EncabezadoWhereInput
    orderBy?: Enumerable<Factura_EncabezadoOrderByWithAggregationInput>
    by: Array<Factura_EncabezadoScalarFieldEnum>
    having?: Factura_EncabezadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Factura_EncabezadoCountAggregateInputType | true
    _avg?: Factura_EncabezadoAvgAggregateInputType
    _sum?: Factura_EncabezadoSumAggregateInputType
    _min?: Factura_EncabezadoMinAggregateInputType
    _max?: Factura_EncabezadoMaxAggregateInputType
  }


  export type Factura_EncabezadoGroupByOutputType = {
    id: bigint
    numero_tarjeta: string | null
    tarjeta: TipoTarjeta | null
    fecha: Date
    estado: boolean
    idUsuario: string
    idTipoPago: number
    _count: Factura_EncabezadoCountAggregateOutputType | null
    _avg: Factura_EncabezadoAvgAggregateOutputType | null
    _sum: Factura_EncabezadoSumAggregateOutputType | null
    _min: Factura_EncabezadoMinAggregateOutputType | null
    _max: Factura_EncabezadoMaxAggregateOutputType | null
  }

  type GetFactura_EncabezadoGroupByPayload<T extends Factura_EncabezadoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Factura_EncabezadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Factura_EncabezadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Factura_EncabezadoGroupByOutputType[P]>
            : GetScalarType<T[P], Factura_EncabezadoGroupByOutputType[P]>
        }
      >
    >


  export type Factura_EncabezadoSelect = {
    id?: boolean
    numero_tarjeta?: boolean
    tarjeta?: boolean
    fecha?: boolean
    estado?: boolean
    detalles?: boolean | Factura_DetalleFindManyArgs
    Usuario?: boolean | UsuarioArgs
    idUsuario?: boolean
    TipoPago?: boolean | TipoPagoArgs
    idTipoPago?: boolean
    _count?: boolean | Factura_EncabezadoCountOutputTypeArgs
  }

  export type Factura_EncabezadoInclude = {
    detalles?: boolean | Factura_DetalleFindManyArgs
    Usuario?: boolean | UsuarioArgs
    TipoPago?: boolean | TipoPagoArgs
    _count?: boolean | Factura_EncabezadoCountOutputTypeArgs
  }

  export type Factura_EncabezadoGetPayload<
    S extends boolean | null | undefined | Factura_EncabezadoArgs,
    U = keyof S
      > = S extends true
        ? Factura_Encabezado
    : S extends undefined
    ? never
    : S extends Factura_EncabezadoArgs | Factura_EncabezadoFindManyArgs
    ?'include' extends U
    ? Factura_Encabezado  & {
    [P in TrueKeys<S['include']>]:
        P extends 'detalles' ? Array < Factura_DetalleGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'TipoPago' ? TipoPagoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? Factura_EncabezadoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'detalles' ? Array < Factura_DetalleGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'TipoPago' ? TipoPagoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? Factura_EncabezadoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Factura_Encabezado ? Factura_Encabezado[P] : never
  } 
    : Factura_Encabezado
  : Factura_Encabezado


  type Factura_EncabezadoCountArgs = Merge<
    Omit<Factura_EncabezadoFindManyArgs, 'select' | 'include'> & {
      select?: Factura_EncabezadoCountAggregateInputType | true
    }
  >

  export interface Factura_EncabezadoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Factura_Encabezado that matches the filter.
     * @param {Factura_EncabezadoFindUniqueArgs} args - Arguments to find a Factura_Encabezado
     * @example
     * // Get one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Factura_EncabezadoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Factura_EncabezadoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Factura_Encabezado'> extends True ? CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>> : CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado | null >, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T> | null >>

    /**
     * Find the first Factura_Encabezado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoFindFirstArgs} args - Arguments to find a Factura_Encabezado
     * @example
     * // Get one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Factura_EncabezadoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Factura_EncabezadoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Factura_Encabezado'> extends True ? CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>> : CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado | null >, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T> | null >>

    /**
     * Find zero or more Factura_Encabezados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Factura_Encabezados
     * const factura_Encabezados = await prisma.factura_Encabezado.findMany()
     * 
     * // Get first 10 Factura_Encabezados
     * const factura_Encabezados = await prisma.factura_Encabezado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factura_EncabezadoWithIdOnly = await prisma.factura_Encabezado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Factura_EncabezadoFindManyArgs>(
      args?: SelectSubset<T, Factura_EncabezadoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Factura_Encabezado>>, PrismaPromise<Array<Factura_EncabezadoGetPayload<T>>>>

    /**
     * Create a Factura_Encabezado.
     * @param {Factura_EncabezadoCreateArgs} args - Arguments to create a Factura_Encabezado.
     * @example
     * // Create one Factura_Encabezado
     * const Factura_Encabezado = await prisma.factura_Encabezado.create({
     *   data: {
     *     // ... data to create a Factura_Encabezado
     *   }
     * })
     * 
    **/
    create<T extends Factura_EncabezadoCreateArgs>(
      args: SelectSubset<T, Factura_EncabezadoCreateArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Create many Factura_Encabezados.
     *     @param {Factura_EncabezadoCreateManyArgs} args - Arguments to create many Factura_Encabezados.
     *     @example
     *     // Create many Factura_Encabezados
     *     const factura_Encabezado = await prisma.factura_Encabezado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Factura_EncabezadoCreateManyArgs>(
      args?: SelectSubset<T, Factura_EncabezadoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Factura_Encabezado.
     * @param {Factura_EncabezadoDeleteArgs} args - Arguments to delete one Factura_Encabezado.
     * @example
     * // Delete one Factura_Encabezado
     * const Factura_Encabezado = await prisma.factura_Encabezado.delete({
     *   where: {
     *     // ... filter to delete one Factura_Encabezado
     *   }
     * })
     * 
    **/
    delete<T extends Factura_EncabezadoDeleteArgs>(
      args: SelectSubset<T, Factura_EncabezadoDeleteArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Update one Factura_Encabezado.
     * @param {Factura_EncabezadoUpdateArgs} args - Arguments to update one Factura_Encabezado.
     * @example
     * // Update one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Factura_EncabezadoUpdateArgs>(
      args: SelectSubset<T, Factura_EncabezadoUpdateArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Delete zero or more Factura_Encabezados.
     * @param {Factura_EncabezadoDeleteManyArgs} args - Arguments to filter Factura_Encabezados to delete.
     * @example
     * // Delete a few Factura_Encabezados
     * const { count } = await prisma.factura_Encabezado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Factura_EncabezadoDeleteManyArgs>(
      args?: SelectSubset<T, Factura_EncabezadoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factura_Encabezados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Factura_Encabezados
     * const factura_Encabezado = await prisma.factura_Encabezado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Factura_EncabezadoUpdateManyArgs>(
      args: SelectSubset<T, Factura_EncabezadoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Factura_Encabezado.
     * @param {Factura_EncabezadoUpsertArgs} args - Arguments to update or create a Factura_Encabezado.
     * @example
     * // Update or create a Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.upsert({
     *   create: {
     *     // ... data to create a Factura_Encabezado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Factura_Encabezado we want to update
     *   }
     * })
    **/
    upsert<T extends Factura_EncabezadoUpsertArgs>(
      args: SelectSubset<T, Factura_EncabezadoUpsertArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Find one Factura_Encabezado that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Factura_EncabezadoFindUniqueOrThrowArgs} args - Arguments to find a Factura_Encabezado
     * @example
     * // Get one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Factura_EncabezadoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Factura_EncabezadoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Find the first Factura_Encabezado that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoFindFirstOrThrowArgs} args - Arguments to find a Factura_Encabezado
     * @example
     * // Get one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Factura_EncabezadoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Factura_EncabezadoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Count the number of Factura_Encabezados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoCountArgs} args - Arguments to filter Factura_Encabezados to count.
     * @example
     * // Count the number of Factura_Encabezados
     * const count = await prisma.factura_Encabezado.count({
     *   where: {
     *     // ... the filter for the Factura_Encabezados we want to count
     *   }
     * })
    **/
    count<T extends Factura_EncabezadoCountArgs>(
      args?: Subset<T, Factura_EncabezadoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Factura_EncabezadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Factura_Encabezado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Factura_EncabezadoAggregateArgs>(args: Subset<T, Factura_EncabezadoAggregateArgs>): PrismaPromise<GetFactura_EncabezadoAggregateType<T>>

    /**
     * Group by Factura_Encabezado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Factura_EncabezadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Factura_EncabezadoGroupByArgs['orderBy'] }
        : { orderBy?: Factura_EncabezadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Factura_EncabezadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactura_EncabezadoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Factura_Encabezado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Factura_EncabezadoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    detalles<T extends Factura_DetalleFindManyArgs = {}>(args?: Subset<T, Factura_DetalleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Factura_Detalle>>, PrismaPromise<Array<Factura_DetalleGetPayload<T>>>>;

    Usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>;

    TipoPago<T extends TipoPagoArgs = {}>(args?: Subset<T, TipoPagoArgs>): CheckSelect<T, Prisma__TipoPagoClient<TipoPago | null >, Prisma__TipoPagoClient<TipoPagoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Factura_Encabezado base type for findUnique actions
   */
  export type Factura_EncabezadoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * Filter, which Factura_Encabezado to fetch.
     * 
    **/
    where: Factura_EncabezadoWhereUniqueInput
  }

  /**
   * Factura_Encabezado: findUnique
   */
  export interface Factura_EncabezadoFindUniqueArgs extends Factura_EncabezadoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Factura_Encabezado base type for findFirst actions
   */
  export type Factura_EncabezadoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * Filter, which Factura_Encabezado to fetch.
     * 
    **/
    where?: Factura_EncabezadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Encabezados to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_EncabezadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Factura_Encabezados.
     * 
    **/
    cursor?: Factura_EncabezadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Encabezados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Encabezados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Factura_Encabezados.
     * 
    **/
    distinct?: Enumerable<Factura_EncabezadoScalarFieldEnum>
  }

  /**
   * Factura_Encabezado: findFirst
   */
  export interface Factura_EncabezadoFindFirstArgs extends Factura_EncabezadoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Factura_Encabezado findMany
   */
  export type Factura_EncabezadoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * Filter, which Factura_Encabezados to fetch.
     * 
    **/
    where?: Factura_EncabezadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Encabezados to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_EncabezadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Factura_Encabezados.
     * 
    **/
    cursor?: Factura_EncabezadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Encabezados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Encabezados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Factura_EncabezadoScalarFieldEnum>
  }


  /**
   * Factura_Encabezado create
   */
  export type Factura_EncabezadoCreateArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * The data needed to create a Factura_Encabezado.
     * 
    **/
    data: XOR<Factura_EncabezadoCreateInput, Factura_EncabezadoUncheckedCreateInput>
  }


  /**
   * Factura_Encabezado createMany
   */
  export type Factura_EncabezadoCreateManyArgs = {
    /**
     * The data used to create many Factura_Encabezados.
     * 
    **/
    data: Enumerable<Factura_EncabezadoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Factura_Encabezado update
   */
  export type Factura_EncabezadoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * The data needed to update a Factura_Encabezado.
     * 
    **/
    data: XOR<Factura_EncabezadoUpdateInput, Factura_EncabezadoUncheckedUpdateInput>
    /**
     * Choose, which Factura_Encabezado to update.
     * 
    **/
    where: Factura_EncabezadoWhereUniqueInput
  }


  /**
   * Factura_Encabezado updateMany
   */
  export type Factura_EncabezadoUpdateManyArgs = {
    /**
     * The data used to update Factura_Encabezados.
     * 
    **/
    data: XOR<Factura_EncabezadoUpdateManyMutationInput, Factura_EncabezadoUncheckedUpdateManyInput>
    /**
     * Filter which Factura_Encabezados to update
     * 
    **/
    where?: Factura_EncabezadoWhereInput
  }


  /**
   * Factura_Encabezado upsert
   */
  export type Factura_EncabezadoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * The filter to search for the Factura_Encabezado to update in case it exists.
     * 
    **/
    where: Factura_EncabezadoWhereUniqueInput
    /**
     * In case the Factura_Encabezado found by the `where` argument doesn't exist, create a new Factura_Encabezado with this data.
     * 
    **/
    create: XOR<Factura_EncabezadoCreateInput, Factura_EncabezadoUncheckedCreateInput>
    /**
     * In case the Factura_Encabezado was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Factura_EncabezadoUpdateInput, Factura_EncabezadoUncheckedUpdateInput>
  }


  /**
   * Factura_Encabezado delete
   */
  export type Factura_EncabezadoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * Filter which Factura_Encabezado to delete.
     * 
    **/
    where: Factura_EncabezadoWhereUniqueInput
  }


  /**
   * Factura_Encabezado deleteMany
   */
  export type Factura_EncabezadoDeleteManyArgs = {
    /**
     * Filter which Factura_Encabezados to delete
     * 
    **/
    where?: Factura_EncabezadoWhereInput
  }


  /**
   * Factura_Encabezado: findUniqueOrThrow
   */
  export type Factura_EncabezadoFindUniqueOrThrowArgs = Factura_EncabezadoFindUniqueArgsBase
      

  /**
   * Factura_Encabezado: findFirstOrThrow
   */
  export type Factura_EncabezadoFindFirstOrThrowArgs = Factura_EncabezadoFindFirstArgsBase
      

  /**
   * Factura_Encabezado without action
   */
  export type Factura_EncabezadoArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
  }



  /**
   * Model Factura_Detalle
   */


  export type AggregateFactura_Detalle = {
    _count: Factura_DetalleCountAggregateOutputType | null
    _avg: Factura_DetalleAvgAggregateOutputType | null
    _sum: Factura_DetalleSumAggregateOutputType | null
    _min: Factura_DetalleMinAggregateOutputType | null
    _max: Factura_DetalleMaxAggregateOutputType | null
  }

  export type Factura_DetalleAvgAggregateOutputType = {
    id: number | null
    cantidad: number | null
    precio: Decimal | null
    impuesto: Decimal | null
    total_detalle: Decimal | null
    idFactura_Encabezado: number | null
    idProducto: number | null
  }

  export type Factura_DetalleSumAggregateOutputType = {
    id: bigint | null
    cantidad: number | null
    precio: Decimal | null
    impuesto: Decimal | null
    total_detalle: Decimal | null
    idFactura_Encabezado: bigint | null
    idProducto: bigint | null
  }

  export type Factura_DetalleMinAggregateOutputType = {
    id: bigint | null
    cantidad: number | null
    precio: Decimal | null
    impuesto: Decimal | null
    total_detalle: Decimal | null
    idFactura_Encabezado: bigint | null
    idProducto: bigint | null
  }

  export type Factura_DetalleMaxAggregateOutputType = {
    id: bigint | null
    cantidad: number | null
    precio: Decimal | null
    impuesto: Decimal | null
    total_detalle: Decimal | null
    idFactura_Encabezado: bigint | null
    idProducto: bigint | null
  }

  export type Factura_DetalleCountAggregateOutputType = {
    id: number
    cantidad: number
    precio: number
    impuesto: number
    total_detalle: number
    idFactura_Encabezado: number
    idProducto: number
    _all: number
  }


  export type Factura_DetalleAvgAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
  }

  export type Factura_DetalleSumAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
  }

  export type Factura_DetalleMinAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
  }

  export type Factura_DetalleMaxAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
  }

  export type Factura_DetalleCountAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
    _all?: true
  }

  export type Factura_DetalleAggregateArgs = {
    /**
     * Filter which Factura_Detalle to aggregate.
     * 
    **/
    where?: Factura_DetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Detalles to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_DetalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Factura_DetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Detalles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Detalles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Factura_Detalles
    **/
    _count?: true | Factura_DetalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Factura_DetalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Factura_DetalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Factura_DetalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Factura_DetalleMaxAggregateInputType
  }

  export type GetFactura_DetalleAggregateType<T extends Factura_DetalleAggregateArgs> = {
        [P in keyof T & keyof AggregateFactura_Detalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactura_Detalle[P]>
      : GetScalarType<T[P], AggregateFactura_Detalle[P]>
  }




  export type Factura_DetalleGroupByArgs = {
    where?: Factura_DetalleWhereInput
    orderBy?: Enumerable<Factura_DetalleOrderByWithAggregationInput>
    by: Array<Factura_DetalleScalarFieldEnum>
    having?: Factura_DetalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Factura_DetalleCountAggregateInputType | true
    _avg?: Factura_DetalleAvgAggregateInputType
    _sum?: Factura_DetalleSumAggregateInputType
    _min?: Factura_DetalleMinAggregateInputType
    _max?: Factura_DetalleMaxAggregateInputType
  }


  export type Factura_DetalleGroupByOutputType = {
    id: bigint
    cantidad: number
    precio: Decimal
    impuesto: Decimal
    total_detalle: Decimal
    idFactura_Encabezado: bigint
    idProducto: bigint
    _count: Factura_DetalleCountAggregateOutputType | null
    _avg: Factura_DetalleAvgAggregateOutputType | null
    _sum: Factura_DetalleSumAggregateOutputType | null
    _min: Factura_DetalleMinAggregateOutputType | null
    _max: Factura_DetalleMaxAggregateOutputType | null
  }

  type GetFactura_DetalleGroupByPayload<T extends Factura_DetalleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Factura_DetalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Factura_DetalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Factura_DetalleGroupByOutputType[P]>
            : GetScalarType<T[P], Factura_DetalleGroupByOutputType[P]>
        }
      >
    >


  export type Factura_DetalleSelect = {
    id?: boolean
    cantidad?: boolean
    precio?: boolean
    impuesto?: boolean
    total_detalle?: boolean
    Factura_Encabezado?: boolean | Factura_EncabezadoArgs
    idFactura_Encabezado?: boolean
    Producto?: boolean | ProductoArgs
    idProducto?: boolean
  }

  export type Factura_DetalleInclude = {
    Factura_Encabezado?: boolean | Factura_EncabezadoArgs
    Producto?: boolean | ProductoArgs
  }

  export type Factura_DetalleGetPayload<
    S extends boolean | null | undefined | Factura_DetalleArgs,
    U = keyof S
      > = S extends true
        ? Factura_Detalle
    : S extends undefined
    ? never
    : S extends Factura_DetalleArgs | Factura_DetalleFindManyArgs
    ?'include' extends U
    ? Factura_Detalle  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Factura_Encabezado' ? Factura_EncabezadoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Factura_Encabezado' ? Factura_EncabezadoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Factura_Detalle ? Factura_Detalle[P] : never
  } 
    : Factura_Detalle
  : Factura_Detalle


  type Factura_DetalleCountArgs = Merge<
    Omit<Factura_DetalleFindManyArgs, 'select' | 'include'> & {
      select?: Factura_DetalleCountAggregateInputType | true
    }
  >

  export interface Factura_DetalleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Factura_Detalle that matches the filter.
     * @param {Factura_DetalleFindUniqueArgs} args - Arguments to find a Factura_Detalle
     * @example
     * // Get one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Factura_DetalleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Factura_DetalleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Factura_Detalle'> extends True ? CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>> : CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle | null >, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T> | null >>

    /**
     * Find the first Factura_Detalle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleFindFirstArgs} args - Arguments to find a Factura_Detalle
     * @example
     * // Get one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Factura_DetalleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Factura_DetalleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Factura_Detalle'> extends True ? CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>> : CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle | null >, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T> | null >>

    /**
     * Find zero or more Factura_Detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Factura_Detalles
     * const factura_Detalles = await prisma.factura_Detalle.findMany()
     * 
     * // Get first 10 Factura_Detalles
     * const factura_Detalles = await prisma.factura_Detalle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factura_DetalleWithIdOnly = await prisma.factura_Detalle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Factura_DetalleFindManyArgs>(
      args?: SelectSubset<T, Factura_DetalleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Factura_Detalle>>, PrismaPromise<Array<Factura_DetalleGetPayload<T>>>>

    /**
     * Create a Factura_Detalle.
     * @param {Factura_DetalleCreateArgs} args - Arguments to create a Factura_Detalle.
     * @example
     * // Create one Factura_Detalle
     * const Factura_Detalle = await prisma.factura_Detalle.create({
     *   data: {
     *     // ... data to create a Factura_Detalle
     *   }
     * })
     * 
    **/
    create<T extends Factura_DetalleCreateArgs>(
      args: SelectSubset<T, Factura_DetalleCreateArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Create many Factura_Detalles.
     *     @param {Factura_DetalleCreateManyArgs} args - Arguments to create many Factura_Detalles.
     *     @example
     *     // Create many Factura_Detalles
     *     const factura_Detalle = await prisma.factura_Detalle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Factura_DetalleCreateManyArgs>(
      args?: SelectSubset<T, Factura_DetalleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Factura_Detalle.
     * @param {Factura_DetalleDeleteArgs} args - Arguments to delete one Factura_Detalle.
     * @example
     * // Delete one Factura_Detalle
     * const Factura_Detalle = await prisma.factura_Detalle.delete({
     *   where: {
     *     // ... filter to delete one Factura_Detalle
     *   }
     * })
     * 
    **/
    delete<T extends Factura_DetalleDeleteArgs>(
      args: SelectSubset<T, Factura_DetalleDeleteArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Update one Factura_Detalle.
     * @param {Factura_DetalleUpdateArgs} args - Arguments to update one Factura_Detalle.
     * @example
     * // Update one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Factura_DetalleUpdateArgs>(
      args: SelectSubset<T, Factura_DetalleUpdateArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Delete zero or more Factura_Detalles.
     * @param {Factura_DetalleDeleteManyArgs} args - Arguments to filter Factura_Detalles to delete.
     * @example
     * // Delete a few Factura_Detalles
     * const { count } = await prisma.factura_Detalle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Factura_DetalleDeleteManyArgs>(
      args?: SelectSubset<T, Factura_DetalleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factura_Detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Factura_Detalles
     * const factura_Detalle = await prisma.factura_Detalle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Factura_DetalleUpdateManyArgs>(
      args: SelectSubset<T, Factura_DetalleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Factura_Detalle.
     * @param {Factura_DetalleUpsertArgs} args - Arguments to update or create a Factura_Detalle.
     * @example
     * // Update or create a Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.upsert({
     *   create: {
     *     // ... data to create a Factura_Detalle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Factura_Detalle we want to update
     *   }
     * })
    **/
    upsert<T extends Factura_DetalleUpsertArgs>(
      args: SelectSubset<T, Factura_DetalleUpsertArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Find one Factura_Detalle that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Factura_DetalleFindUniqueOrThrowArgs} args - Arguments to find a Factura_Detalle
     * @example
     * // Get one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Factura_DetalleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Factura_DetalleFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Find the first Factura_Detalle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleFindFirstOrThrowArgs} args - Arguments to find a Factura_Detalle
     * @example
     * // Get one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Factura_DetalleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Factura_DetalleFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Count the number of Factura_Detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleCountArgs} args - Arguments to filter Factura_Detalles to count.
     * @example
     * // Count the number of Factura_Detalles
     * const count = await prisma.factura_Detalle.count({
     *   where: {
     *     // ... the filter for the Factura_Detalles we want to count
     *   }
     * })
    **/
    count<T extends Factura_DetalleCountArgs>(
      args?: Subset<T, Factura_DetalleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Factura_DetalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Factura_Detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Factura_DetalleAggregateArgs>(args: Subset<T, Factura_DetalleAggregateArgs>): PrismaPromise<GetFactura_DetalleAggregateType<T>>

    /**
     * Group by Factura_Detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Factura_DetalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Factura_DetalleGroupByArgs['orderBy'] }
        : { orderBy?: Factura_DetalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Factura_DetalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactura_DetalleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Factura_Detalle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Factura_DetalleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Factura_Encabezado<T extends Factura_EncabezadoArgs = {}>(args?: Subset<T, Factura_EncabezadoArgs>): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado | null >, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T> | null >>;

    Producto<T extends ProductoArgs = {}>(args?: Subset<T, ProductoArgs>): CheckSelect<T, Prisma__ProductoClient<Producto | null >, Prisma__ProductoClient<ProductoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Factura_Detalle base type for findUnique actions
   */
  export type Factura_DetalleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * Filter, which Factura_Detalle to fetch.
     * 
    **/
    where: Factura_DetalleWhereUniqueInput
  }

  /**
   * Factura_Detalle: findUnique
   */
  export interface Factura_DetalleFindUniqueArgs extends Factura_DetalleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Factura_Detalle base type for findFirst actions
   */
  export type Factura_DetalleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * Filter, which Factura_Detalle to fetch.
     * 
    **/
    where?: Factura_DetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Detalles to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_DetalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Factura_Detalles.
     * 
    **/
    cursor?: Factura_DetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Detalles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Detalles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Factura_Detalles.
     * 
    **/
    distinct?: Enumerable<Factura_DetalleScalarFieldEnum>
  }

  /**
   * Factura_Detalle: findFirst
   */
  export interface Factura_DetalleFindFirstArgs extends Factura_DetalleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Factura_Detalle findMany
   */
  export type Factura_DetalleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * Filter, which Factura_Detalles to fetch.
     * 
    **/
    where?: Factura_DetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Detalles to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_DetalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Factura_Detalles.
     * 
    **/
    cursor?: Factura_DetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Detalles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Detalles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Factura_DetalleScalarFieldEnum>
  }


  /**
   * Factura_Detalle create
   */
  export type Factura_DetalleCreateArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * The data needed to create a Factura_Detalle.
     * 
    **/
    data: XOR<Factura_DetalleCreateInput, Factura_DetalleUncheckedCreateInput>
  }


  /**
   * Factura_Detalle createMany
   */
  export type Factura_DetalleCreateManyArgs = {
    /**
     * The data used to create many Factura_Detalles.
     * 
    **/
    data: Enumerable<Factura_DetalleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Factura_Detalle update
   */
  export type Factura_DetalleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * The data needed to update a Factura_Detalle.
     * 
    **/
    data: XOR<Factura_DetalleUpdateInput, Factura_DetalleUncheckedUpdateInput>
    /**
     * Choose, which Factura_Detalle to update.
     * 
    **/
    where: Factura_DetalleWhereUniqueInput
  }


  /**
   * Factura_Detalle updateMany
   */
  export type Factura_DetalleUpdateManyArgs = {
    /**
     * The data used to update Factura_Detalles.
     * 
    **/
    data: XOR<Factura_DetalleUpdateManyMutationInput, Factura_DetalleUncheckedUpdateManyInput>
    /**
     * Filter which Factura_Detalles to update
     * 
    **/
    where?: Factura_DetalleWhereInput
  }


  /**
   * Factura_Detalle upsert
   */
  export type Factura_DetalleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * The filter to search for the Factura_Detalle to update in case it exists.
     * 
    **/
    where: Factura_DetalleWhereUniqueInput
    /**
     * In case the Factura_Detalle found by the `where` argument doesn't exist, create a new Factura_Detalle with this data.
     * 
    **/
    create: XOR<Factura_DetalleCreateInput, Factura_DetalleUncheckedCreateInput>
    /**
     * In case the Factura_Detalle was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Factura_DetalleUpdateInput, Factura_DetalleUncheckedUpdateInput>
  }


  /**
   * Factura_Detalle delete
   */
  export type Factura_DetalleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * Filter which Factura_Detalle to delete.
     * 
    **/
    where: Factura_DetalleWhereUniqueInput
  }


  /**
   * Factura_Detalle deleteMany
   */
  export type Factura_DetalleDeleteManyArgs = {
    /**
     * Filter which Factura_Detalles to delete
     * 
    **/
    where?: Factura_DetalleWhereInput
  }


  /**
   * Factura_Detalle: findUniqueOrThrow
   */
  export type Factura_DetalleFindUniqueOrThrowArgs = Factura_DetalleFindUniqueArgsBase
      

  /**
   * Factura_Detalle: findFirstOrThrow
   */
  export type Factura_DetalleFindFirstOrThrowArgs = Factura_DetalleFindFirstArgsBase
      

  /**
   * Factura_Detalle without action
   */
  export type Factura_DetalleArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
  }



  /**
   * Model Pedido
   */


  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id: number | null
    precio: Decimal | null
  }

  export type PedidoSumAggregateOutputType = {
    id: bigint | null
    precio: Decimal | null
  }

  export type PedidoMinAggregateOutputType = {
    id: bigint | null
    nombre: string | null
    precio: Decimal | null
    idUsuario: string | null
  }

  export type PedidoMaxAggregateOutputType = {
    id: bigint | null
    nombre: string | null
    precio: Decimal | null
    idUsuario: string | null
  }

  export type PedidoCountAggregateOutputType = {
    id: number
    nombre: number
    precio: number
    idUsuario: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id?: true
    precio?: true
  }

  export type PedidoSumAggregateInputType = {
    id?: true
    precio?: true
  }

  export type PedidoMinAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    idUsuario?: true
  }

  export type PedidoMaxAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    idUsuario?: true
  }

  export type PedidoCountAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    idUsuario?: true
    _all?: true
  }

  export type PedidoAggregateArgs = {
    /**
     * Filter which Pedido to aggregate.
     * 
    **/
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs = {
    where?: PedidoWhereInput
    orderBy?: Enumerable<PedidoOrderByWithAggregationInput>
    by: Array<PedidoScalarFieldEnum>
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }


  export type PedidoGroupByOutputType = {
    id: bigint
    nombre: string | null
    precio: Decimal
    idUsuario: string
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect = {
    id?: boolean
    nombre?: boolean
    precio?: boolean
    productos?: boolean | Pedido_ProductoFindManyArgs
    Usuario?: boolean | UsuarioArgs
    idUsuario?: boolean
    _count?: boolean | PedidoCountOutputTypeArgs
  }

  export type PedidoInclude = {
    productos?: boolean | Pedido_ProductoFindManyArgs
    Usuario?: boolean | UsuarioArgs
    _count?: boolean | PedidoCountOutputTypeArgs
  }

  export type PedidoGetPayload<
    S extends boolean | null | undefined | PedidoArgs,
    U = keyof S
      > = S extends true
        ? Pedido
    : S extends undefined
    ? never
    : S extends PedidoArgs | PedidoFindManyArgs
    ?'include' extends U
    ? Pedido  & {
    [P in TrueKeys<S['include']>]:
        P extends 'productos' ? Array < Pedido_ProductoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? PedidoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'productos' ? Array < Pedido_ProductoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? PedidoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Pedido ? Pedido[P] : never
  } 
    : Pedido
  : Pedido


  type PedidoCountArgs = Merge<
    Omit<PedidoFindManyArgs, 'select' | 'include'> & {
      select?: PedidoCountAggregateInputType | true
    }
  >

  export interface PedidoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PedidoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pedido'> extends True ? CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>> : CheckSelect<T, Prisma__PedidoClient<Pedido | null >, Prisma__PedidoClient<PedidoGetPayload<T> | null >>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PedidoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pedido'> extends True ? CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>> : CheckSelect<T, Prisma__PedidoClient<Pedido | null >, Prisma__PedidoClient<PedidoGetPayload<T> | null >>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoWithIdOnly = await prisma.pedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PedidoFindManyArgs>(
      args?: SelectSubset<T, PedidoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
    **/
    create<T extends PedidoCreateArgs>(
      args: SelectSubset<T, PedidoCreateArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Create many Pedidos.
     *     @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     *     @example
     *     // Create many Pedidos
     *     const pedido = await prisma.pedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoCreateManyArgs>(
      args?: SelectSubset<T, PedidoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
    **/
    delete<T extends PedidoDeleteArgs>(
      args: SelectSubset<T, PedidoDeleteArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoUpdateArgs>(
      args: SelectSubset<T, PedidoUpdateArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoDeleteManyArgs>(
      args?: SelectSubset<T, PedidoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoUpdateManyArgs>(
      args: SelectSubset<T, PedidoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoUpsertArgs>(
      args: SelectSubset<T, PedidoUpsertArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Find one Pedido that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PedidoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Find the first Pedido that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PedidoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PedidoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    productos<T extends Pedido_ProductoFindManyArgs = {}>(args?: Subset<T, Pedido_ProductoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido_Producto>>, PrismaPromise<Array<Pedido_ProductoGetPayload<T>>>>;

    Usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pedido base type for findUnique actions
   */
  export type PedidoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     * 
    **/
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido: findUnique
   */
  export interface PedidoFindUniqueArgs extends PedidoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido base type for findFirst actions
   */
  export type PedidoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     * 
    **/
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     * 
    **/
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     * 
    **/
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }

  /**
   * Pedido: findFirst
   */
  export interface PedidoFindFirstArgs extends PedidoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter, which Pedidos to fetch.
     * 
    **/
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     * 
    **/
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }


  /**
   * Pedido create
   */
  export type PedidoCreateArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * The data needed to create a Pedido.
     * 
    **/
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }


  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs = {
    /**
     * The data used to create many Pedidos.
     * 
    **/
    data: Enumerable<PedidoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pedido update
   */
  export type PedidoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * The data needed to update a Pedido.
     * 
    **/
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     * 
    **/
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs = {
    /**
     * The data used to update Pedidos.
     * 
    **/
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     * 
    **/
    where?: PedidoWhereInput
  }


  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     * 
    **/
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     * 
    **/
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }


  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter which Pedido to delete.
     * 
    **/
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs = {
    /**
     * Filter which Pedidos to delete
     * 
    **/
    where?: PedidoWhereInput
  }


  /**
   * Pedido: findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs = PedidoFindUniqueArgsBase
      

  /**
   * Pedido: findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs = PedidoFindFirstArgsBase
      

  /**
   * Pedido without action
   */
  export type PedidoArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
  }



  /**
   * Model Pedido_Producto
   */


  export type AggregatePedido_Producto = {
    _count: Pedido_ProductoCountAggregateOutputType | null
    _avg: Pedido_ProductoAvgAggregateOutputType | null
    _sum: Pedido_ProductoSumAggregateOutputType | null
    _min: Pedido_ProductoMinAggregateOutputType | null
    _max: Pedido_ProductoMaxAggregateOutputType | null
  }

  export type Pedido_ProductoAvgAggregateOutputType = {
    idPedido: number | null
    idProducto: number | null
    cantidad: number | null
  }

  export type Pedido_ProductoSumAggregateOutputType = {
    idPedido: bigint | null
    idProducto: bigint | null
    cantidad: number | null
  }

  export type Pedido_ProductoMinAggregateOutputType = {
    idPedido: bigint | null
    idProducto: bigint | null
    cantidad: number | null
    notas: string | null
  }

  export type Pedido_ProductoMaxAggregateOutputType = {
    idPedido: bigint | null
    idProducto: bigint | null
    cantidad: number | null
    notas: string | null
  }

  export type Pedido_ProductoCountAggregateOutputType = {
    idPedido: number
    idProducto: number
    cantidad: number
    notas: number
    _all: number
  }


  export type Pedido_ProductoAvgAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
  }

  export type Pedido_ProductoSumAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
  }

  export type Pedido_ProductoMinAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
    notas?: true
  }

  export type Pedido_ProductoMaxAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
    notas?: true
  }

  export type Pedido_ProductoCountAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
    notas?: true
    _all?: true
  }

  export type Pedido_ProductoAggregateArgs = {
    /**
     * Filter which Pedido_Producto to aggregate.
     * 
    **/
    where?: Pedido_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedido_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Pedido_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Pedido_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedido_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedido_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedido_Productos
    **/
    _count?: true | Pedido_ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pedido_ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pedido_ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pedido_ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pedido_ProductoMaxAggregateInputType
  }

  export type GetPedido_ProductoAggregateType<T extends Pedido_ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido_Producto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido_Producto[P]>
      : GetScalarType<T[P], AggregatePedido_Producto[P]>
  }




  export type Pedido_ProductoGroupByArgs = {
    where?: Pedido_ProductoWhereInput
    orderBy?: Enumerable<Pedido_ProductoOrderByWithAggregationInput>
    by: Array<Pedido_ProductoScalarFieldEnum>
    having?: Pedido_ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pedido_ProductoCountAggregateInputType | true
    _avg?: Pedido_ProductoAvgAggregateInputType
    _sum?: Pedido_ProductoSumAggregateInputType
    _min?: Pedido_ProductoMinAggregateInputType
    _max?: Pedido_ProductoMaxAggregateInputType
  }


  export type Pedido_ProductoGroupByOutputType = {
    idPedido: bigint
    idProducto: bigint
    cantidad: number
    notas: string
    _count: Pedido_ProductoCountAggregateOutputType | null
    _avg: Pedido_ProductoAvgAggregateOutputType | null
    _sum: Pedido_ProductoSumAggregateOutputType | null
    _min: Pedido_ProductoMinAggregateOutputType | null
    _max: Pedido_ProductoMaxAggregateOutputType | null
  }

  type GetPedido_ProductoGroupByPayload<T extends Pedido_ProductoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Pedido_ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pedido_ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pedido_ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], Pedido_ProductoGroupByOutputType[P]>
        }
      >
    >


  export type Pedido_ProductoSelect = {
    Pedido?: boolean | PedidoArgs
    idPedido?: boolean
    Producto?: boolean | ProductoArgs
    idProducto?: boolean
    cantidad?: boolean
    notas?: boolean
  }

  export type Pedido_ProductoInclude = {
    Pedido?: boolean | PedidoArgs
    Producto?: boolean | ProductoArgs
  }

  export type Pedido_ProductoGetPayload<
    S extends boolean | null | undefined | Pedido_ProductoArgs,
    U = keyof S
      > = S extends true
        ? Pedido_Producto
    : S extends undefined
    ? never
    : S extends Pedido_ProductoArgs | Pedido_ProductoFindManyArgs
    ?'include' extends U
    ? Pedido_Producto  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Pedido' ? PedidoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Pedido' ? PedidoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Pedido_Producto ? Pedido_Producto[P] : never
  } 
    : Pedido_Producto
  : Pedido_Producto


  type Pedido_ProductoCountArgs = Merge<
    Omit<Pedido_ProductoFindManyArgs, 'select' | 'include'> & {
      select?: Pedido_ProductoCountAggregateInputType | true
    }
  >

  export interface Pedido_ProductoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pedido_Producto that matches the filter.
     * @param {Pedido_ProductoFindUniqueArgs} args - Arguments to find a Pedido_Producto
     * @example
     * // Get one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Pedido_ProductoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Pedido_ProductoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pedido_Producto'> extends True ? CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto | null >, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T> | null >>

    /**
     * Find the first Pedido_Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoFindFirstArgs} args - Arguments to find a Pedido_Producto
     * @example
     * // Get one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Pedido_ProductoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Pedido_ProductoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pedido_Producto'> extends True ? CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto | null >, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T> | null >>

    /**
     * Find zero or more Pedido_Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedido_Productos
     * const pedido_Productos = await prisma.pedido_Producto.findMany()
     * 
     * // Get first 10 Pedido_Productos
     * const pedido_Productos = await prisma.pedido_Producto.findMany({ take: 10 })
     * 
     * // Only select the `idPedido`
     * const pedido_ProductoWithIdPedidoOnly = await prisma.pedido_Producto.findMany({ select: { idPedido: true } })
     * 
    **/
    findMany<T extends Pedido_ProductoFindManyArgs>(
      args?: SelectSubset<T, Pedido_ProductoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Pedido_Producto>>, PrismaPromise<Array<Pedido_ProductoGetPayload<T>>>>

    /**
     * Create a Pedido_Producto.
     * @param {Pedido_ProductoCreateArgs} args - Arguments to create a Pedido_Producto.
     * @example
     * // Create one Pedido_Producto
     * const Pedido_Producto = await prisma.pedido_Producto.create({
     *   data: {
     *     // ... data to create a Pedido_Producto
     *   }
     * })
     * 
    **/
    create<T extends Pedido_ProductoCreateArgs>(
      args: SelectSubset<T, Pedido_ProductoCreateArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Create many Pedido_Productos.
     *     @param {Pedido_ProductoCreateManyArgs} args - Arguments to create many Pedido_Productos.
     *     @example
     *     // Create many Pedido_Productos
     *     const pedido_Producto = await prisma.pedido_Producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Pedido_ProductoCreateManyArgs>(
      args?: SelectSubset<T, Pedido_ProductoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido_Producto.
     * @param {Pedido_ProductoDeleteArgs} args - Arguments to delete one Pedido_Producto.
     * @example
     * // Delete one Pedido_Producto
     * const Pedido_Producto = await prisma.pedido_Producto.delete({
     *   where: {
     *     // ... filter to delete one Pedido_Producto
     *   }
     * })
     * 
    **/
    delete<T extends Pedido_ProductoDeleteArgs>(
      args: SelectSubset<T, Pedido_ProductoDeleteArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Update one Pedido_Producto.
     * @param {Pedido_ProductoUpdateArgs} args - Arguments to update one Pedido_Producto.
     * @example
     * // Update one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Pedido_ProductoUpdateArgs>(
      args: SelectSubset<T, Pedido_ProductoUpdateArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Delete zero or more Pedido_Productos.
     * @param {Pedido_ProductoDeleteManyArgs} args - Arguments to filter Pedido_Productos to delete.
     * @example
     * // Delete a few Pedido_Productos
     * const { count } = await prisma.pedido_Producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Pedido_ProductoDeleteManyArgs>(
      args?: SelectSubset<T, Pedido_ProductoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedido_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedido_Productos
     * const pedido_Producto = await prisma.pedido_Producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Pedido_ProductoUpdateManyArgs>(
      args: SelectSubset<T, Pedido_ProductoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido_Producto.
     * @param {Pedido_ProductoUpsertArgs} args - Arguments to update or create a Pedido_Producto.
     * @example
     * // Update or create a Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.upsert({
     *   create: {
     *     // ... data to create a Pedido_Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido_Producto we want to update
     *   }
     * })
    **/
    upsert<T extends Pedido_ProductoUpsertArgs>(
      args: SelectSubset<T, Pedido_ProductoUpsertArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Find one Pedido_Producto that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Pedido_ProductoFindUniqueOrThrowArgs} args - Arguments to find a Pedido_Producto
     * @example
     * // Get one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Pedido_ProductoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Pedido_ProductoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Find the first Pedido_Producto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoFindFirstOrThrowArgs} args - Arguments to find a Pedido_Producto
     * @example
     * // Get one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Pedido_ProductoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Pedido_ProductoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Count the number of Pedido_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoCountArgs} args - Arguments to filter Pedido_Productos to count.
     * @example
     * // Count the number of Pedido_Productos
     * const count = await prisma.pedido_Producto.count({
     *   where: {
     *     // ... the filter for the Pedido_Productos we want to count
     *   }
     * })
    **/
    count<T extends Pedido_ProductoCountArgs>(
      args?: Subset<T, Pedido_ProductoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pedido_ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pedido_ProductoAggregateArgs>(args: Subset<T, Pedido_ProductoAggregateArgs>): PrismaPromise<GetPedido_ProductoAggregateType<T>>

    /**
     * Group by Pedido_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pedido_ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pedido_ProductoGroupByArgs['orderBy'] }
        : { orderBy?: Pedido_ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pedido_ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedido_ProductoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido_Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Pedido_ProductoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Pedido<T extends PedidoArgs = {}>(args?: Subset<T, PedidoArgs>): CheckSelect<T, Prisma__PedidoClient<Pedido | null >, Prisma__PedidoClient<PedidoGetPayload<T> | null >>;

    Producto<T extends ProductoArgs = {}>(args?: Subset<T, ProductoArgs>): CheckSelect<T, Prisma__ProductoClient<Producto | null >, Prisma__ProductoClient<ProductoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pedido_Producto base type for findUnique actions
   */
  export type Pedido_ProductoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * Filter, which Pedido_Producto to fetch.
     * 
    **/
    where: Pedido_ProductoWhereUniqueInput
  }

  /**
   * Pedido_Producto: findUnique
   */
  export interface Pedido_ProductoFindUniqueArgs extends Pedido_ProductoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido_Producto base type for findFirst actions
   */
  export type Pedido_ProductoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * Filter, which Pedido_Producto to fetch.
     * 
    **/
    where?: Pedido_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedido_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Pedido_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedido_Productos.
     * 
    **/
    cursor?: Pedido_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedido_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedido_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedido_Productos.
     * 
    **/
    distinct?: Enumerable<Pedido_ProductoScalarFieldEnum>
  }

  /**
   * Pedido_Producto: findFirst
   */
  export interface Pedido_ProductoFindFirstArgs extends Pedido_ProductoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido_Producto findMany
   */
  export type Pedido_ProductoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * Filter, which Pedido_Productos to fetch.
     * 
    **/
    where?: Pedido_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedido_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Pedido_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedido_Productos.
     * 
    **/
    cursor?: Pedido_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedido_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedido_Productos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Pedido_ProductoScalarFieldEnum>
  }


  /**
   * Pedido_Producto create
   */
  export type Pedido_ProductoCreateArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * The data needed to create a Pedido_Producto.
     * 
    **/
    data: XOR<Pedido_ProductoCreateInput, Pedido_ProductoUncheckedCreateInput>
  }


  /**
   * Pedido_Producto createMany
   */
  export type Pedido_ProductoCreateManyArgs = {
    /**
     * The data used to create many Pedido_Productos.
     * 
    **/
    data: Enumerable<Pedido_ProductoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pedido_Producto update
   */
  export type Pedido_ProductoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * The data needed to update a Pedido_Producto.
     * 
    **/
    data: XOR<Pedido_ProductoUpdateInput, Pedido_ProductoUncheckedUpdateInput>
    /**
     * Choose, which Pedido_Producto to update.
     * 
    **/
    where: Pedido_ProductoWhereUniqueInput
  }


  /**
   * Pedido_Producto updateMany
   */
  export type Pedido_ProductoUpdateManyArgs = {
    /**
     * The data used to update Pedido_Productos.
     * 
    **/
    data: XOR<Pedido_ProductoUpdateManyMutationInput, Pedido_ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Pedido_Productos to update
     * 
    **/
    where?: Pedido_ProductoWhereInput
  }


  /**
   * Pedido_Producto upsert
   */
  export type Pedido_ProductoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * The filter to search for the Pedido_Producto to update in case it exists.
     * 
    **/
    where: Pedido_ProductoWhereUniqueInput
    /**
     * In case the Pedido_Producto found by the `where` argument doesn't exist, create a new Pedido_Producto with this data.
     * 
    **/
    create: XOR<Pedido_ProductoCreateInput, Pedido_ProductoUncheckedCreateInput>
    /**
     * In case the Pedido_Producto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Pedido_ProductoUpdateInput, Pedido_ProductoUncheckedUpdateInput>
  }


  /**
   * Pedido_Producto delete
   */
  export type Pedido_ProductoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * Filter which Pedido_Producto to delete.
     * 
    **/
    where: Pedido_ProductoWhereUniqueInput
  }


  /**
   * Pedido_Producto deleteMany
   */
  export type Pedido_ProductoDeleteManyArgs = {
    /**
     * Filter which Pedido_Productos to delete
     * 
    **/
    where?: Pedido_ProductoWhereInput
  }


  /**
   * Pedido_Producto: findUniqueOrThrow
   */
  export type Pedido_ProductoFindUniqueOrThrowArgs = Pedido_ProductoFindUniqueArgsBase
      

  /**
   * Pedido_Producto: findFirstOrThrow
   */
  export type Pedido_ProductoFindFirstOrThrowArgs = Pedido_ProductoFindFirstArgsBase
      

  /**
   * Pedido_Producto without action
   */
  export type Pedido_ProductoArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Categoria_ProductoScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type Categoria_ProductoScalarFieldEnum = (typeof Categoria_ProductoScalarFieldEnum)[keyof typeof Categoria_ProductoScalarFieldEnum]


  export const EstadoMesaScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type EstadoMesaScalarFieldEnum = (typeof EstadoMesaScalarFieldEnum)[keyof typeof EstadoMesaScalarFieldEnum]


  export const Factura_DetalleScalarFieldEnum: {
    id: 'id',
    cantidad: 'cantidad',
    precio: 'precio',
    impuesto: 'impuesto',
    total_detalle: 'total_detalle',
    idFactura_Encabezado: 'idFactura_Encabezado',
    idProducto: 'idProducto'
  };

  export type Factura_DetalleScalarFieldEnum = (typeof Factura_DetalleScalarFieldEnum)[keyof typeof Factura_DetalleScalarFieldEnum]


  export const Factura_EncabezadoScalarFieldEnum: {
    id: 'id',
    numero_tarjeta: 'numero_tarjeta',
    tarjeta: 'tarjeta',
    fecha: 'fecha',
    estado: 'estado',
    idUsuario: 'idUsuario',
    idTipoPago: 'idTipoPago'
  };

  export type Factura_EncabezadoScalarFieldEnum = (typeof Factura_EncabezadoScalarFieldEnum)[keyof typeof Factura_EncabezadoScalarFieldEnum]


  export const MesaScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    capacidad: 'capacidad',
    disponibilidad: 'disponibilidad',
    estado: 'estado',
    idSucursal: 'idSucursal',
    idEstadoMesa: 'idEstadoMesa'
  };

  export type MesaScalarFieldEnum = (typeof MesaScalarFieldEnum)[keyof typeof MesaScalarFieldEnum]


  export const MeseroOnSucursalScalarFieldEnum: {
    idSucursal: 'idSucursal',
    idMesero: 'idMesero'
  };

  export type MeseroOnSucursalScalarFieldEnum = (typeof MeseroOnSucursalScalarFieldEnum)[keyof typeof MeseroOnSucursalScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    precio: 'precio',
    idUsuario: 'idUsuario'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const Pedido_ProductoScalarFieldEnum: {
    idPedido: 'idPedido',
    idProducto: 'idProducto',
    cantidad: 'cantidad',
    notas: 'notas'
  };

  export type Pedido_ProductoScalarFieldEnum = (typeof Pedido_ProductoScalarFieldEnum)[keyof typeof Pedido_ProductoScalarFieldEnum]


  export const PerfilScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type PerfilScalarFieldEnum = (typeof PerfilScalarFieldEnum)[keyof typeof PerfilScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    ingredientes: 'ingredientes',
    precio: 'precio',
    imagen: 'imagen',
    estado: 'estado',
    idCategoria: 'idCategoria'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const ReservacionScalarFieldEnum: {
    id: 'id',
    fecha_hora: 'fecha_hora',
    idSucursal: 'idSucursal',
    idUsuario: 'idUsuario'
  };

  export type ReservacionScalarFieldEnum = (typeof ReservacionScalarFieldEnum)[keyof typeof ReservacionScalarFieldEnum]


  export const Reservacion_MesaScalarFieldEnum: {
    idMesa: 'idMesa',
    idReservacion: 'idReservacion',
    cantidad: 'cantidad'
  };

  export type Reservacion_MesaScalarFieldEnum = (typeof Reservacion_MesaScalarFieldEnum)[keyof typeof Reservacion_MesaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SucursalScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nombre: 'nombre',
    ubicacion: 'ubicacion',
    capacidad: 'capacidad'
  };

  export type SucursalScalarFieldEnum = (typeof SucursalScalarFieldEnum)[keyof typeof SucursalScalarFieldEnum]


  export const Sucursal_ProductoScalarFieldEnum: {
    idProducto: 'idProducto',
    idSucursal: 'idSucursal'
  };

  export type Sucursal_ProductoScalarFieldEnum = (typeof Sucursal_ProductoScalarFieldEnum)[keyof typeof Sucursal_ProductoScalarFieldEnum]


  export const TipoPagoScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type TipoPagoScalarFieldEnum = (typeof TipoPagoScalarFieldEnum)[keyof typeof TipoPagoScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido1: 'apellido1',
    apellido2: 'apellido2',
    correo: 'correo',
    username: 'username',
    clave: 'clave',
    telefono: 'telefono',
    direccion: 'direccion',
    idPerfil: 'idPerfil'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type PerfilWhereInput = {
    AND?: Enumerable<PerfilWhereInput>
    OR?: Enumerable<PerfilWhereInput>
    NOT?: Enumerable<PerfilWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    usuarios?: UsuarioListRelationFilter
  }

  export type PerfilOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarios?: UsuarioOrderByRelationAggregateInput
  }

  export type PerfilWhereUniqueInput = {
    id?: number
  }

  export type PerfilOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: PerfilCountOrderByAggregateInput
    _avg?: PerfilAvgOrderByAggregateInput
    _max?: PerfilMaxOrderByAggregateInput
    _min?: PerfilMinOrderByAggregateInput
    _sum?: PerfilSumOrderByAggregateInput
  }

  export type PerfilScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PerfilScalarWhereWithAggregatesInput>
    OR?: Enumerable<PerfilScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PerfilScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type UsuarioWhereInput = {
    AND?: Enumerable<UsuarioWhereInput>
    OR?: Enumerable<UsuarioWhereInput>
    NOT?: Enumerable<UsuarioWhereInput>
    id?: StringFilter | string
    nombre?: StringFilter | string
    apellido1?: StringFilter | string
    apellido2?: StringFilter | string
    correo?: StringFilter | string
    username?: StringFilter | string
    clave?: StringFilter | string
    telefono?: StringFilter | string
    direccion?: StringNullableFilter | string | null
    reservaciones?: ReservacionListRelationFilter
    facturas?: Factura_EncabezadoListRelationFilter
    pedidos?: PedidoListRelationFilter
    Perfil?: XOR<PerfilRelationFilter, PerfilWhereInput>
    idPerfil?: IntFilter | number
    MeseroOnSucursal?: MeseroOnSucursalListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    reservaciones?: ReservacionOrderByRelationAggregateInput
    facturas?: Factura_EncabezadoOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
    Perfil?: PerfilOrderByWithRelationInput
    idPerfil?: SortOrder
    MeseroOnSucursal?: MeseroOnSucursalOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = {
    id?: string
    correo_username_telefono?: UsuarioCorreoUsernameTelefonoCompoundUniqueInput
  }

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    idPerfil?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nombre?: StringWithAggregatesFilter | string
    apellido1?: StringWithAggregatesFilter | string
    apellido2?: StringWithAggregatesFilter | string
    correo?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    clave?: StringWithAggregatesFilter | string
    telefono?: StringWithAggregatesFilter | string
    direccion?: StringNullableWithAggregatesFilter | string | null
    idPerfil?: IntWithAggregatesFilter | number
  }

  export type MeseroOnSucursalWhereInput = {
    AND?: Enumerable<MeseroOnSucursalWhereInput>
    OR?: Enumerable<MeseroOnSucursalWhereInput>
    NOT?: Enumerable<MeseroOnSucursalWhereInput>
    Sucursal?: XOR<SucursalRelationFilter, SucursalWhereInput>
    idSucursal?: BigIntFilter | bigint | number
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    idMesero?: StringFilter | string
  }

  export type MeseroOnSucursalOrderByWithRelationInput = {
    Sucursal?: SucursalOrderByWithRelationInput
    idSucursal?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
    idMesero?: SortOrder
  }

  export type MeseroOnSucursalWhereUniqueInput = {
    idSucursal_idMesero?: MeseroOnSucursalIdSucursalIdMeseroCompoundUniqueInput
  }

  export type MeseroOnSucursalOrderByWithAggregationInput = {
    idSucursal?: SortOrder
    idMesero?: SortOrder
    _count?: MeseroOnSucursalCountOrderByAggregateInput
    _avg?: MeseroOnSucursalAvgOrderByAggregateInput
    _max?: MeseroOnSucursalMaxOrderByAggregateInput
    _min?: MeseroOnSucursalMinOrderByAggregateInput
    _sum?: MeseroOnSucursalSumOrderByAggregateInput
  }

  export type MeseroOnSucursalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MeseroOnSucursalScalarWhereWithAggregatesInput>
    OR?: Enumerable<MeseroOnSucursalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MeseroOnSucursalScalarWhereWithAggregatesInput>
    idSucursal?: BigIntWithAggregatesFilter | bigint | number
    idMesero?: StringWithAggregatesFilter | string
  }

  export type SucursalWhereInput = {
    AND?: Enumerable<SucursalWhereInput>
    OR?: Enumerable<SucursalWhereInput>
    NOT?: Enumerable<SucursalWhereInput>
    id?: BigIntFilter | bigint | number
    codigo?: StringFilter | string
    nombre?: StringFilter | string
    ubicacion?: StringFilter | string
    capacidad?: BigIntFilter | bigint | number
    mesas?: MesaListRelationFilter
    reservaciones?: ReservacionListRelationFilter
    productos?: Sucursal_ProductoListRelationFilter
    MeseroOnSucursal?: MeseroOnSucursalListRelationFilter
  }

  export type SucursalOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
    mesas?: MesaOrderByRelationAggregateInput
    reservaciones?: ReservacionOrderByRelationAggregateInput
    productos?: Sucursal_ProductoOrderByRelationAggregateInput
    MeseroOnSucursal?: MeseroOnSucursalOrderByRelationAggregateInput
  }

  export type SucursalWhereUniqueInput = {
    id?: bigint | number
    codigo_nombre?: SucursalCodigoNombreCompoundUniqueInput
  }

  export type SucursalOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
    _count?: SucursalCountOrderByAggregateInput
    _avg?: SucursalAvgOrderByAggregateInput
    _max?: SucursalMaxOrderByAggregateInput
    _min?: SucursalMinOrderByAggregateInput
    _sum?: SucursalSumOrderByAggregateInput
  }

  export type SucursalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SucursalScalarWhereWithAggregatesInput>
    OR?: Enumerable<SucursalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SucursalScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    codigo?: StringWithAggregatesFilter | string
    nombre?: StringWithAggregatesFilter | string
    ubicacion?: StringWithAggregatesFilter | string
    capacidad?: BigIntWithAggregatesFilter | bigint | number
  }

  export type MesaWhereInput = {
    AND?: Enumerable<MesaWhereInput>
    OR?: Enumerable<MesaWhereInput>
    NOT?: Enumerable<MesaWhereInput>
    id?: BigIntFilter | bigint | number
    codigo?: StringFilter | string
    capacidad?: IntFilter | number
    disponibilidad?: IntFilter | number
    estado?: BoolFilter | boolean
    reservaciones?: Reservacion_MesaListRelationFilter
    Sucursal?: XOR<SucursalRelationFilter, SucursalWhereInput>
    idSucursal?: BigIntFilter | bigint | number
    EstadoMesa?: XOR<EstadoMesaRelationFilter, EstadoMesaWhereInput>
    idEstadoMesa?: IntFilter | number
  }

  export type MesaOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    reservaciones?: Reservacion_MesaOrderByRelationAggregateInput
    Sucursal?: SucursalOrderByWithRelationInput
    idSucursal?: SortOrder
    EstadoMesa?: EstadoMesaOrderByWithRelationInput
    idEstadoMesa?: SortOrder
  }

  export type MesaWhereUniqueInput = {
    id?: bigint | number
    codigo?: string
  }

  export type MesaOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    idSucursal?: SortOrder
    idEstadoMesa?: SortOrder
    _count?: MesaCountOrderByAggregateInput
    _avg?: MesaAvgOrderByAggregateInput
    _max?: MesaMaxOrderByAggregateInput
    _min?: MesaMinOrderByAggregateInput
    _sum?: MesaSumOrderByAggregateInput
  }

  export type MesaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MesaScalarWhereWithAggregatesInput>
    OR?: Enumerable<MesaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MesaScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    codigo?: StringWithAggregatesFilter | string
    capacidad?: IntWithAggregatesFilter | number
    disponibilidad?: IntWithAggregatesFilter | number
    estado?: BoolWithAggregatesFilter | boolean
    idSucursal?: BigIntWithAggregatesFilter | bigint | number
    idEstadoMesa?: IntWithAggregatesFilter | number
  }

  export type EstadoMesaWhereInput = {
    AND?: Enumerable<EstadoMesaWhereInput>
    OR?: Enumerable<EstadoMesaWhereInput>
    NOT?: Enumerable<EstadoMesaWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    mesas?: MesaListRelationFilter
  }

  export type EstadoMesaOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    mesas?: MesaOrderByRelationAggregateInput
  }

  export type EstadoMesaWhereUniqueInput = {
    id?: number
  }

  export type EstadoMesaOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: EstadoMesaCountOrderByAggregateInput
    _avg?: EstadoMesaAvgOrderByAggregateInput
    _max?: EstadoMesaMaxOrderByAggregateInput
    _min?: EstadoMesaMinOrderByAggregateInput
    _sum?: EstadoMesaSumOrderByAggregateInput
  }

  export type EstadoMesaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EstadoMesaScalarWhereWithAggregatesInput>
    OR?: Enumerable<EstadoMesaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EstadoMesaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type ReservacionWhereInput = {
    AND?: Enumerable<ReservacionWhereInput>
    OR?: Enumerable<ReservacionWhereInput>
    NOT?: Enumerable<ReservacionWhereInput>
    id?: BigIntFilter | bigint | number
    fecha_hora?: DateTimeFilter | Date | string
    mesas?: Reservacion_MesaListRelationFilter
    Sucursal?: XOR<SucursalRelationFilter, SucursalWhereInput>
    idSucursal?: BigIntFilter | bigint | number
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    idUsuario?: StringFilter | string
  }

  export type ReservacionOrderByWithRelationInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    mesas?: Reservacion_MesaOrderByRelationAggregateInput
    Sucursal?: SucursalOrderByWithRelationInput
    idSucursal?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
    idUsuario?: SortOrder
  }

  export type ReservacionWhereUniqueInput = {
    id?: bigint | number
  }

  export type ReservacionOrderByWithAggregationInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    idSucursal?: SortOrder
    idUsuario?: SortOrder
    _count?: ReservacionCountOrderByAggregateInput
    _avg?: ReservacionAvgOrderByAggregateInput
    _max?: ReservacionMaxOrderByAggregateInput
    _min?: ReservacionMinOrderByAggregateInput
    _sum?: ReservacionSumOrderByAggregateInput
  }

  export type ReservacionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReservacionScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReservacionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReservacionScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    fecha_hora?: DateTimeWithAggregatesFilter | Date | string
    idSucursal?: BigIntWithAggregatesFilter | bigint | number
    idUsuario?: StringWithAggregatesFilter | string
  }

  export type Reservacion_MesaWhereInput = {
    AND?: Enumerable<Reservacion_MesaWhereInput>
    OR?: Enumerable<Reservacion_MesaWhereInput>
    NOT?: Enumerable<Reservacion_MesaWhereInput>
    Mesa?: XOR<MesaRelationFilter, MesaWhereInput>
    idMesa?: BigIntFilter | bigint | number
    Reservacion?: XOR<ReservacionRelationFilter, ReservacionWhereInput>
    idReservacion?: BigIntFilter | bigint | number
    cantidad?: IntFilter | number
  }

  export type Reservacion_MesaOrderByWithRelationInput = {
    Mesa?: MesaOrderByWithRelationInput
    idMesa?: SortOrder
    Reservacion?: ReservacionOrderByWithRelationInput
    idReservacion?: SortOrder
    cantidad?: SortOrder
  }

  export type Reservacion_MesaWhereUniqueInput = {
    idMesa_idReservacion?: Reservacion_MesaIdMesaIdReservacionCompoundUniqueInput
  }

  export type Reservacion_MesaOrderByWithAggregationInput = {
    idMesa?: SortOrder
    idReservacion?: SortOrder
    cantidad?: SortOrder
    _count?: Reservacion_MesaCountOrderByAggregateInput
    _avg?: Reservacion_MesaAvgOrderByAggregateInput
    _max?: Reservacion_MesaMaxOrderByAggregateInput
    _min?: Reservacion_MesaMinOrderByAggregateInput
    _sum?: Reservacion_MesaSumOrderByAggregateInput
  }

  export type Reservacion_MesaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Reservacion_MesaScalarWhereWithAggregatesInput>
    OR?: Enumerable<Reservacion_MesaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Reservacion_MesaScalarWhereWithAggregatesInput>
    idMesa?: BigIntWithAggregatesFilter | bigint | number
    idReservacion?: BigIntWithAggregatesFilter | bigint | number
    cantidad?: IntWithAggregatesFilter | number
  }

  export type Categoria_ProductoWhereInput = {
    AND?: Enumerable<Categoria_ProductoWhereInput>
    OR?: Enumerable<Categoria_ProductoWhereInput>
    NOT?: Enumerable<Categoria_ProductoWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    productos?: ProductoListRelationFilter
  }

  export type Categoria_ProductoOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    productos?: ProductoOrderByRelationAggregateInput
  }

  export type Categoria_ProductoWhereUniqueInput = {
    id?: number
    descripcion?: string
  }

  export type Categoria_ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: Categoria_ProductoCountOrderByAggregateInput
    _avg?: Categoria_ProductoAvgOrderByAggregateInput
    _max?: Categoria_ProductoMaxOrderByAggregateInput
    _min?: Categoria_ProductoMinOrderByAggregateInput
    _sum?: Categoria_ProductoSumOrderByAggregateInput
  }

  export type Categoria_ProductoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Categoria_ProductoScalarWhereWithAggregatesInput>
    OR?: Enumerable<Categoria_ProductoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Categoria_ProductoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type ProductoWhereInput = {
    AND?: Enumerable<ProductoWhereInput>
    OR?: Enumerable<ProductoWhereInput>
    NOT?: Enumerable<ProductoWhereInput>
    id?: BigIntFilter | bigint | number
    nombre?: StringFilter | string
    descripcion?: StringFilter | string
    ingredientes?: StringNullableFilter | string | null
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    imagen?: StringFilter | string
    estado?: IntFilter | number
    Categoria_Producto?: XOR<Categoria_ProductoRelationFilter, Categoria_ProductoWhereInput>
    idCategoria?: IntFilter | number
    detalles?: Factura_DetalleListRelationFilter
    pedidos?: Pedido_ProductoListRelationFilter
    sucursales?: Sucursal_ProductoListRelationFilter
  }

  export type ProductoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    Categoria_Producto?: Categoria_ProductoOrderByWithRelationInput
    idCategoria?: SortOrder
    detalles?: Factura_DetalleOrderByRelationAggregateInput
    pedidos?: Pedido_ProductoOrderByRelationAggregateInput
    sucursales?: Sucursal_ProductoOrderByRelationAggregateInput
  }

  export type ProductoWhereUniqueInput = {
    id?: bigint | number
  }

  export type ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
    _count?: ProductoCountOrderByAggregateInput
    _avg?: ProductoAvgOrderByAggregateInput
    _max?: ProductoMaxOrderByAggregateInput
    _min?: ProductoMinOrderByAggregateInput
    _sum?: ProductoSumOrderByAggregateInput
  }

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductoScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductoScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    nombre?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
    ingredientes?: StringNullableWithAggregatesFilter | string | null
    precio?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    imagen?: StringWithAggregatesFilter | string
    estado?: IntWithAggregatesFilter | number
    idCategoria?: IntWithAggregatesFilter | number
  }

  export type Sucursal_ProductoWhereInput = {
    AND?: Enumerable<Sucursal_ProductoWhereInput>
    OR?: Enumerable<Sucursal_ProductoWhereInput>
    NOT?: Enumerable<Sucursal_ProductoWhereInput>
    Producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    idProducto?: BigIntFilter | bigint | number
    Sucursal?: XOR<SucursalRelationFilter, SucursalWhereInput>
    idSucursal?: BigIntFilter | bigint | number
  }

  export type Sucursal_ProductoOrderByWithRelationInput = {
    Producto?: ProductoOrderByWithRelationInput
    idProducto?: SortOrder
    Sucursal?: SucursalOrderByWithRelationInput
    idSucursal?: SortOrder
  }

  export type Sucursal_ProductoWhereUniqueInput = {
    idProducto_idSucursal?: Sucursal_ProductoIdProductoIdSucursalCompoundUniqueInput
  }

  export type Sucursal_ProductoOrderByWithAggregationInput = {
    idProducto?: SortOrder
    idSucursal?: SortOrder
    _count?: Sucursal_ProductoCountOrderByAggregateInput
    _avg?: Sucursal_ProductoAvgOrderByAggregateInput
    _max?: Sucursal_ProductoMaxOrderByAggregateInput
    _min?: Sucursal_ProductoMinOrderByAggregateInput
    _sum?: Sucursal_ProductoSumOrderByAggregateInput
  }

  export type Sucursal_ProductoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Sucursal_ProductoScalarWhereWithAggregatesInput>
    OR?: Enumerable<Sucursal_ProductoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Sucursal_ProductoScalarWhereWithAggregatesInput>
    idProducto?: BigIntWithAggregatesFilter | bigint | number
    idSucursal?: BigIntWithAggregatesFilter | bigint | number
  }

  export type TipoPagoWhereInput = {
    AND?: Enumerable<TipoPagoWhereInput>
    OR?: Enumerable<TipoPagoWhereInput>
    NOT?: Enumerable<TipoPagoWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    facturas?: Factura_EncabezadoListRelationFilter
  }

  export type TipoPagoOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    facturas?: Factura_EncabezadoOrderByRelationAggregateInput
  }

  export type TipoPagoWhereUniqueInput = {
    id?: number
  }

  export type TipoPagoOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: TipoPagoCountOrderByAggregateInput
    _avg?: TipoPagoAvgOrderByAggregateInput
    _max?: TipoPagoMaxOrderByAggregateInput
    _min?: TipoPagoMinOrderByAggregateInput
    _sum?: TipoPagoSumOrderByAggregateInput
  }

  export type TipoPagoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TipoPagoScalarWhereWithAggregatesInput>
    OR?: Enumerable<TipoPagoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TipoPagoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type Factura_EncabezadoWhereInput = {
    AND?: Enumerable<Factura_EncabezadoWhereInput>
    OR?: Enumerable<Factura_EncabezadoWhereInput>
    NOT?: Enumerable<Factura_EncabezadoWhereInput>
    id?: BigIntFilter | bigint | number
    numero_tarjeta?: StringNullableFilter | string | null
    tarjeta?: EnumTipoTarjetaNullableFilter | TipoTarjeta | null
    fecha?: DateTimeFilter | Date | string
    estado?: BoolFilter | boolean
    detalles?: Factura_DetalleListRelationFilter
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    idUsuario?: StringFilter | string
    TipoPago?: XOR<TipoPagoRelationFilter, TipoPagoWhereInput>
    idTipoPago?: IntFilter | number
  }

  export type Factura_EncabezadoOrderByWithRelationInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    tarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    detalles?: Factura_DetalleOrderByRelationAggregateInput
    Usuario?: UsuarioOrderByWithRelationInput
    idUsuario?: SortOrder
    TipoPago?: TipoPagoOrderByWithRelationInput
    idTipoPago?: SortOrder
  }

  export type Factura_EncabezadoWhereUniqueInput = {
    id?: bigint | number
  }

  export type Factura_EncabezadoOrderByWithAggregationInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    tarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    idUsuario?: SortOrder
    idTipoPago?: SortOrder
    _count?: Factura_EncabezadoCountOrderByAggregateInput
    _avg?: Factura_EncabezadoAvgOrderByAggregateInput
    _max?: Factura_EncabezadoMaxOrderByAggregateInput
    _min?: Factura_EncabezadoMinOrderByAggregateInput
    _sum?: Factura_EncabezadoSumOrderByAggregateInput
  }

  export type Factura_EncabezadoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Factura_EncabezadoScalarWhereWithAggregatesInput>
    OR?: Enumerable<Factura_EncabezadoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Factura_EncabezadoScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    numero_tarjeta?: StringNullableWithAggregatesFilter | string | null
    tarjeta?: EnumTipoTarjetaNullableWithAggregatesFilter | TipoTarjeta | null
    fecha?: DateTimeWithAggregatesFilter | Date | string
    estado?: BoolWithAggregatesFilter | boolean
    idUsuario?: StringWithAggregatesFilter | string
    idTipoPago?: IntWithAggregatesFilter | number
  }

  export type Factura_DetalleWhereInput = {
    AND?: Enumerable<Factura_DetalleWhereInput>
    OR?: Enumerable<Factura_DetalleWhereInput>
    NOT?: Enumerable<Factura_DetalleWhereInput>
    id?: BigIntFilter | bigint | number
    cantidad?: IntFilter | number
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFilter | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFilter | Decimal | DecimalJsLike | number | string
    Factura_Encabezado?: XOR<Factura_EncabezadoRelationFilter, Factura_EncabezadoWhereInput>
    idFactura_Encabezado?: BigIntFilter | bigint | number
    Producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    idProducto?: BigIntFilter | bigint | number
  }

  export type Factura_DetalleOrderByWithRelationInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    Factura_Encabezado?: Factura_EncabezadoOrderByWithRelationInput
    idFactura_Encabezado?: SortOrder
    Producto?: ProductoOrderByWithRelationInput
    idProducto?: SortOrder
  }

  export type Factura_DetalleWhereUniqueInput = {
    id_idFactura_Encabezado?: Factura_DetalleIdIdFactura_EncabezadoCompoundUniqueInput
  }

  export type Factura_DetalleOrderByWithAggregationInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
    _count?: Factura_DetalleCountOrderByAggregateInput
    _avg?: Factura_DetalleAvgOrderByAggregateInput
    _max?: Factura_DetalleMaxOrderByAggregateInput
    _min?: Factura_DetalleMinOrderByAggregateInput
    _sum?: Factura_DetalleSumOrderByAggregateInput
  }

  export type Factura_DetalleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Factura_DetalleScalarWhereWithAggregatesInput>
    OR?: Enumerable<Factura_DetalleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Factura_DetalleScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    cantidad?: IntWithAggregatesFilter | number
    precio?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: BigIntWithAggregatesFilter | bigint | number
    idProducto?: BigIntWithAggregatesFilter | bigint | number
  }

  export type PedidoWhereInput = {
    AND?: Enumerable<PedidoWhereInput>
    OR?: Enumerable<PedidoWhereInput>
    NOT?: Enumerable<PedidoWhereInput>
    id?: BigIntFilter | bigint | number
    nombre?: StringNullableFilter | string | null
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    productos?: Pedido_ProductoListRelationFilter
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    idUsuario?: StringFilter | string
  }

  export type PedidoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    productos?: Pedido_ProductoOrderByRelationAggregateInput
    Usuario?: UsuarioOrderByWithRelationInput
    idUsuario?: SortOrder
  }

  export type PedidoWhereUniqueInput = {
    id?: bigint | number
  }

  export type PedidoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    idUsuario?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    precio?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    idUsuario?: StringWithAggregatesFilter | string
  }

  export type Pedido_ProductoWhereInput = {
    AND?: Enumerable<Pedido_ProductoWhereInput>
    OR?: Enumerable<Pedido_ProductoWhereInput>
    NOT?: Enumerable<Pedido_ProductoWhereInput>
    Pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    idPedido?: BigIntFilter | bigint | number
    Producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    idProducto?: BigIntFilter | bigint | number
    cantidad?: IntFilter | number
    notas?: StringFilter | string
  }

  export type Pedido_ProductoOrderByWithRelationInput = {
    Pedido?: PedidoOrderByWithRelationInput
    idPedido?: SortOrder
    Producto?: ProductoOrderByWithRelationInput
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
  }

  export type Pedido_ProductoWhereUniqueInput = {
    idPedido_idProducto?: Pedido_ProductoIdPedidoIdProductoCompoundUniqueInput
  }

  export type Pedido_ProductoOrderByWithAggregationInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
    _count?: Pedido_ProductoCountOrderByAggregateInput
    _avg?: Pedido_ProductoAvgOrderByAggregateInput
    _max?: Pedido_ProductoMaxOrderByAggregateInput
    _min?: Pedido_ProductoMinOrderByAggregateInput
    _sum?: Pedido_ProductoSumOrderByAggregateInput
  }

  export type Pedido_ProductoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Pedido_ProductoScalarWhereWithAggregatesInput>
    OR?: Enumerable<Pedido_ProductoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Pedido_ProductoScalarWhereWithAggregatesInput>
    idPedido?: BigIntWithAggregatesFilter | bigint | number
    idProducto?: BigIntWithAggregatesFilter | bigint | number
    cantidad?: IntWithAggregatesFilter | number
    notas?: StringWithAggregatesFilter | string
  }

  export type PerfilCreateInput = {
    id: number
    descripcion: string
    usuarios?: UsuarioCreateNestedManyWithoutPerfilInput
  }

  export type PerfilUncheckedCreateInput = {
    id: number
    descripcion: string
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutPerfilInput
  }

  export type PerfilUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarios?: UsuarioUpdateManyWithoutPerfilNestedInput
  }

  export type PerfilUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarios?: UsuarioUncheckedUpdateManyWithoutPerfilNestedInput
  }

  export type PerfilCreateManyInput = {
    id: number
    descripcion: string
  }

  export type PerfilUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PerfilUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
    MeseroOnSucursal?: MeseroOnSucursalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    idPerfil: number
    MeseroOnSucursal?: MeseroOnSucursalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
    MeseroOnSucursal?: MeseroOnSucursalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    idPerfil: number
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    idPerfil?: IntFieldUpdateOperationsInput | number
  }

  export type MeseroOnSucursalCreateInput = {
    Sucursal: SucursalCreateNestedOneWithoutMeseroOnSucursalInput
    Usuario: UsuarioCreateNestedOneWithoutMeseroOnSucursalInput
  }

  export type MeseroOnSucursalUncheckedCreateInput = {
    idSucursal: bigint | number
    idMesero: string
  }

  export type MeseroOnSucursalUpdateInput = {
    Sucursal?: SucursalUpdateOneRequiredWithoutMeseroOnSucursalNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutMeseroOnSucursalNestedInput
  }

  export type MeseroOnSucursalUncheckedUpdateInput = {
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
    idMesero?: StringFieldUpdateOperationsInput | string
  }

  export type MeseroOnSucursalCreateManyInput = {
    idSucursal: bigint | number
    idMesero: string
  }

  export type MeseroOnSucursalUpdateManyMutationInput = {

  }

  export type MeseroOnSucursalUncheckedUpdateManyInput = {
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
    idMesero?: StringFieldUpdateOperationsInput | string
  }

  export type SucursalCreateInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    mesas?: MesaCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionCreateNestedManyWithoutSucursalInput
    productos?: Sucursal_ProductoCreateNestedManyWithoutSucursalInput
    MeseroOnSucursal?: MeseroOnSucursalCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    mesas?: MesaUncheckedCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutSucursalInput
    productos?: Sucursal_ProductoUncheckedCreateNestedManyWithoutSucursalInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    mesas?: MesaUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUpdateManyWithoutSucursalNestedInput
    productos?: Sucursal_ProductoUpdateManyWithoutSucursalNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    mesas?: MesaUncheckedUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUncheckedUpdateManyWithoutSucursalNestedInput
    productos?: Sucursal_ProductoUncheckedUpdateManyWithoutSucursalNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalCreateManyInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
  }

  export type SucursalUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type SucursalUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MesaCreateInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    reservaciones?: Reservacion_MesaCreateNestedManyWithoutMesaInput
    Sucursal: SucursalCreateNestedOneWithoutMesasInput
    EstadoMesa: EstadoMesaCreateNestedOneWithoutMesasInput
  }

  export type MesaUncheckedCreateInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    reservaciones?: Reservacion_MesaUncheckedCreateNestedManyWithoutMesaInput
    idSucursal: bigint | number
    idEstadoMesa: number
  }

  export type MesaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: Reservacion_MesaUpdateManyWithoutMesaNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutMesasNestedInput
    EstadoMesa?: EstadoMesaUpdateOneRequiredWithoutMesasNestedInput
  }

  export type MesaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: Reservacion_MesaUncheckedUpdateManyWithoutMesaNestedInput
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
    idEstadoMesa?: IntFieldUpdateOperationsInput | number
  }

  export type MesaCreateManyInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    idSucursal: bigint | number
    idEstadoMesa: number
  }

  export type MesaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MesaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
    idEstadoMesa?: IntFieldUpdateOperationsInput | number
  }

  export type EstadoMesaCreateInput = {
    id: number
    descripcion: string
    mesas?: MesaCreateNestedManyWithoutEstadoMesaInput
  }

  export type EstadoMesaUncheckedCreateInput = {
    id: number
    descripcion: string
    mesas?: MesaUncheckedCreateNestedManyWithoutEstadoMesaInput
  }

  export type EstadoMesaUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    mesas?: MesaUpdateManyWithoutEstadoMesaNestedInput
  }

  export type EstadoMesaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    mesas?: MesaUncheckedUpdateManyWithoutEstadoMesaNestedInput
  }

  export type EstadoMesaCreateManyInput = {
    id: number
    descripcion: string
  }

  export type EstadoMesaUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoMesaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type ReservacionCreateInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    mesas?: Reservacion_MesaCreateNestedManyWithoutReservacionInput
    Sucursal: SucursalCreateNestedOneWithoutReservacionesInput
    Usuario: UsuarioCreateNestedOneWithoutReservacionesInput
  }

  export type ReservacionUncheckedCreateInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    mesas?: Reservacion_MesaUncheckedCreateNestedManyWithoutReservacionInput
    idSucursal: bigint | number
    idUsuario: string
  }

  export type ReservacionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    mesas?: Reservacion_MesaUpdateManyWithoutReservacionNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutReservacionesNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReservacionesNestedInput
  }

  export type ReservacionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    mesas?: Reservacion_MesaUncheckedUpdateManyWithoutReservacionNestedInput
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type ReservacionCreateManyInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    idSucursal: bigint | number
    idUsuario: string
  }

  export type ReservacionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservacionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type Reservacion_MesaCreateInput = {
    Mesa: MesaCreateNestedOneWithoutReservacionesInput
    Reservacion: ReservacionCreateNestedOneWithoutMesasInput
    cantidad: number
  }

  export type Reservacion_MesaUncheckedCreateInput = {
    idMesa: bigint | number
    idReservacion: bigint | number
    cantidad: number
  }

  export type Reservacion_MesaUpdateInput = {
    Mesa?: MesaUpdateOneRequiredWithoutReservacionesNestedInput
    Reservacion?: ReservacionUpdateOneRequiredWithoutMesasNestedInput
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type Reservacion_MesaUncheckedUpdateInput = {
    idMesa?: BigIntFieldUpdateOperationsInput | bigint | number
    idReservacion?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type Reservacion_MesaCreateManyInput = {
    idMesa: bigint | number
    idReservacion: bigint | number
    cantidad: number
  }

  export type Reservacion_MesaUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type Reservacion_MesaUncheckedUpdateManyInput = {
    idMesa?: BigIntFieldUpdateOperationsInput | bigint | number
    idReservacion?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type Categoria_ProductoCreateInput = {
    id: number
    descripcion: string
    productos?: ProductoCreateNestedManyWithoutCategoria_ProductoInput
  }

  export type Categoria_ProductoUncheckedCreateInput = {
    id: number
    descripcion: string
    productos?: ProductoUncheckedCreateNestedManyWithoutCategoria_ProductoInput
  }

  export type Categoria_ProductoUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUpdateManyWithoutCategoria_ProductoNestedInput
  }

  export type Categoria_ProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUncheckedUpdateManyWithoutCategoria_ProductoNestedInput
  }

  export type Categoria_ProductoCreateManyInput = {
    id: number
    descripcion: string
  }

  export type Categoria_ProductoUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Categoria_ProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoCreateInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    Categoria_Producto: Categoria_ProductoCreateNestedOneWithoutProductosInput
    detalles?: Factura_DetalleCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoCreateNestedManyWithoutProductoInput
    sucursales?: Sucursal_ProductoCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    idCategoria: number
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput
    sucursales?: Sucursal_ProductoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    Categoria_Producto?: Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput
    detalles?: Factura_DetalleUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUpdateManyWithoutProductoNestedInput
    sucursales?: Sucursal_ProductoUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    idCategoria?: IntFieldUpdateOperationsInput | number
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput
    sucursales?: Sucursal_ProductoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoCreateManyInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    idCategoria: number
  }

  export type ProductoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    idCategoria?: IntFieldUpdateOperationsInput | number
  }

  export type Sucursal_ProductoCreateInput = {
    Producto: ProductoCreateNestedOneWithoutSucursalesInput
    Sucursal: SucursalCreateNestedOneWithoutProductosInput
  }

  export type Sucursal_ProductoUncheckedCreateInput = {
    idProducto: bigint | number
    idSucursal: bigint | number
  }

  export type Sucursal_ProductoUpdateInput = {
    Producto?: ProductoUpdateOneRequiredWithoutSucursalesNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutProductosNestedInput
  }

  export type Sucursal_ProductoUncheckedUpdateInput = {
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Sucursal_ProductoCreateManyInput = {
    idProducto: bigint | number
    idSucursal: bigint | number
  }

  export type Sucursal_ProductoUpdateManyMutationInput = {

  }

  export type Sucursal_ProductoUncheckedUpdateManyInput = {
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TipoPagoCreateInput = {
    id: number
    descripcion: string
    facturas?: Factura_EncabezadoCreateNestedManyWithoutTipoPagoInput
  }

  export type TipoPagoUncheckedCreateInput = {
    id: number
    descripcion: string
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutTipoPagoInput
  }

  export type TipoPagoUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    facturas?: Factura_EncabezadoUpdateManyWithoutTipoPagoNestedInput
  }

  export type TipoPagoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutTipoPagoNestedInput
  }

  export type TipoPagoCreateManyInput = {
    id: number
    descripcion: string
  }

  export type TipoPagoUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoPagoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_EncabezadoCreateInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    detalles?: Factura_DetalleCreateNestedManyWithoutFactura_EncabezadoInput
    Usuario: UsuarioCreateNestedOneWithoutFacturasInput
    TipoPago: TipoPagoCreateNestedOneWithoutFacturasInput
  }

  export type Factura_EncabezadoUncheckedCreateInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    idUsuario: string
    idTipoPago: number
  }

  export type Factura_EncabezadoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUpdateManyWithoutFactura_EncabezadoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutFacturasNestedInput
    TipoPago?: TipoPagoUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    idUsuario?: StringFieldUpdateOperationsInput | string
    idTipoPago?: IntFieldUpdateOperationsInput | number
  }

  export type Factura_EncabezadoCreateManyInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    idUsuario: string
    idTipoPago: number
  }

  export type Factura_EncabezadoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Factura_EncabezadoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idUsuario?: StringFieldUpdateOperationsInput | string
    idTipoPago?: IntFieldUpdateOperationsInput | number
  }

  export type Factura_DetalleCreateInput = {
    id?: bigint | number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    Factura_Encabezado: Factura_EncabezadoCreateNestedOneWithoutDetallesInput
    Producto: ProductoCreateNestedOneWithoutDetallesInput
  }

  export type Factura_DetalleUncheckedCreateInput = {
    id?: bigint | number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idFactura_Encabezado: bigint | number
    idProducto: bigint | number
  }

  export type Factura_DetalleUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Factura_Encabezado?: Factura_EncabezadoUpdateOneRequiredWithoutDetallesNestedInput
    Producto?: ProductoUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type Factura_DetalleUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: BigIntFieldUpdateOperationsInput | bigint | number
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Factura_DetalleCreateManyInput = {
    id?: bigint | number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idFactura_Encabezado: bigint | number
    idProducto: bigint | number
  }

  export type Factura_DetalleUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type Factura_DetalleUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: BigIntFieldUpdateOperationsInput | bigint | number
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PedidoCreateInput = {
    id?: bigint | number
    nombre?: string | null
    precio: Decimal | DecimalJsLike | number | string
    productos?: Pedido_ProductoCreateNestedManyWithoutPedidoInput
    Usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateInput = {
    id?: bigint | number
    nombre?: string | null
    precio: Decimal | DecimalJsLike | number | string
    productos?: Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput
    idUsuario: string
  }

  export type PedidoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productos?: Pedido_ProductoUpdateManyWithoutPedidoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productos?: Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoCreateManyInput = {
    id?: bigint | number
    nombre?: string | null
    precio: Decimal | DecimalJsLike | number | string
    idUsuario: string
  }

  export type PedidoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PedidoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoCreateInput = {
    Pedido: PedidoCreateNestedOneWithoutProductosInput
    Producto: ProductoCreateNestedOneWithoutPedidosInput
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUncheckedCreateInput = {
    idPedido: bigint | number
    idProducto: bigint | number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUpdateInput = {
    Pedido?: PedidoUpdateOneRequiredWithoutProductosNestedInput
    Producto?: ProductoUpdateOneRequiredWithoutPedidosNestedInput
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateInput = {
    idPedido?: BigIntFieldUpdateOperationsInput | bigint | number
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoCreateManyInput = {
    idPedido: bigint | number
    idProducto: bigint | number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateManyInput = {
    idPedido?: BigIntFieldUpdateOperationsInput | bigint | number
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerfilCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type PerfilAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PerfilMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type PerfilMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type PerfilSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type ReservacionListRelationFilter = {
    every?: ReservacionWhereInput
    some?: ReservacionWhereInput
    none?: ReservacionWhereInput
  }

  export type Factura_EncabezadoListRelationFilter = {
    every?: Factura_EncabezadoWhereInput
    some?: Factura_EncabezadoWhereInput
    none?: Factura_EncabezadoWhereInput
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type PerfilRelationFilter = {
    is?: PerfilWhereInput
    isNot?: PerfilWhereInput
  }

  export type MeseroOnSucursalListRelationFilter = {
    every?: MeseroOnSucursalWhereInput
    some?: MeseroOnSucursalWhereInput
    none?: MeseroOnSucursalWhereInput
  }

  export type ReservacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Factura_EncabezadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeseroOnSucursalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCorreoUsernameTelefonoCompoundUniqueInput = {
    correo: string
    username: string
    telefono: string
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    idPerfil?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    idPerfil?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    idPerfil?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    idPerfil?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    idPerfil?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type SucursalRelationFilter = {
    is?: SucursalWhereInput
    isNot?: SucursalWhereInput
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type MeseroOnSucursalIdSucursalIdMeseroCompoundUniqueInput = {
    idSucursal: bigint | number
    idMesero: string
  }

  export type MeseroOnSucursalCountOrderByAggregateInput = {
    idSucursal?: SortOrder
    idMesero?: SortOrder
  }

  export type MeseroOnSucursalAvgOrderByAggregateInput = {
    idSucursal?: SortOrder
  }

  export type MeseroOnSucursalMaxOrderByAggregateInput = {
    idSucursal?: SortOrder
    idMesero?: SortOrder
  }

  export type MeseroOnSucursalMinOrderByAggregateInput = {
    idSucursal?: SortOrder
    idMesero?: SortOrder
  }

  export type MeseroOnSucursalSumOrderByAggregateInput = {
    idSucursal?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type MesaListRelationFilter = {
    every?: MesaWhereInput
    some?: MesaWhereInput
    none?: MesaWhereInput
  }

  export type Sucursal_ProductoListRelationFilter = {
    every?: Sucursal_ProductoWhereInput
    some?: Sucursal_ProductoWhereInput
    none?: Sucursal_ProductoWhereInput
  }

  export type MesaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Sucursal_ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SucursalCodigoNombreCompoundUniqueInput = {
    codigo: string
    nombre: string
  }

  export type SucursalCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
  }

  export type SucursalAvgOrderByAggregateInput = {
    id?: SortOrder
    capacidad?: SortOrder
  }

  export type SucursalMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
  }

  export type SucursalMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
  }

  export type SucursalSumOrderByAggregateInput = {
    id?: SortOrder
    capacidad?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type Reservacion_MesaListRelationFilter = {
    every?: Reservacion_MesaWhereInput
    some?: Reservacion_MesaWhereInput
    none?: Reservacion_MesaWhereInput
  }

  export type EstadoMesaRelationFilter = {
    is?: EstadoMesaWhereInput
    isNot?: EstadoMesaWhereInput
  }

  export type Reservacion_MesaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MesaCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    idSucursal?: SortOrder
    idEstadoMesa?: SortOrder
  }

  export type MesaAvgOrderByAggregateInput = {
    id?: SortOrder
    capacidad?: SortOrder
    disponibilidad?: SortOrder
    idSucursal?: SortOrder
    idEstadoMesa?: SortOrder
  }

  export type MesaMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    idSucursal?: SortOrder
    idEstadoMesa?: SortOrder
  }

  export type MesaMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    disponibilidad?: SortOrder
    estado?: SortOrder
    idSucursal?: SortOrder
    idEstadoMesa?: SortOrder
  }

  export type MesaSumOrderByAggregateInput = {
    id?: SortOrder
    capacidad?: SortOrder
    disponibilidad?: SortOrder
    idSucursal?: SortOrder
    idEstadoMesa?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EstadoMesaCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type EstadoMesaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EstadoMesaMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type EstadoMesaMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type EstadoMesaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ReservacionCountOrderByAggregateInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    idSucursal?: SortOrder
    idUsuario?: SortOrder
  }

  export type ReservacionAvgOrderByAggregateInput = {
    id?: SortOrder
    idSucursal?: SortOrder
  }

  export type ReservacionMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    idSucursal?: SortOrder
    idUsuario?: SortOrder
  }

  export type ReservacionMinOrderByAggregateInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    idSucursal?: SortOrder
    idUsuario?: SortOrder
  }

  export type ReservacionSumOrderByAggregateInput = {
    id?: SortOrder
    idSucursal?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type MesaRelationFilter = {
    is?: MesaWhereInput
    isNot?: MesaWhereInput
  }

  export type ReservacionRelationFilter = {
    is?: ReservacionWhereInput
    isNot?: ReservacionWhereInput
  }

  export type Reservacion_MesaIdMesaIdReservacionCompoundUniqueInput = {
    idMesa: bigint | number
    idReservacion: bigint | number
  }

  export type Reservacion_MesaCountOrderByAggregateInput = {
    idMesa?: SortOrder
    idReservacion?: SortOrder
    cantidad?: SortOrder
  }

  export type Reservacion_MesaAvgOrderByAggregateInput = {
    idMesa?: SortOrder
    idReservacion?: SortOrder
    cantidad?: SortOrder
  }

  export type Reservacion_MesaMaxOrderByAggregateInput = {
    idMesa?: SortOrder
    idReservacion?: SortOrder
    cantidad?: SortOrder
  }

  export type Reservacion_MesaMinOrderByAggregateInput = {
    idMesa?: SortOrder
    idReservacion?: SortOrder
    cantidad?: SortOrder
  }

  export type Reservacion_MesaSumOrderByAggregateInput = {
    idMesa?: SortOrder
    idReservacion?: SortOrder
    cantidad?: SortOrder
  }

  export type ProductoListRelationFilter = {
    every?: ProductoWhereInput
    some?: ProductoWhereInput
    none?: ProductoWhereInput
  }

  export type ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Categoria_ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type Categoria_ProductoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Categoria_ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type Categoria_ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type Categoria_ProductoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type Categoria_ProductoRelationFilter = {
    is?: Categoria_ProductoWhereInput
    isNot?: Categoria_ProductoWhereInput
  }

  export type Factura_DetalleListRelationFilter = {
    every?: Factura_DetalleWhereInput
    some?: Factura_DetalleWhereInput
    none?: Factura_DetalleWhereInput
  }

  export type Pedido_ProductoListRelationFilter = {
    every?: Pedido_ProductoWhereInput
    some?: Pedido_ProductoWhereInput
    none?: Pedido_ProductoWhereInput
  }

  export type Factura_DetalleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Pedido_ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
  }

  export type ProductoAvgOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
  }

  export type ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
  }

  export type ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
  }

  export type ProductoSumOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type ProductoRelationFilter = {
    is?: ProductoWhereInput
    isNot?: ProductoWhereInput
  }

  export type Sucursal_ProductoIdProductoIdSucursalCompoundUniqueInput = {
    idProducto: bigint | number
    idSucursal: bigint | number
  }

  export type Sucursal_ProductoCountOrderByAggregateInput = {
    idProducto?: SortOrder
    idSucursal?: SortOrder
  }

  export type Sucursal_ProductoAvgOrderByAggregateInput = {
    idProducto?: SortOrder
    idSucursal?: SortOrder
  }

  export type Sucursal_ProductoMaxOrderByAggregateInput = {
    idProducto?: SortOrder
    idSucursal?: SortOrder
  }

  export type Sucursal_ProductoMinOrderByAggregateInput = {
    idProducto?: SortOrder
    idSucursal?: SortOrder
  }

  export type Sucursal_ProductoSumOrderByAggregateInput = {
    idProducto?: SortOrder
    idSucursal?: SortOrder
  }

  export type TipoPagoCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoPagoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoPagoMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoPagoMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoPagoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTipoTarjetaNullableFilter = {
    equals?: TipoTarjeta | null
    in?: Enumerable<TipoTarjeta> | null
    notIn?: Enumerable<TipoTarjeta> | null
    not?: NestedEnumTipoTarjetaNullableFilter | TipoTarjeta | null
  }

  export type TipoPagoRelationFilter = {
    is?: TipoPagoWhereInput
    isNot?: TipoPagoWhereInput
  }

  export type Factura_EncabezadoCountOrderByAggregateInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    tarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    idUsuario?: SortOrder
    idTipoPago?: SortOrder
  }

  export type Factura_EncabezadoAvgOrderByAggregateInput = {
    id?: SortOrder
    idTipoPago?: SortOrder
  }

  export type Factura_EncabezadoMaxOrderByAggregateInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    tarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    idUsuario?: SortOrder
    idTipoPago?: SortOrder
  }

  export type Factura_EncabezadoMinOrderByAggregateInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    tarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    idUsuario?: SortOrder
    idTipoPago?: SortOrder
  }

  export type Factura_EncabezadoSumOrderByAggregateInput = {
    id?: SortOrder
    idTipoPago?: SortOrder
  }

  export type EnumTipoTarjetaNullableWithAggregatesFilter = {
    equals?: TipoTarjeta | null
    in?: Enumerable<TipoTarjeta> | null
    notIn?: Enumerable<TipoTarjeta> | null
    not?: NestedEnumTipoTarjetaNullableWithAggregatesFilter | TipoTarjeta | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumTipoTarjetaNullableFilter
    _max?: NestedEnumTipoTarjetaNullableFilter
  }

  export type Factura_EncabezadoRelationFilter = {
    is?: Factura_EncabezadoWhereInput
    isNot?: Factura_EncabezadoWhereInput
  }

  export type Factura_DetalleIdIdFactura_EncabezadoCompoundUniqueInput = {
    id: bigint | number
    idFactura_Encabezado: bigint | number
  }

  export type Factura_DetalleCountOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type Factura_DetalleAvgOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type Factura_DetalleMaxOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type Factura_DetalleMinOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type Factura_DetalleSumOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type PedidoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    idUsuario?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    idUsuario?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    idUsuario?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
  }

  export type PedidoRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type Pedido_ProductoIdPedidoIdProductoCompoundUniqueInput = {
    idPedido: bigint | number
    idProducto: bigint | number
  }

  export type Pedido_ProductoCountOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
  }

  export type Pedido_ProductoAvgOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
  }

  export type Pedido_ProductoMaxOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
  }

  export type Pedido_ProductoMinOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
  }

  export type Pedido_ProductoSumOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
  }

  export type UsuarioCreateNestedManyWithoutPerfilInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutPerfilInput>, Enumerable<UsuarioUncheckedCreateWithoutPerfilInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutPerfilInput>
    createMany?: UsuarioCreateManyPerfilInputEnvelope
    connect?: Enumerable<UsuarioWhereUniqueInput>
  }

  export type UsuarioUncheckedCreateNestedManyWithoutPerfilInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutPerfilInput>, Enumerable<UsuarioUncheckedCreateWithoutPerfilInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutPerfilInput>
    createMany?: UsuarioCreateManyPerfilInputEnvelope
    connect?: Enumerable<UsuarioWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UsuarioUpdateManyWithoutPerfilNestedInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutPerfilInput>, Enumerable<UsuarioUncheckedCreateWithoutPerfilInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutPerfilInput>
    upsert?: Enumerable<UsuarioUpsertWithWhereUniqueWithoutPerfilInput>
    createMany?: UsuarioCreateManyPerfilInputEnvelope
    set?: Enumerable<UsuarioWhereUniqueInput>
    disconnect?: Enumerable<UsuarioWhereUniqueInput>
    delete?: Enumerable<UsuarioWhereUniqueInput>
    connect?: Enumerable<UsuarioWhereUniqueInput>
    update?: Enumerable<UsuarioUpdateWithWhereUniqueWithoutPerfilInput>
    updateMany?: Enumerable<UsuarioUpdateManyWithWhereWithoutPerfilInput>
    deleteMany?: Enumerable<UsuarioScalarWhereInput>
  }

  export type UsuarioUncheckedUpdateManyWithoutPerfilNestedInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutPerfilInput>, Enumerable<UsuarioUncheckedCreateWithoutPerfilInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutPerfilInput>
    upsert?: Enumerable<UsuarioUpsertWithWhereUniqueWithoutPerfilInput>
    createMany?: UsuarioCreateManyPerfilInputEnvelope
    set?: Enumerable<UsuarioWhereUniqueInput>
    disconnect?: Enumerable<UsuarioWhereUniqueInput>
    delete?: Enumerable<UsuarioWhereUniqueInput>
    connect?: Enumerable<UsuarioWhereUniqueInput>
    update?: Enumerable<UsuarioUpdateWithWhereUniqueWithoutPerfilInput>
    updateMany?: Enumerable<UsuarioUpdateManyWithWhereWithoutPerfilInput>
    deleteMany?: Enumerable<UsuarioScalarWhereInput>
  }

  export type ReservacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutUsuarioInput>, Enumerable<ReservacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutUsuarioInput>
    createMany?: ReservacionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type Factura_EncabezadoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutUsuarioInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutUsuarioInput>
    createMany?: Factura_EncabezadoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
  }

  export type PedidoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PerfilCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<PerfilCreateWithoutUsuariosInput, PerfilUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: PerfilCreateOrConnectWithoutUsuariosInput
    connect?: PerfilWhereUniqueInput
  }

  export type MeseroOnSucursalCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<MeseroOnSucursalCreateWithoutUsuarioInput>, Enumerable<MeseroOnSucursalUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<MeseroOnSucursalCreateOrConnectWithoutUsuarioInput>
    createMany?: MeseroOnSucursalCreateManyUsuarioInputEnvelope
    connect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
  }

  export type ReservacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutUsuarioInput>, Enumerable<ReservacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutUsuarioInput>
    createMany?: ReservacionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutUsuarioInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutUsuarioInput>
    createMany?: Factura_EncabezadoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type MeseroOnSucursalUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<MeseroOnSucursalCreateWithoutUsuarioInput>, Enumerable<MeseroOnSucursalUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<MeseroOnSucursalCreateOrConnectWithoutUsuarioInput>
    createMany?: MeseroOnSucursalCreateManyUsuarioInputEnvelope
    connect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ReservacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutUsuarioInput>, Enumerable<ReservacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: ReservacionCreateManyUsuarioInputEnvelope
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutUsuarioInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<Factura_EncabezadoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: Factura_EncabezadoCreateManyUsuarioInputEnvelope
    set?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    disconnect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    delete?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    update?: Enumerable<Factura_EncabezadoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<Factura_EncabezadoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<Factura_EncabezadoScalarWhereInput>
  }

  export type PedidoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type PerfilUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<PerfilCreateWithoutUsuariosInput, PerfilUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: PerfilCreateOrConnectWithoutUsuariosInput
    upsert?: PerfilUpsertWithoutUsuariosInput
    connect?: PerfilWhereUniqueInput
    update?: XOR<PerfilUpdateWithoutUsuariosInput, PerfilUncheckedUpdateWithoutUsuariosInput>
  }

  export type MeseroOnSucursalUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<MeseroOnSucursalCreateWithoutUsuarioInput>, Enumerable<MeseroOnSucursalUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<MeseroOnSucursalCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<MeseroOnSucursalUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: MeseroOnSucursalCreateManyUsuarioInputEnvelope
    set?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    disconnect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    delete?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    connect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    update?: Enumerable<MeseroOnSucursalUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<MeseroOnSucursalUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<MeseroOnSucursalScalarWhereInput>
  }

  export type ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutUsuarioInput>, Enumerable<ReservacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: ReservacionCreateManyUsuarioInputEnvelope
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutUsuarioInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<Factura_EncabezadoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: Factura_EncabezadoCreateManyUsuarioInputEnvelope
    set?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    disconnect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    delete?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    update?: Enumerable<Factura_EncabezadoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<Factura_EncabezadoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<Factura_EncabezadoScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type MeseroOnSucursalUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<MeseroOnSucursalCreateWithoutUsuarioInput>, Enumerable<MeseroOnSucursalUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<MeseroOnSucursalCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<MeseroOnSucursalUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: MeseroOnSucursalCreateManyUsuarioInputEnvelope
    set?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    disconnect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    delete?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    connect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    update?: Enumerable<MeseroOnSucursalUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<MeseroOnSucursalUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<MeseroOnSucursalScalarWhereInput>
  }

  export type SucursalCreateNestedOneWithoutMeseroOnSucursalInput = {
    create?: XOR<SucursalCreateWithoutMeseroOnSucursalInput, SucursalUncheckedCreateWithoutMeseroOnSucursalInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutMeseroOnSucursalInput
    connect?: SucursalWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutMeseroOnSucursalInput = {
    create?: XOR<UsuarioCreateWithoutMeseroOnSucursalInput, UsuarioUncheckedCreateWithoutMeseroOnSucursalInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMeseroOnSucursalInput
    connect?: UsuarioWhereUniqueInput
  }

  export type SucursalUpdateOneRequiredWithoutMeseroOnSucursalNestedInput = {
    create?: XOR<SucursalCreateWithoutMeseroOnSucursalInput, SucursalUncheckedCreateWithoutMeseroOnSucursalInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutMeseroOnSucursalInput
    upsert?: SucursalUpsertWithoutMeseroOnSucursalInput
    connect?: SucursalWhereUniqueInput
    update?: XOR<SucursalUpdateWithoutMeseroOnSucursalInput, SucursalUncheckedUpdateWithoutMeseroOnSucursalInput>
  }

  export type UsuarioUpdateOneRequiredWithoutMeseroOnSucursalNestedInput = {
    create?: XOR<UsuarioCreateWithoutMeseroOnSucursalInput, UsuarioUncheckedCreateWithoutMeseroOnSucursalInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMeseroOnSucursalInput
    upsert?: UsuarioUpsertWithoutMeseroOnSucursalInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutMeseroOnSucursalInput, UsuarioUncheckedUpdateWithoutMeseroOnSucursalInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type MesaCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<MesaCreateWithoutSucursalInput>, Enumerable<MesaUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutSucursalInput>
    createMany?: MesaCreateManySucursalInputEnvelope
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type ReservacionCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutSucursalInput>, Enumerable<ReservacionUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutSucursalInput>
    createMany?: ReservacionCreateManySucursalInputEnvelope
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type Sucursal_ProductoCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<Sucursal_ProductoCreateWithoutSucursalInput>, Enumerable<Sucursal_ProductoUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<Sucursal_ProductoCreateOrConnectWithoutSucursalInput>
    createMany?: Sucursal_ProductoCreateManySucursalInputEnvelope
    connect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
  }

  export type MeseroOnSucursalCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<MeseroOnSucursalCreateWithoutSucursalInput>, Enumerable<MeseroOnSucursalUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MeseroOnSucursalCreateOrConnectWithoutSucursalInput>
    createMany?: MeseroOnSucursalCreateManySucursalInputEnvelope
    connect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
  }

  export type MesaUncheckedCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<MesaCreateWithoutSucursalInput>, Enumerable<MesaUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutSucursalInput>
    createMany?: MesaCreateManySucursalInputEnvelope
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type ReservacionUncheckedCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutSucursalInput>, Enumerable<ReservacionUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutSucursalInput>
    createMany?: ReservacionCreateManySucursalInputEnvelope
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type Sucursal_ProductoUncheckedCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<Sucursal_ProductoCreateWithoutSucursalInput>, Enumerable<Sucursal_ProductoUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<Sucursal_ProductoCreateOrConnectWithoutSucursalInput>
    createMany?: Sucursal_ProductoCreateManySucursalInputEnvelope
    connect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
  }

  export type MeseroOnSucursalUncheckedCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<MeseroOnSucursalCreateWithoutSucursalInput>, Enumerable<MeseroOnSucursalUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MeseroOnSucursalCreateOrConnectWithoutSucursalInput>
    createMany?: MeseroOnSucursalCreateManySucursalInputEnvelope
    connect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
  }

  export type MesaUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutSucursalInput>, Enumerable<MesaUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: MesaCreateManySucursalInputEnvelope
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type ReservacionUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutSucursalInput>, Enumerable<ReservacionUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: ReservacionCreateManySucursalInputEnvelope
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type Sucursal_ProductoUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<Sucursal_ProductoCreateWithoutSucursalInput>, Enumerable<Sucursal_ProductoUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<Sucursal_ProductoCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<Sucursal_ProductoUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: Sucursal_ProductoCreateManySucursalInputEnvelope
    set?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    delete?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    connect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    update?: Enumerable<Sucursal_ProductoUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<Sucursal_ProductoUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<Sucursal_ProductoScalarWhereInput>
  }

  export type MeseroOnSucursalUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<MeseroOnSucursalCreateWithoutSucursalInput>, Enumerable<MeseroOnSucursalUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MeseroOnSucursalCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<MeseroOnSucursalUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: MeseroOnSucursalCreateManySucursalInputEnvelope
    set?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    disconnect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    delete?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    connect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    update?: Enumerable<MeseroOnSucursalUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<MeseroOnSucursalUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<MeseroOnSucursalScalarWhereInput>
  }

  export type MesaUncheckedUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutSucursalInput>, Enumerable<MesaUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: MesaCreateManySucursalInputEnvelope
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type ReservacionUncheckedUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutSucursalInput>, Enumerable<ReservacionUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: ReservacionCreateManySucursalInputEnvelope
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type Sucursal_ProductoUncheckedUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<Sucursal_ProductoCreateWithoutSucursalInput>, Enumerable<Sucursal_ProductoUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<Sucursal_ProductoCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<Sucursal_ProductoUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: Sucursal_ProductoCreateManySucursalInputEnvelope
    set?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    delete?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    connect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    update?: Enumerable<Sucursal_ProductoUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<Sucursal_ProductoUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<Sucursal_ProductoScalarWhereInput>
  }

  export type MeseroOnSucursalUncheckedUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<MeseroOnSucursalCreateWithoutSucursalInput>, Enumerable<MeseroOnSucursalUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MeseroOnSucursalCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<MeseroOnSucursalUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: MeseroOnSucursalCreateManySucursalInputEnvelope
    set?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    disconnect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    delete?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    connect?: Enumerable<MeseroOnSucursalWhereUniqueInput>
    update?: Enumerable<MeseroOnSucursalUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<MeseroOnSucursalUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<MeseroOnSucursalScalarWhereInput>
  }

  export type Reservacion_MesaCreateNestedManyWithoutMesaInput = {
    create?: XOR<Enumerable<Reservacion_MesaCreateWithoutMesaInput>, Enumerable<Reservacion_MesaUncheckedCreateWithoutMesaInput>>
    connectOrCreate?: Enumerable<Reservacion_MesaCreateOrConnectWithoutMesaInput>
    createMany?: Reservacion_MesaCreateManyMesaInputEnvelope
    connect?: Enumerable<Reservacion_MesaWhereUniqueInput>
  }

  export type SucursalCreateNestedOneWithoutMesasInput = {
    create?: XOR<SucursalCreateWithoutMesasInput, SucursalUncheckedCreateWithoutMesasInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutMesasInput
    connect?: SucursalWhereUniqueInput
  }

  export type EstadoMesaCreateNestedOneWithoutMesasInput = {
    create?: XOR<EstadoMesaCreateWithoutMesasInput, EstadoMesaUncheckedCreateWithoutMesasInput>
    connectOrCreate?: EstadoMesaCreateOrConnectWithoutMesasInput
    connect?: EstadoMesaWhereUniqueInput
  }

  export type Reservacion_MesaUncheckedCreateNestedManyWithoutMesaInput = {
    create?: XOR<Enumerable<Reservacion_MesaCreateWithoutMesaInput>, Enumerable<Reservacion_MesaUncheckedCreateWithoutMesaInput>>
    connectOrCreate?: Enumerable<Reservacion_MesaCreateOrConnectWithoutMesaInput>
    createMany?: Reservacion_MesaCreateManyMesaInputEnvelope
    connect?: Enumerable<Reservacion_MesaWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type Reservacion_MesaUpdateManyWithoutMesaNestedInput = {
    create?: XOR<Enumerable<Reservacion_MesaCreateWithoutMesaInput>, Enumerable<Reservacion_MesaUncheckedCreateWithoutMesaInput>>
    connectOrCreate?: Enumerable<Reservacion_MesaCreateOrConnectWithoutMesaInput>
    upsert?: Enumerable<Reservacion_MesaUpsertWithWhereUniqueWithoutMesaInput>
    createMany?: Reservacion_MesaCreateManyMesaInputEnvelope
    set?: Enumerable<Reservacion_MesaWhereUniqueInput>
    disconnect?: Enumerable<Reservacion_MesaWhereUniqueInput>
    delete?: Enumerable<Reservacion_MesaWhereUniqueInput>
    connect?: Enumerable<Reservacion_MesaWhereUniqueInput>
    update?: Enumerable<Reservacion_MesaUpdateWithWhereUniqueWithoutMesaInput>
    updateMany?: Enumerable<Reservacion_MesaUpdateManyWithWhereWithoutMesaInput>
    deleteMany?: Enumerable<Reservacion_MesaScalarWhereInput>
  }

  export type SucursalUpdateOneRequiredWithoutMesasNestedInput = {
    create?: XOR<SucursalCreateWithoutMesasInput, SucursalUncheckedCreateWithoutMesasInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutMesasInput
    upsert?: SucursalUpsertWithoutMesasInput
    connect?: SucursalWhereUniqueInput
    update?: XOR<SucursalUpdateWithoutMesasInput, SucursalUncheckedUpdateWithoutMesasInput>
  }

  export type EstadoMesaUpdateOneRequiredWithoutMesasNestedInput = {
    create?: XOR<EstadoMesaCreateWithoutMesasInput, EstadoMesaUncheckedCreateWithoutMesasInput>
    connectOrCreate?: EstadoMesaCreateOrConnectWithoutMesasInput
    upsert?: EstadoMesaUpsertWithoutMesasInput
    connect?: EstadoMesaWhereUniqueInput
    update?: XOR<EstadoMesaUpdateWithoutMesasInput, EstadoMesaUncheckedUpdateWithoutMesasInput>
  }

  export type Reservacion_MesaUncheckedUpdateManyWithoutMesaNestedInput = {
    create?: XOR<Enumerable<Reservacion_MesaCreateWithoutMesaInput>, Enumerable<Reservacion_MesaUncheckedCreateWithoutMesaInput>>
    connectOrCreate?: Enumerable<Reservacion_MesaCreateOrConnectWithoutMesaInput>
    upsert?: Enumerable<Reservacion_MesaUpsertWithWhereUniqueWithoutMesaInput>
    createMany?: Reservacion_MesaCreateManyMesaInputEnvelope
    set?: Enumerable<Reservacion_MesaWhereUniqueInput>
    disconnect?: Enumerable<Reservacion_MesaWhereUniqueInput>
    delete?: Enumerable<Reservacion_MesaWhereUniqueInput>
    connect?: Enumerable<Reservacion_MesaWhereUniqueInput>
    update?: Enumerable<Reservacion_MesaUpdateWithWhereUniqueWithoutMesaInput>
    updateMany?: Enumerable<Reservacion_MesaUpdateManyWithWhereWithoutMesaInput>
    deleteMany?: Enumerable<Reservacion_MesaScalarWhereInput>
  }

  export type MesaCreateNestedManyWithoutEstadoMesaInput = {
    create?: XOR<Enumerable<MesaCreateWithoutEstadoMesaInput>, Enumerable<MesaUncheckedCreateWithoutEstadoMesaInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutEstadoMesaInput>
    createMany?: MesaCreateManyEstadoMesaInputEnvelope
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type MesaUncheckedCreateNestedManyWithoutEstadoMesaInput = {
    create?: XOR<Enumerable<MesaCreateWithoutEstadoMesaInput>, Enumerable<MesaUncheckedCreateWithoutEstadoMesaInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutEstadoMesaInput>
    createMany?: MesaCreateManyEstadoMesaInputEnvelope
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type MesaUpdateManyWithoutEstadoMesaNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutEstadoMesaInput>, Enumerable<MesaUncheckedCreateWithoutEstadoMesaInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutEstadoMesaInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutEstadoMesaInput>
    createMany?: MesaCreateManyEstadoMesaInputEnvelope
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutEstadoMesaInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutEstadoMesaInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type MesaUncheckedUpdateManyWithoutEstadoMesaNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutEstadoMesaInput>, Enumerable<MesaUncheckedCreateWithoutEstadoMesaInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutEstadoMesaInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutEstadoMesaInput>
    createMany?: MesaCreateManyEstadoMesaInputEnvelope
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutEstadoMesaInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutEstadoMesaInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type Reservacion_MesaCreateNestedManyWithoutReservacionInput = {
    create?: XOR<Enumerable<Reservacion_MesaCreateWithoutReservacionInput>, Enumerable<Reservacion_MesaUncheckedCreateWithoutReservacionInput>>
    connectOrCreate?: Enumerable<Reservacion_MesaCreateOrConnectWithoutReservacionInput>
    createMany?: Reservacion_MesaCreateManyReservacionInputEnvelope
    connect?: Enumerable<Reservacion_MesaWhereUniqueInput>
  }

  export type SucursalCreateNestedOneWithoutReservacionesInput = {
    create?: XOR<SucursalCreateWithoutReservacionesInput, SucursalUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutReservacionesInput
    connect?: SucursalWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutReservacionesInput = {
    create?: XOR<UsuarioCreateWithoutReservacionesInput, UsuarioUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutReservacionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type Reservacion_MesaUncheckedCreateNestedManyWithoutReservacionInput = {
    create?: XOR<Enumerable<Reservacion_MesaCreateWithoutReservacionInput>, Enumerable<Reservacion_MesaUncheckedCreateWithoutReservacionInput>>
    connectOrCreate?: Enumerable<Reservacion_MesaCreateOrConnectWithoutReservacionInput>
    createMany?: Reservacion_MesaCreateManyReservacionInputEnvelope
    connect?: Enumerable<Reservacion_MesaWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type Reservacion_MesaUpdateManyWithoutReservacionNestedInput = {
    create?: XOR<Enumerable<Reservacion_MesaCreateWithoutReservacionInput>, Enumerable<Reservacion_MesaUncheckedCreateWithoutReservacionInput>>
    connectOrCreate?: Enumerable<Reservacion_MesaCreateOrConnectWithoutReservacionInput>
    upsert?: Enumerable<Reservacion_MesaUpsertWithWhereUniqueWithoutReservacionInput>
    createMany?: Reservacion_MesaCreateManyReservacionInputEnvelope
    set?: Enumerable<Reservacion_MesaWhereUniqueInput>
    disconnect?: Enumerable<Reservacion_MesaWhereUniqueInput>
    delete?: Enumerable<Reservacion_MesaWhereUniqueInput>
    connect?: Enumerable<Reservacion_MesaWhereUniqueInput>
    update?: Enumerable<Reservacion_MesaUpdateWithWhereUniqueWithoutReservacionInput>
    updateMany?: Enumerable<Reservacion_MesaUpdateManyWithWhereWithoutReservacionInput>
    deleteMany?: Enumerable<Reservacion_MesaScalarWhereInput>
  }

  export type SucursalUpdateOneRequiredWithoutReservacionesNestedInput = {
    create?: XOR<SucursalCreateWithoutReservacionesInput, SucursalUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutReservacionesInput
    upsert?: SucursalUpsertWithoutReservacionesInput
    connect?: SucursalWhereUniqueInput
    update?: XOR<SucursalUpdateWithoutReservacionesInput, SucursalUncheckedUpdateWithoutReservacionesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutReservacionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutReservacionesInput, UsuarioUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutReservacionesInput
    upsert?: UsuarioUpsertWithoutReservacionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutReservacionesInput, UsuarioUncheckedUpdateWithoutReservacionesInput>
  }

  export type Reservacion_MesaUncheckedUpdateManyWithoutReservacionNestedInput = {
    create?: XOR<Enumerable<Reservacion_MesaCreateWithoutReservacionInput>, Enumerable<Reservacion_MesaUncheckedCreateWithoutReservacionInput>>
    connectOrCreate?: Enumerable<Reservacion_MesaCreateOrConnectWithoutReservacionInput>
    upsert?: Enumerable<Reservacion_MesaUpsertWithWhereUniqueWithoutReservacionInput>
    createMany?: Reservacion_MesaCreateManyReservacionInputEnvelope
    set?: Enumerable<Reservacion_MesaWhereUniqueInput>
    disconnect?: Enumerable<Reservacion_MesaWhereUniqueInput>
    delete?: Enumerable<Reservacion_MesaWhereUniqueInput>
    connect?: Enumerable<Reservacion_MesaWhereUniqueInput>
    update?: Enumerable<Reservacion_MesaUpdateWithWhereUniqueWithoutReservacionInput>
    updateMany?: Enumerable<Reservacion_MesaUpdateManyWithWhereWithoutReservacionInput>
    deleteMany?: Enumerable<Reservacion_MesaScalarWhereInput>
  }

  export type MesaCreateNestedOneWithoutReservacionesInput = {
    create?: XOR<MesaCreateWithoutReservacionesInput, MesaUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: MesaCreateOrConnectWithoutReservacionesInput
    connect?: MesaWhereUniqueInput
  }

  export type ReservacionCreateNestedOneWithoutMesasInput = {
    create?: XOR<ReservacionCreateWithoutMesasInput, ReservacionUncheckedCreateWithoutMesasInput>
    connectOrCreate?: ReservacionCreateOrConnectWithoutMesasInput
    connect?: ReservacionWhereUniqueInput
  }

  export type MesaUpdateOneRequiredWithoutReservacionesNestedInput = {
    create?: XOR<MesaCreateWithoutReservacionesInput, MesaUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: MesaCreateOrConnectWithoutReservacionesInput
    upsert?: MesaUpsertWithoutReservacionesInput
    connect?: MesaWhereUniqueInput
    update?: XOR<MesaUpdateWithoutReservacionesInput, MesaUncheckedUpdateWithoutReservacionesInput>
  }

  export type ReservacionUpdateOneRequiredWithoutMesasNestedInput = {
    create?: XOR<ReservacionCreateWithoutMesasInput, ReservacionUncheckedCreateWithoutMesasInput>
    connectOrCreate?: ReservacionCreateOrConnectWithoutMesasInput
    upsert?: ReservacionUpsertWithoutMesasInput
    connect?: ReservacionWhereUniqueInput
    update?: XOR<ReservacionUpdateWithoutMesasInput, ReservacionUncheckedUpdateWithoutMesasInput>
  }

  export type ProductoCreateNestedManyWithoutCategoria_ProductoInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutCategoria_ProductoInput>, Enumerable<ProductoUncheckedCreateWithoutCategoria_ProductoInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutCategoria_ProductoInput>
    createMany?: ProductoCreateManyCategoria_ProductoInputEnvelope
    connect?: Enumerable<ProductoWhereUniqueInput>
  }

  export type ProductoUncheckedCreateNestedManyWithoutCategoria_ProductoInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutCategoria_ProductoInput>, Enumerable<ProductoUncheckedCreateWithoutCategoria_ProductoInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutCategoria_ProductoInput>
    createMany?: ProductoCreateManyCategoria_ProductoInputEnvelope
    connect?: Enumerable<ProductoWhereUniqueInput>
  }

  export type ProductoUpdateManyWithoutCategoria_ProductoNestedInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutCategoria_ProductoInput>, Enumerable<ProductoUncheckedCreateWithoutCategoria_ProductoInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutCategoria_ProductoInput>
    upsert?: Enumerable<ProductoUpsertWithWhereUniqueWithoutCategoria_ProductoInput>
    createMany?: ProductoCreateManyCategoria_ProductoInputEnvelope
    set?: Enumerable<ProductoWhereUniqueInput>
    disconnect?: Enumerable<ProductoWhereUniqueInput>
    delete?: Enumerable<ProductoWhereUniqueInput>
    connect?: Enumerable<ProductoWhereUniqueInput>
    update?: Enumerable<ProductoUpdateWithWhereUniqueWithoutCategoria_ProductoInput>
    updateMany?: Enumerable<ProductoUpdateManyWithWhereWithoutCategoria_ProductoInput>
    deleteMany?: Enumerable<ProductoScalarWhereInput>
  }

  export type ProductoUncheckedUpdateManyWithoutCategoria_ProductoNestedInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutCategoria_ProductoInput>, Enumerable<ProductoUncheckedCreateWithoutCategoria_ProductoInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutCategoria_ProductoInput>
    upsert?: Enumerable<ProductoUpsertWithWhereUniqueWithoutCategoria_ProductoInput>
    createMany?: ProductoCreateManyCategoria_ProductoInputEnvelope
    set?: Enumerable<ProductoWhereUniqueInput>
    disconnect?: Enumerable<ProductoWhereUniqueInput>
    delete?: Enumerable<ProductoWhereUniqueInput>
    connect?: Enumerable<ProductoWhereUniqueInput>
    update?: Enumerable<ProductoUpdateWithWhereUniqueWithoutCategoria_ProductoInput>
    updateMany?: Enumerable<ProductoUpdateManyWithWhereWithoutCategoria_ProductoInput>
    deleteMany?: Enumerable<ProductoScalarWhereInput>
  }

  export type Categoria_ProductoCreateNestedOneWithoutProductosInput = {
    create?: XOR<Categoria_ProductoCreateWithoutProductosInput, Categoria_ProductoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: Categoria_ProductoCreateOrConnectWithoutProductosInput
    connect?: Categoria_ProductoWhereUniqueInput
  }

  export type Factura_DetalleCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutProductoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutProductoInput>
    createMany?: Factura_DetalleCreateManyProductoInputEnvelope
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
  }

  export type Pedido_ProductoCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutProductoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutProductoInput>
    createMany?: Pedido_ProductoCreateManyProductoInputEnvelope
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
  }

  export type Sucursal_ProductoCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Sucursal_ProductoCreateWithoutProductoInput>, Enumerable<Sucursal_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Sucursal_ProductoCreateOrConnectWithoutProductoInput>
    createMany?: Sucursal_ProductoCreateManyProductoInputEnvelope
    connect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
  }

  export type Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutProductoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutProductoInput>
    createMany?: Factura_DetalleCreateManyProductoInputEnvelope
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
  }

  export type Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutProductoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutProductoInput>
    createMany?: Pedido_ProductoCreateManyProductoInputEnvelope
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
  }

  export type Sucursal_ProductoUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Sucursal_ProductoCreateWithoutProductoInput>, Enumerable<Sucursal_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Sucursal_ProductoCreateOrConnectWithoutProductoInput>
    createMany?: Sucursal_ProductoCreateManyProductoInputEnvelope
    connect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<Categoria_ProductoCreateWithoutProductosInput, Categoria_ProductoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: Categoria_ProductoCreateOrConnectWithoutProductosInput
    upsert?: Categoria_ProductoUpsertWithoutProductosInput
    connect?: Categoria_ProductoWhereUniqueInput
    update?: XOR<Categoria_ProductoUpdateWithoutProductosInput, Categoria_ProductoUncheckedUpdateWithoutProductosInput>
  }

  export type Factura_DetalleUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutProductoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Factura_DetalleUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Factura_DetalleCreateManyProductoInputEnvelope
    set?: Enumerable<Factura_DetalleWhereUniqueInput>
    disconnect?: Enumerable<Factura_DetalleWhereUniqueInput>
    delete?: Enumerable<Factura_DetalleWhereUniqueInput>
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
    update?: Enumerable<Factura_DetalleUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Factura_DetalleUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Factura_DetalleScalarWhereInput>
  }

  export type Pedido_ProductoUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutProductoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Pedido_ProductoUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Pedido_ProductoCreateManyProductoInputEnvelope
    set?: Enumerable<Pedido_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    delete?: Enumerable<Pedido_ProductoWhereUniqueInput>
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    update?: Enumerable<Pedido_ProductoUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Pedido_ProductoUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Pedido_ProductoScalarWhereInput>
  }

  export type Sucursal_ProductoUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Sucursal_ProductoCreateWithoutProductoInput>, Enumerable<Sucursal_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Sucursal_ProductoCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Sucursal_ProductoUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Sucursal_ProductoCreateManyProductoInputEnvelope
    set?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    delete?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    connect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    update?: Enumerable<Sucursal_ProductoUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Sucursal_ProductoUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Sucursal_ProductoScalarWhereInput>
  }

  export type Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutProductoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Factura_DetalleUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Factura_DetalleCreateManyProductoInputEnvelope
    set?: Enumerable<Factura_DetalleWhereUniqueInput>
    disconnect?: Enumerable<Factura_DetalleWhereUniqueInput>
    delete?: Enumerable<Factura_DetalleWhereUniqueInput>
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
    update?: Enumerable<Factura_DetalleUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Factura_DetalleUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Factura_DetalleScalarWhereInput>
  }

  export type Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutProductoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Pedido_ProductoUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Pedido_ProductoCreateManyProductoInputEnvelope
    set?: Enumerable<Pedido_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    delete?: Enumerable<Pedido_ProductoWhereUniqueInput>
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    update?: Enumerable<Pedido_ProductoUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Pedido_ProductoUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Pedido_ProductoScalarWhereInput>
  }

  export type Sucursal_ProductoUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Sucursal_ProductoCreateWithoutProductoInput>, Enumerable<Sucursal_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Sucursal_ProductoCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Sucursal_ProductoUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Sucursal_ProductoCreateManyProductoInputEnvelope
    set?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    delete?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    connect?: Enumerable<Sucursal_ProductoWhereUniqueInput>
    update?: Enumerable<Sucursal_ProductoUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Sucursal_ProductoUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Sucursal_ProductoScalarWhereInput>
  }

  export type ProductoCreateNestedOneWithoutSucursalesInput = {
    create?: XOR<ProductoCreateWithoutSucursalesInput, ProductoUncheckedCreateWithoutSucursalesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutSucursalesInput
    connect?: ProductoWhereUniqueInput
  }

  export type SucursalCreateNestedOneWithoutProductosInput = {
    create?: XOR<SucursalCreateWithoutProductosInput, SucursalUncheckedCreateWithoutProductosInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutProductosInput
    connect?: SucursalWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutSucursalesNestedInput = {
    create?: XOR<ProductoCreateWithoutSucursalesInput, ProductoUncheckedCreateWithoutSucursalesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutSucursalesInput
    upsert?: ProductoUpsertWithoutSucursalesInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<ProductoUpdateWithoutSucursalesInput, ProductoUncheckedUpdateWithoutSucursalesInput>
  }

  export type SucursalUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<SucursalCreateWithoutProductosInput, SucursalUncheckedCreateWithoutProductosInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutProductosInput
    upsert?: SucursalUpsertWithoutProductosInput
    connect?: SucursalWhereUniqueInput
    update?: XOR<SucursalUpdateWithoutProductosInput, SucursalUncheckedUpdateWithoutProductosInput>
  }

  export type Factura_EncabezadoCreateNestedManyWithoutTipoPagoInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutTipoPagoInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutTipoPagoInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutTipoPagoInput>
    createMany?: Factura_EncabezadoCreateManyTipoPagoInputEnvelope
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
  }

  export type Factura_EncabezadoUncheckedCreateNestedManyWithoutTipoPagoInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutTipoPagoInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutTipoPagoInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutTipoPagoInput>
    createMany?: Factura_EncabezadoCreateManyTipoPagoInputEnvelope
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
  }

  export type Factura_EncabezadoUpdateManyWithoutTipoPagoNestedInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutTipoPagoInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutTipoPagoInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutTipoPagoInput>
    upsert?: Enumerable<Factura_EncabezadoUpsertWithWhereUniqueWithoutTipoPagoInput>
    createMany?: Factura_EncabezadoCreateManyTipoPagoInputEnvelope
    set?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    disconnect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    delete?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    update?: Enumerable<Factura_EncabezadoUpdateWithWhereUniqueWithoutTipoPagoInput>
    updateMany?: Enumerable<Factura_EncabezadoUpdateManyWithWhereWithoutTipoPagoInput>
    deleteMany?: Enumerable<Factura_EncabezadoScalarWhereInput>
  }

  export type Factura_EncabezadoUncheckedUpdateManyWithoutTipoPagoNestedInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutTipoPagoInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutTipoPagoInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutTipoPagoInput>
    upsert?: Enumerable<Factura_EncabezadoUpsertWithWhereUniqueWithoutTipoPagoInput>
    createMany?: Factura_EncabezadoCreateManyTipoPagoInputEnvelope
    set?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    disconnect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    delete?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    update?: Enumerable<Factura_EncabezadoUpdateWithWhereUniqueWithoutTipoPagoInput>
    updateMany?: Enumerable<Factura_EncabezadoUpdateManyWithWhereWithoutTipoPagoInput>
    deleteMany?: Enumerable<Factura_EncabezadoScalarWhereInput>
  }

  export type Factura_DetalleCreateNestedManyWithoutFactura_EncabezadoInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutFactura_EncabezadoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput>
    createMany?: Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
  }

  export type UsuarioCreateNestedOneWithoutFacturasInput = {
    create?: XOR<UsuarioCreateWithoutFacturasInput, UsuarioUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFacturasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type TipoPagoCreateNestedOneWithoutFacturasInput = {
    create?: XOR<TipoPagoCreateWithoutFacturasInput, TipoPagoUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: TipoPagoCreateOrConnectWithoutFacturasInput
    connect?: TipoPagoWhereUniqueInput
  }

  export type Factura_DetalleUncheckedCreateNestedManyWithoutFactura_EncabezadoInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutFactura_EncabezadoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput>
    createMany?: Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
  }

  export type NullableEnumTipoTarjetaFieldUpdateOperationsInput = {
    set?: TipoTarjeta | null
  }

  export type Factura_DetalleUpdateManyWithoutFactura_EncabezadoNestedInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutFactura_EncabezadoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput>
    upsert?: Enumerable<Factura_DetalleUpsertWithWhereUniqueWithoutFactura_EncabezadoInput>
    createMany?: Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope
    set?: Enumerable<Factura_DetalleWhereUniqueInput>
    disconnect?: Enumerable<Factura_DetalleWhereUniqueInput>
    delete?: Enumerable<Factura_DetalleWhereUniqueInput>
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
    update?: Enumerable<Factura_DetalleUpdateWithWhereUniqueWithoutFactura_EncabezadoInput>
    updateMany?: Enumerable<Factura_DetalleUpdateManyWithWhereWithoutFactura_EncabezadoInput>
    deleteMany?: Enumerable<Factura_DetalleScalarWhereInput>
  }

  export type UsuarioUpdateOneRequiredWithoutFacturasNestedInput = {
    create?: XOR<UsuarioCreateWithoutFacturasInput, UsuarioUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFacturasInput
    upsert?: UsuarioUpsertWithoutFacturasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutFacturasInput, UsuarioUncheckedUpdateWithoutFacturasInput>
  }

  export type TipoPagoUpdateOneRequiredWithoutFacturasNestedInput = {
    create?: XOR<TipoPagoCreateWithoutFacturasInput, TipoPagoUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: TipoPagoCreateOrConnectWithoutFacturasInput
    upsert?: TipoPagoUpsertWithoutFacturasInput
    connect?: TipoPagoWhereUniqueInput
    update?: XOR<TipoPagoUpdateWithoutFacturasInput, TipoPagoUncheckedUpdateWithoutFacturasInput>
  }

  export type Factura_DetalleUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutFactura_EncabezadoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput>
    upsert?: Enumerable<Factura_DetalleUpsertWithWhereUniqueWithoutFactura_EncabezadoInput>
    createMany?: Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope
    set?: Enumerable<Factura_DetalleWhereUniqueInput>
    disconnect?: Enumerable<Factura_DetalleWhereUniqueInput>
    delete?: Enumerable<Factura_DetalleWhereUniqueInput>
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
    update?: Enumerable<Factura_DetalleUpdateWithWhereUniqueWithoutFactura_EncabezadoInput>
    updateMany?: Enumerable<Factura_DetalleUpdateManyWithWhereWithoutFactura_EncabezadoInput>
    deleteMany?: Enumerable<Factura_DetalleScalarWhereInput>
  }

  export type Factura_EncabezadoCreateNestedOneWithoutDetallesInput = {
    create?: XOR<Factura_EncabezadoCreateWithoutDetallesInput, Factura_EncabezadoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: Factura_EncabezadoCreateOrConnectWithoutDetallesInput
    connect?: Factura_EncabezadoWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutDetallesInput = {
    create?: XOR<ProductoCreateWithoutDetallesInput, ProductoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetallesInput
    connect?: ProductoWhereUniqueInput
  }

  export type Factura_EncabezadoUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<Factura_EncabezadoCreateWithoutDetallesInput, Factura_EncabezadoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: Factura_EncabezadoCreateOrConnectWithoutDetallesInput
    upsert?: Factura_EncabezadoUpsertWithoutDetallesInput
    connect?: Factura_EncabezadoWhereUniqueInput
    update?: XOR<Factura_EncabezadoUpdateWithoutDetallesInput, Factura_EncabezadoUncheckedUpdateWithoutDetallesInput>
  }

  export type ProductoUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<ProductoCreateWithoutDetallesInput, ProductoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetallesInput
    upsert?: ProductoUpsertWithoutDetallesInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<ProductoUpdateWithoutDetallesInput, ProductoUncheckedUpdateWithoutDetallesInput>
  }

  export type Pedido_ProductoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutPedidoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutPedidoInput>
    createMany?: Pedido_ProductoCreateManyPedidoInputEnvelope
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
  }

  export type UsuarioCreateNestedOneWithoutPedidosInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutPedidoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutPedidoInput>
    createMany?: Pedido_ProductoCreateManyPedidoInputEnvelope
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
  }

  export type Pedido_ProductoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutPedidoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<Pedido_ProductoUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: Pedido_ProductoCreateManyPedidoInputEnvelope
    set?: Enumerable<Pedido_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    delete?: Enumerable<Pedido_ProductoWhereUniqueInput>
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    update?: Enumerable<Pedido_ProductoUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<Pedido_ProductoUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<Pedido_ProductoScalarWhereInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    upsert?: UsuarioUpsertWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
  }

  export type Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutPedidoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<Pedido_ProductoUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: Pedido_ProductoCreateManyPedidoInputEnvelope
    set?: Enumerable<Pedido_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    delete?: Enumerable<Pedido_ProductoWhereUniqueInput>
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    update?: Enumerable<Pedido_ProductoUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<Pedido_ProductoUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<Pedido_ProductoScalarWhereInput>
  }

  export type PedidoCreateNestedOneWithoutProductosInput = {
    create?: XOR<PedidoCreateWithoutProductosInput, PedidoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutProductosInput
    connect?: PedidoWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutPedidosInput = {
    create?: XOR<ProductoCreateWithoutPedidosInput, ProductoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPedidosInput
    connect?: ProductoWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<PedidoCreateWithoutProductosInput, PedidoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutProductosInput
    upsert?: PedidoUpsertWithoutProductosInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<PedidoUpdateWithoutProductosInput, PedidoUncheckedUpdateWithoutProductosInput>
  }

  export type ProductoUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<ProductoCreateWithoutPedidosInput, ProductoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPedidosInput
    upsert?: ProductoUpsertWithoutPedidosInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<ProductoUpdateWithoutPedidosInput, ProductoUncheckedUpdateWithoutPedidosInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedEnumTipoTarjetaNullableFilter = {
    equals?: TipoTarjeta | null
    in?: Enumerable<TipoTarjeta> | null
    notIn?: Enumerable<TipoTarjeta> | null
    not?: NestedEnumTipoTarjetaNullableFilter | TipoTarjeta | null
  }

  export type NestedEnumTipoTarjetaNullableWithAggregatesFilter = {
    equals?: TipoTarjeta | null
    in?: Enumerable<TipoTarjeta> | null
    notIn?: Enumerable<TipoTarjeta> | null
    not?: NestedEnumTipoTarjetaNullableWithAggregatesFilter | TipoTarjeta | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumTipoTarjetaNullableFilter
    _max?: NestedEnumTipoTarjetaNullableFilter
  }

  export type UsuarioCreateWithoutPerfilInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    MeseroOnSucursal?: MeseroOnSucursalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPerfilInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPerfilInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPerfilInput, UsuarioUncheckedCreateWithoutPerfilInput>
  }

  export type UsuarioCreateManyPerfilInputEnvelope = {
    data: Enumerable<UsuarioCreateManyPerfilInput>
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithWhereUniqueWithoutPerfilInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutPerfilInput, UsuarioUncheckedUpdateWithoutPerfilInput>
    create: XOR<UsuarioCreateWithoutPerfilInput, UsuarioUncheckedCreateWithoutPerfilInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutPerfilInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutPerfilInput, UsuarioUncheckedUpdateWithoutPerfilInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutPerfilInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: Enumerable<UsuarioScalarWhereInput>
    OR?: Enumerable<UsuarioScalarWhereInput>
    NOT?: Enumerable<UsuarioScalarWhereInput>
    id?: StringFilter | string
    nombre?: StringFilter | string
    apellido1?: StringFilter | string
    apellido2?: StringFilter | string
    correo?: StringFilter | string
    username?: StringFilter | string
    clave?: StringFilter | string
    telefono?: StringFilter | string
    direccion?: StringNullableFilter | string | null
    idPerfil?: IntFilter | number
  }

  export type ReservacionCreateWithoutUsuarioInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    mesas?: Reservacion_MesaCreateNestedManyWithoutReservacionInput
    Sucursal: SucursalCreateNestedOneWithoutReservacionesInput
  }

  export type ReservacionUncheckedCreateWithoutUsuarioInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    mesas?: Reservacion_MesaUncheckedCreateNestedManyWithoutReservacionInput
    idSucursal: bigint | number
  }

  export type ReservacionCreateOrConnectWithoutUsuarioInput = {
    where: ReservacionWhereUniqueInput
    create: XOR<ReservacionCreateWithoutUsuarioInput, ReservacionUncheckedCreateWithoutUsuarioInput>
  }

  export type ReservacionCreateManyUsuarioInputEnvelope = {
    data: Enumerable<ReservacionCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type Factura_EncabezadoCreateWithoutUsuarioInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    detalles?: Factura_DetalleCreateNestedManyWithoutFactura_EncabezadoInput
    TipoPago: TipoPagoCreateNestedOneWithoutFacturasInput
  }

  export type Factura_EncabezadoUncheckedCreateWithoutUsuarioInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    idTipoPago: number
  }

  export type Factura_EncabezadoCreateOrConnectWithoutUsuarioInput = {
    where: Factura_EncabezadoWhereUniqueInput
    create: XOR<Factura_EncabezadoCreateWithoutUsuarioInput, Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>
  }

  export type Factura_EncabezadoCreateManyUsuarioInputEnvelope = {
    data: Enumerable<Factura_EncabezadoCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutUsuarioInput = {
    id?: bigint | number
    nombre?: string | null
    precio: Decimal | DecimalJsLike | number | string
    productos?: Pedido_ProductoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutUsuarioInput = {
    id?: bigint | number
    nombre?: string | null
    precio: Decimal | DecimalJsLike | number | string
    productos?: Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoCreateManyUsuarioInputEnvelope = {
    data: Enumerable<PedidoCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type PerfilCreateWithoutUsuariosInput = {
    id: number
    descripcion: string
  }

  export type PerfilUncheckedCreateWithoutUsuariosInput = {
    id: number
    descripcion: string
  }

  export type PerfilCreateOrConnectWithoutUsuariosInput = {
    where: PerfilWhereUniqueInput
    create: XOR<PerfilCreateWithoutUsuariosInput, PerfilUncheckedCreateWithoutUsuariosInput>
  }

  export type MeseroOnSucursalCreateWithoutUsuarioInput = {
    Sucursal: SucursalCreateNestedOneWithoutMeseroOnSucursalInput
  }

  export type MeseroOnSucursalUncheckedCreateWithoutUsuarioInput = {
    idSucursal: bigint | number
  }

  export type MeseroOnSucursalCreateOrConnectWithoutUsuarioInput = {
    where: MeseroOnSucursalWhereUniqueInput
    create: XOR<MeseroOnSucursalCreateWithoutUsuarioInput, MeseroOnSucursalUncheckedCreateWithoutUsuarioInput>
  }

  export type MeseroOnSucursalCreateManyUsuarioInputEnvelope = {
    data: Enumerable<MeseroOnSucursalCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type ReservacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ReservacionWhereUniqueInput
    update: XOR<ReservacionUpdateWithoutUsuarioInput, ReservacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ReservacionCreateWithoutUsuarioInput, ReservacionUncheckedCreateWithoutUsuarioInput>
  }

  export type ReservacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ReservacionWhereUniqueInput
    data: XOR<ReservacionUpdateWithoutUsuarioInput, ReservacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type ReservacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: ReservacionScalarWhereInput
    data: XOR<ReservacionUpdateManyMutationInput, ReservacionUncheckedUpdateManyWithoutReservacionesInput>
  }

  export type ReservacionScalarWhereInput = {
    AND?: Enumerable<ReservacionScalarWhereInput>
    OR?: Enumerable<ReservacionScalarWhereInput>
    NOT?: Enumerable<ReservacionScalarWhereInput>
    id?: BigIntFilter | bigint | number
    fecha_hora?: DateTimeFilter | Date | string
    idSucursal?: BigIntFilter | bigint | number
    idUsuario?: StringFilter | string
  }

  export type Factura_EncabezadoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: Factura_EncabezadoWhereUniqueInput
    update: XOR<Factura_EncabezadoUpdateWithoutUsuarioInput, Factura_EncabezadoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<Factura_EncabezadoCreateWithoutUsuarioInput, Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>
  }

  export type Factura_EncabezadoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: Factura_EncabezadoWhereUniqueInput
    data: XOR<Factura_EncabezadoUpdateWithoutUsuarioInput, Factura_EncabezadoUncheckedUpdateWithoutUsuarioInput>
  }

  export type Factura_EncabezadoUpdateManyWithWhereWithoutUsuarioInput = {
    where: Factura_EncabezadoScalarWhereInput
    data: XOR<Factura_EncabezadoUpdateManyMutationInput, Factura_EncabezadoUncheckedUpdateManyWithoutFacturasInput>
  }

  export type Factura_EncabezadoScalarWhereInput = {
    AND?: Enumerable<Factura_EncabezadoScalarWhereInput>
    OR?: Enumerable<Factura_EncabezadoScalarWhereInput>
    NOT?: Enumerable<Factura_EncabezadoScalarWhereInput>
    id?: BigIntFilter | bigint | number
    numero_tarjeta?: StringNullableFilter | string | null
    tarjeta?: EnumTipoTarjetaNullableFilter | TipoTarjeta | null
    fecha?: DateTimeFilter | Date | string
    estado?: BoolFilter | boolean
    idUsuario?: StringFilter | string
    idTipoPago?: IntFilter | number
  }

  export type PedidoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PedidoUpdateManyWithWhereWithoutUsuarioInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: Enumerable<PedidoScalarWhereInput>
    OR?: Enumerable<PedidoScalarWhereInput>
    NOT?: Enumerable<PedidoScalarWhereInput>
    id?: BigIntFilter | bigint | number
    nombre?: StringNullableFilter | string | null
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    idUsuario?: StringFilter | string
  }

  export type PerfilUpsertWithoutUsuariosInput = {
    update: XOR<PerfilUpdateWithoutUsuariosInput, PerfilUncheckedUpdateWithoutUsuariosInput>
    create: XOR<PerfilCreateWithoutUsuariosInput, PerfilUncheckedCreateWithoutUsuariosInput>
  }

  export type PerfilUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PerfilUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type MeseroOnSucursalUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: MeseroOnSucursalWhereUniqueInput
    update: XOR<MeseroOnSucursalUpdateWithoutUsuarioInput, MeseroOnSucursalUncheckedUpdateWithoutUsuarioInput>
    create: XOR<MeseroOnSucursalCreateWithoutUsuarioInput, MeseroOnSucursalUncheckedCreateWithoutUsuarioInput>
  }

  export type MeseroOnSucursalUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: MeseroOnSucursalWhereUniqueInput
    data: XOR<MeseroOnSucursalUpdateWithoutUsuarioInput, MeseroOnSucursalUncheckedUpdateWithoutUsuarioInput>
  }

  export type MeseroOnSucursalUpdateManyWithWhereWithoutUsuarioInput = {
    where: MeseroOnSucursalScalarWhereInput
    data: XOR<MeseroOnSucursalUpdateManyMutationInput, MeseroOnSucursalUncheckedUpdateManyWithoutMeseroOnSucursalInput>
  }

  export type MeseroOnSucursalScalarWhereInput = {
    AND?: Enumerable<MeseroOnSucursalScalarWhereInput>
    OR?: Enumerable<MeseroOnSucursalScalarWhereInput>
    NOT?: Enumerable<MeseroOnSucursalScalarWhereInput>
    idSucursal?: BigIntFilter | bigint | number
    idMesero?: StringFilter | string
  }

  export type SucursalCreateWithoutMeseroOnSucursalInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    mesas?: MesaCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionCreateNestedManyWithoutSucursalInput
    productos?: Sucursal_ProductoCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateWithoutMeseroOnSucursalInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    mesas?: MesaUncheckedCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutSucursalInput
    productos?: Sucursal_ProductoUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalCreateOrConnectWithoutMeseroOnSucursalInput = {
    where: SucursalWhereUniqueInput
    create: XOR<SucursalCreateWithoutMeseroOnSucursalInput, SucursalUncheckedCreateWithoutMeseroOnSucursalInput>
  }

  export type UsuarioCreateWithoutMeseroOnSucursalInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioUncheckedCreateWithoutMeseroOnSucursalInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    idPerfil: number
  }

  export type UsuarioCreateOrConnectWithoutMeseroOnSucursalInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutMeseroOnSucursalInput, UsuarioUncheckedCreateWithoutMeseroOnSucursalInput>
  }

  export type SucursalUpsertWithoutMeseroOnSucursalInput = {
    update: XOR<SucursalUpdateWithoutMeseroOnSucursalInput, SucursalUncheckedUpdateWithoutMeseroOnSucursalInput>
    create: XOR<SucursalCreateWithoutMeseroOnSucursalInput, SucursalUncheckedCreateWithoutMeseroOnSucursalInput>
  }

  export type SucursalUpdateWithoutMeseroOnSucursalInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    mesas?: MesaUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUpdateManyWithoutSucursalNestedInput
    productos?: Sucursal_ProductoUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateWithoutMeseroOnSucursalInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    mesas?: MesaUncheckedUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUncheckedUpdateManyWithoutSucursalNestedInput
    productos?: Sucursal_ProductoUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type UsuarioUpsertWithoutMeseroOnSucursalInput = {
    update: XOR<UsuarioUpdateWithoutMeseroOnSucursalInput, UsuarioUncheckedUpdateWithoutMeseroOnSucursalInput>
    create: XOR<UsuarioCreateWithoutMeseroOnSucursalInput, UsuarioUncheckedCreateWithoutMeseroOnSucursalInput>
  }

  export type UsuarioUpdateWithoutMeseroOnSucursalInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutMeseroOnSucursalInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
  }

  export type MesaCreateWithoutSucursalInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    reservaciones?: Reservacion_MesaCreateNestedManyWithoutMesaInput
    EstadoMesa: EstadoMesaCreateNestedOneWithoutMesasInput
  }

  export type MesaUncheckedCreateWithoutSucursalInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    reservaciones?: Reservacion_MesaUncheckedCreateNestedManyWithoutMesaInput
    idEstadoMesa: number
  }

  export type MesaCreateOrConnectWithoutSucursalInput = {
    where: MesaWhereUniqueInput
    create: XOR<MesaCreateWithoutSucursalInput, MesaUncheckedCreateWithoutSucursalInput>
  }

  export type MesaCreateManySucursalInputEnvelope = {
    data: Enumerable<MesaCreateManySucursalInput>
    skipDuplicates?: boolean
  }

  export type ReservacionCreateWithoutSucursalInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    mesas?: Reservacion_MesaCreateNestedManyWithoutReservacionInput
    Usuario: UsuarioCreateNestedOneWithoutReservacionesInput
  }

  export type ReservacionUncheckedCreateWithoutSucursalInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    mesas?: Reservacion_MesaUncheckedCreateNestedManyWithoutReservacionInput
    idUsuario: string
  }

  export type ReservacionCreateOrConnectWithoutSucursalInput = {
    where: ReservacionWhereUniqueInput
    create: XOR<ReservacionCreateWithoutSucursalInput, ReservacionUncheckedCreateWithoutSucursalInput>
  }

  export type ReservacionCreateManySucursalInputEnvelope = {
    data: Enumerable<ReservacionCreateManySucursalInput>
    skipDuplicates?: boolean
  }

  export type Sucursal_ProductoCreateWithoutSucursalInput = {
    Producto: ProductoCreateNestedOneWithoutSucursalesInput
  }

  export type Sucursal_ProductoUncheckedCreateWithoutSucursalInput = {
    idProducto: bigint | number
  }

  export type Sucursal_ProductoCreateOrConnectWithoutSucursalInput = {
    where: Sucursal_ProductoWhereUniqueInput
    create: XOR<Sucursal_ProductoCreateWithoutSucursalInput, Sucursal_ProductoUncheckedCreateWithoutSucursalInput>
  }

  export type Sucursal_ProductoCreateManySucursalInputEnvelope = {
    data: Enumerable<Sucursal_ProductoCreateManySucursalInput>
    skipDuplicates?: boolean
  }

  export type MeseroOnSucursalCreateWithoutSucursalInput = {
    Usuario: UsuarioCreateNestedOneWithoutMeseroOnSucursalInput
  }

  export type MeseroOnSucursalUncheckedCreateWithoutSucursalInput = {
    idMesero: string
  }

  export type MeseroOnSucursalCreateOrConnectWithoutSucursalInput = {
    where: MeseroOnSucursalWhereUniqueInput
    create: XOR<MeseroOnSucursalCreateWithoutSucursalInput, MeseroOnSucursalUncheckedCreateWithoutSucursalInput>
  }

  export type MeseroOnSucursalCreateManySucursalInputEnvelope = {
    data: Enumerable<MeseroOnSucursalCreateManySucursalInput>
    skipDuplicates?: boolean
  }

  export type MesaUpsertWithWhereUniqueWithoutSucursalInput = {
    where: MesaWhereUniqueInput
    update: XOR<MesaUpdateWithoutSucursalInput, MesaUncheckedUpdateWithoutSucursalInput>
    create: XOR<MesaCreateWithoutSucursalInput, MesaUncheckedCreateWithoutSucursalInput>
  }

  export type MesaUpdateWithWhereUniqueWithoutSucursalInput = {
    where: MesaWhereUniqueInput
    data: XOR<MesaUpdateWithoutSucursalInput, MesaUncheckedUpdateWithoutSucursalInput>
  }

  export type MesaUpdateManyWithWhereWithoutSucursalInput = {
    where: MesaScalarWhereInput
    data: XOR<MesaUpdateManyMutationInput, MesaUncheckedUpdateManyWithoutMesasInput>
  }

  export type MesaScalarWhereInput = {
    AND?: Enumerable<MesaScalarWhereInput>
    OR?: Enumerable<MesaScalarWhereInput>
    NOT?: Enumerable<MesaScalarWhereInput>
    id?: BigIntFilter | bigint | number
    codigo?: StringFilter | string
    capacidad?: IntFilter | number
    disponibilidad?: IntFilter | number
    estado?: BoolFilter | boolean
    idSucursal?: BigIntFilter | bigint | number
    idEstadoMesa?: IntFilter | number
  }

  export type ReservacionUpsertWithWhereUniqueWithoutSucursalInput = {
    where: ReservacionWhereUniqueInput
    update: XOR<ReservacionUpdateWithoutSucursalInput, ReservacionUncheckedUpdateWithoutSucursalInput>
    create: XOR<ReservacionCreateWithoutSucursalInput, ReservacionUncheckedCreateWithoutSucursalInput>
  }

  export type ReservacionUpdateWithWhereUniqueWithoutSucursalInput = {
    where: ReservacionWhereUniqueInput
    data: XOR<ReservacionUpdateWithoutSucursalInput, ReservacionUncheckedUpdateWithoutSucursalInput>
  }

  export type ReservacionUpdateManyWithWhereWithoutSucursalInput = {
    where: ReservacionScalarWhereInput
    data: XOR<ReservacionUpdateManyMutationInput, ReservacionUncheckedUpdateManyWithoutReservacionesInput>
  }

  export type Sucursal_ProductoUpsertWithWhereUniqueWithoutSucursalInput = {
    where: Sucursal_ProductoWhereUniqueInput
    update: XOR<Sucursal_ProductoUpdateWithoutSucursalInput, Sucursal_ProductoUncheckedUpdateWithoutSucursalInput>
    create: XOR<Sucursal_ProductoCreateWithoutSucursalInput, Sucursal_ProductoUncheckedCreateWithoutSucursalInput>
  }

  export type Sucursal_ProductoUpdateWithWhereUniqueWithoutSucursalInput = {
    where: Sucursal_ProductoWhereUniqueInput
    data: XOR<Sucursal_ProductoUpdateWithoutSucursalInput, Sucursal_ProductoUncheckedUpdateWithoutSucursalInput>
  }

  export type Sucursal_ProductoUpdateManyWithWhereWithoutSucursalInput = {
    where: Sucursal_ProductoScalarWhereInput
    data: XOR<Sucursal_ProductoUpdateManyMutationInput, Sucursal_ProductoUncheckedUpdateManyWithoutProductosInput>
  }

  export type Sucursal_ProductoScalarWhereInput = {
    AND?: Enumerable<Sucursal_ProductoScalarWhereInput>
    OR?: Enumerable<Sucursal_ProductoScalarWhereInput>
    NOT?: Enumerable<Sucursal_ProductoScalarWhereInput>
    idProducto?: BigIntFilter | bigint | number
    idSucursal?: BigIntFilter | bigint | number
  }

  export type MeseroOnSucursalUpsertWithWhereUniqueWithoutSucursalInput = {
    where: MeseroOnSucursalWhereUniqueInput
    update: XOR<MeseroOnSucursalUpdateWithoutSucursalInput, MeseroOnSucursalUncheckedUpdateWithoutSucursalInput>
    create: XOR<MeseroOnSucursalCreateWithoutSucursalInput, MeseroOnSucursalUncheckedCreateWithoutSucursalInput>
  }

  export type MeseroOnSucursalUpdateWithWhereUniqueWithoutSucursalInput = {
    where: MeseroOnSucursalWhereUniqueInput
    data: XOR<MeseroOnSucursalUpdateWithoutSucursalInput, MeseroOnSucursalUncheckedUpdateWithoutSucursalInput>
  }

  export type MeseroOnSucursalUpdateManyWithWhereWithoutSucursalInput = {
    where: MeseroOnSucursalScalarWhereInput
    data: XOR<MeseroOnSucursalUpdateManyMutationInput, MeseroOnSucursalUncheckedUpdateManyWithoutMeseroOnSucursalInput>
  }

  export type Reservacion_MesaCreateWithoutMesaInput = {
    Reservacion: ReservacionCreateNestedOneWithoutMesasInput
    cantidad: number
  }

  export type Reservacion_MesaUncheckedCreateWithoutMesaInput = {
    idReservacion: bigint | number
    cantidad: number
  }

  export type Reservacion_MesaCreateOrConnectWithoutMesaInput = {
    where: Reservacion_MesaWhereUniqueInput
    create: XOR<Reservacion_MesaCreateWithoutMesaInput, Reservacion_MesaUncheckedCreateWithoutMesaInput>
  }

  export type Reservacion_MesaCreateManyMesaInputEnvelope = {
    data: Enumerable<Reservacion_MesaCreateManyMesaInput>
    skipDuplicates?: boolean
  }

  export type SucursalCreateWithoutMesasInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    reservaciones?: ReservacionCreateNestedManyWithoutSucursalInput
    productos?: Sucursal_ProductoCreateNestedManyWithoutSucursalInput
    MeseroOnSucursal?: MeseroOnSucursalCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateWithoutMesasInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutSucursalInput
    productos?: Sucursal_ProductoUncheckedCreateNestedManyWithoutSucursalInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalCreateOrConnectWithoutMesasInput = {
    where: SucursalWhereUniqueInput
    create: XOR<SucursalCreateWithoutMesasInput, SucursalUncheckedCreateWithoutMesasInput>
  }

  export type EstadoMesaCreateWithoutMesasInput = {
    id: number
    descripcion: string
  }

  export type EstadoMesaUncheckedCreateWithoutMesasInput = {
    id: number
    descripcion: string
  }

  export type EstadoMesaCreateOrConnectWithoutMesasInput = {
    where: EstadoMesaWhereUniqueInput
    create: XOR<EstadoMesaCreateWithoutMesasInput, EstadoMesaUncheckedCreateWithoutMesasInput>
  }

  export type Reservacion_MesaUpsertWithWhereUniqueWithoutMesaInput = {
    where: Reservacion_MesaWhereUniqueInput
    update: XOR<Reservacion_MesaUpdateWithoutMesaInput, Reservacion_MesaUncheckedUpdateWithoutMesaInput>
    create: XOR<Reservacion_MesaCreateWithoutMesaInput, Reservacion_MesaUncheckedCreateWithoutMesaInput>
  }

  export type Reservacion_MesaUpdateWithWhereUniqueWithoutMesaInput = {
    where: Reservacion_MesaWhereUniqueInput
    data: XOR<Reservacion_MesaUpdateWithoutMesaInput, Reservacion_MesaUncheckedUpdateWithoutMesaInput>
  }

  export type Reservacion_MesaUpdateManyWithWhereWithoutMesaInput = {
    where: Reservacion_MesaScalarWhereInput
    data: XOR<Reservacion_MesaUpdateManyMutationInput, Reservacion_MesaUncheckedUpdateManyWithoutReservacionesInput>
  }

  export type Reservacion_MesaScalarWhereInput = {
    AND?: Enumerable<Reservacion_MesaScalarWhereInput>
    OR?: Enumerable<Reservacion_MesaScalarWhereInput>
    NOT?: Enumerable<Reservacion_MesaScalarWhereInput>
    idMesa?: BigIntFilter | bigint | number
    idReservacion?: BigIntFilter | bigint | number
    cantidad?: IntFilter | number
  }

  export type SucursalUpsertWithoutMesasInput = {
    update: XOR<SucursalUpdateWithoutMesasInput, SucursalUncheckedUpdateWithoutMesasInput>
    create: XOR<SucursalCreateWithoutMesasInput, SucursalUncheckedCreateWithoutMesasInput>
  }

  export type SucursalUpdateWithoutMesasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    reservaciones?: ReservacionUpdateManyWithoutSucursalNestedInput
    productos?: Sucursal_ProductoUpdateManyWithoutSucursalNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateWithoutMesasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    reservaciones?: ReservacionUncheckedUpdateManyWithoutSucursalNestedInput
    productos?: Sucursal_ProductoUncheckedUpdateManyWithoutSucursalNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type EstadoMesaUpsertWithoutMesasInput = {
    update: XOR<EstadoMesaUpdateWithoutMesasInput, EstadoMesaUncheckedUpdateWithoutMesasInput>
    create: XOR<EstadoMesaCreateWithoutMesasInput, EstadoMesaUncheckedCreateWithoutMesasInput>
  }

  export type EstadoMesaUpdateWithoutMesasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoMesaUncheckedUpdateWithoutMesasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type MesaCreateWithoutEstadoMesaInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    reservaciones?: Reservacion_MesaCreateNestedManyWithoutMesaInput
    Sucursal: SucursalCreateNestedOneWithoutMesasInput
  }

  export type MesaUncheckedCreateWithoutEstadoMesaInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    reservaciones?: Reservacion_MesaUncheckedCreateNestedManyWithoutMesaInput
    idSucursal: bigint | number
  }

  export type MesaCreateOrConnectWithoutEstadoMesaInput = {
    where: MesaWhereUniqueInput
    create: XOR<MesaCreateWithoutEstadoMesaInput, MesaUncheckedCreateWithoutEstadoMesaInput>
  }

  export type MesaCreateManyEstadoMesaInputEnvelope = {
    data: Enumerable<MesaCreateManyEstadoMesaInput>
    skipDuplicates?: boolean
  }

  export type MesaUpsertWithWhereUniqueWithoutEstadoMesaInput = {
    where: MesaWhereUniqueInput
    update: XOR<MesaUpdateWithoutEstadoMesaInput, MesaUncheckedUpdateWithoutEstadoMesaInput>
    create: XOR<MesaCreateWithoutEstadoMesaInput, MesaUncheckedCreateWithoutEstadoMesaInput>
  }

  export type MesaUpdateWithWhereUniqueWithoutEstadoMesaInput = {
    where: MesaWhereUniqueInput
    data: XOR<MesaUpdateWithoutEstadoMesaInput, MesaUncheckedUpdateWithoutEstadoMesaInput>
  }

  export type MesaUpdateManyWithWhereWithoutEstadoMesaInput = {
    where: MesaScalarWhereInput
    data: XOR<MesaUpdateManyMutationInput, MesaUncheckedUpdateManyWithoutMesasInput>
  }

  export type Reservacion_MesaCreateWithoutReservacionInput = {
    Mesa: MesaCreateNestedOneWithoutReservacionesInput
    cantidad: number
  }

  export type Reservacion_MesaUncheckedCreateWithoutReservacionInput = {
    idMesa: bigint | number
    cantidad: number
  }

  export type Reservacion_MesaCreateOrConnectWithoutReservacionInput = {
    where: Reservacion_MesaWhereUniqueInput
    create: XOR<Reservacion_MesaCreateWithoutReservacionInput, Reservacion_MesaUncheckedCreateWithoutReservacionInput>
  }

  export type Reservacion_MesaCreateManyReservacionInputEnvelope = {
    data: Enumerable<Reservacion_MesaCreateManyReservacionInput>
    skipDuplicates?: boolean
  }

  export type SucursalCreateWithoutReservacionesInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    mesas?: MesaCreateNestedManyWithoutSucursalInput
    productos?: Sucursal_ProductoCreateNestedManyWithoutSucursalInput
    MeseroOnSucursal?: MeseroOnSucursalCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateWithoutReservacionesInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    mesas?: MesaUncheckedCreateNestedManyWithoutSucursalInput
    productos?: Sucursal_ProductoUncheckedCreateNestedManyWithoutSucursalInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalCreateOrConnectWithoutReservacionesInput = {
    where: SucursalWhereUniqueInput
    create: XOR<SucursalCreateWithoutReservacionesInput, SucursalUncheckedCreateWithoutReservacionesInput>
  }

  export type UsuarioCreateWithoutReservacionesInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
    MeseroOnSucursal?: MeseroOnSucursalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutReservacionesInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    idPerfil: number
    MeseroOnSucursal?: MeseroOnSucursalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutReservacionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutReservacionesInput, UsuarioUncheckedCreateWithoutReservacionesInput>
  }

  export type Reservacion_MesaUpsertWithWhereUniqueWithoutReservacionInput = {
    where: Reservacion_MesaWhereUniqueInput
    update: XOR<Reservacion_MesaUpdateWithoutReservacionInput, Reservacion_MesaUncheckedUpdateWithoutReservacionInput>
    create: XOR<Reservacion_MesaCreateWithoutReservacionInput, Reservacion_MesaUncheckedCreateWithoutReservacionInput>
  }

  export type Reservacion_MesaUpdateWithWhereUniqueWithoutReservacionInput = {
    where: Reservacion_MesaWhereUniqueInput
    data: XOR<Reservacion_MesaUpdateWithoutReservacionInput, Reservacion_MesaUncheckedUpdateWithoutReservacionInput>
  }

  export type Reservacion_MesaUpdateManyWithWhereWithoutReservacionInput = {
    where: Reservacion_MesaScalarWhereInput
    data: XOR<Reservacion_MesaUpdateManyMutationInput, Reservacion_MesaUncheckedUpdateManyWithoutMesasInput>
  }

  export type SucursalUpsertWithoutReservacionesInput = {
    update: XOR<SucursalUpdateWithoutReservacionesInput, SucursalUncheckedUpdateWithoutReservacionesInput>
    create: XOR<SucursalCreateWithoutReservacionesInput, SucursalUncheckedCreateWithoutReservacionesInput>
  }

  export type SucursalUpdateWithoutReservacionesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    mesas?: MesaUpdateManyWithoutSucursalNestedInput
    productos?: Sucursal_ProductoUpdateManyWithoutSucursalNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateWithoutReservacionesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    mesas?: MesaUncheckedUpdateManyWithoutSucursalNestedInput
    productos?: Sucursal_ProductoUncheckedUpdateManyWithoutSucursalNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type UsuarioUpsertWithoutReservacionesInput = {
    update: XOR<UsuarioUpdateWithoutReservacionesInput, UsuarioUncheckedUpdateWithoutReservacionesInput>
    create: XOR<UsuarioCreateWithoutReservacionesInput, UsuarioUncheckedCreateWithoutReservacionesInput>
  }

  export type UsuarioUpdateWithoutReservacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutReservacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
    MeseroOnSucursal?: MeseroOnSucursalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type MesaCreateWithoutReservacionesInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    Sucursal: SucursalCreateNestedOneWithoutMesasInput
    EstadoMesa: EstadoMesaCreateNestedOneWithoutMesasInput
  }

  export type MesaUncheckedCreateWithoutReservacionesInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    idSucursal: bigint | number
    idEstadoMesa: number
  }

  export type MesaCreateOrConnectWithoutReservacionesInput = {
    where: MesaWhereUniqueInput
    create: XOR<MesaCreateWithoutReservacionesInput, MesaUncheckedCreateWithoutReservacionesInput>
  }

  export type ReservacionCreateWithoutMesasInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    Sucursal: SucursalCreateNestedOneWithoutReservacionesInput
    Usuario: UsuarioCreateNestedOneWithoutReservacionesInput
  }

  export type ReservacionUncheckedCreateWithoutMesasInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    idSucursal: bigint | number
    idUsuario: string
  }

  export type ReservacionCreateOrConnectWithoutMesasInput = {
    where: ReservacionWhereUniqueInput
    create: XOR<ReservacionCreateWithoutMesasInput, ReservacionUncheckedCreateWithoutMesasInput>
  }

  export type MesaUpsertWithoutReservacionesInput = {
    update: XOR<MesaUpdateWithoutReservacionesInput, MesaUncheckedUpdateWithoutReservacionesInput>
    create: XOR<MesaCreateWithoutReservacionesInput, MesaUncheckedCreateWithoutReservacionesInput>
  }

  export type MesaUpdateWithoutReservacionesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    Sucursal?: SucursalUpdateOneRequiredWithoutMesasNestedInput
    EstadoMesa?: EstadoMesaUpdateOneRequiredWithoutMesasNestedInput
  }

  export type MesaUncheckedUpdateWithoutReservacionesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
    idEstadoMesa?: IntFieldUpdateOperationsInput | number
  }

  export type ReservacionUpsertWithoutMesasInput = {
    update: XOR<ReservacionUpdateWithoutMesasInput, ReservacionUncheckedUpdateWithoutMesasInput>
    create: XOR<ReservacionCreateWithoutMesasInput, ReservacionUncheckedCreateWithoutMesasInput>
  }

  export type ReservacionUpdateWithoutMesasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    Sucursal?: SucursalUpdateOneRequiredWithoutReservacionesNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReservacionesNestedInput
  }

  export type ReservacionUncheckedUpdateWithoutMesasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoCreateWithoutCategoria_ProductoInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    detalles?: Factura_DetalleCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoCreateNestedManyWithoutProductoInput
    sucursales?: Sucursal_ProductoCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutCategoria_ProductoInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput
    sucursales?: Sucursal_ProductoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutCategoria_ProductoInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutCategoria_ProductoInput, ProductoUncheckedCreateWithoutCategoria_ProductoInput>
  }

  export type ProductoCreateManyCategoria_ProductoInputEnvelope = {
    data: Enumerable<ProductoCreateManyCategoria_ProductoInput>
    skipDuplicates?: boolean
  }

  export type ProductoUpsertWithWhereUniqueWithoutCategoria_ProductoInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutCategoria_ProductoInput, ProductoUncheckedUpdateWithoutCategoria_ProductoInput>
    create: XOR<ProductoCreateWithoutCategoria_ProductoInput, ProductoUncheckedCreateWithoutCategoria_ProductoInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutCategoria_ProductoInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutCategoria_ProductoInput, ProductoUncheckedUpdateWithoutCategoria_ProductoInput>
  }

  export type ProductoUpdateManyWithWhereWithoutCategoria_ProductoInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutProductosInput>
  }

  export type ProductoScalarWhereInput = {
    AND?: Enumerable<ProductoScalarWhereInput>
    OR?: Enumerable<ProductoScalarWhereInput>
    NOT?: Enumerable<ProductoScalarWhereInput>
    id?: BigIntFilter | bigint | number
    nombre?: StringFilter | string
    descripcion?: StringFilter | string
    ingredientes?: StringNullableFilter | string | null
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    imagen?: StringFilter | string
    estado?: IntFilter | number
    idCategoria?: IntFilter | number
  }

  export type Categoria_ProductoCreateWithoutProductosInput = {
    id: number
    descripcion: string
  }

  export type Categoria_ProductoUncheckedCreateWithoutProductosInput = {
    id: number
    descripcion: string
  }

  export type Categoria_ProductoCreateOrConnectWithoutProductosInput = {
    where: Categoria_ProductoWhereUniqueInput
    create: XOR<Categoria_ProductoCreateWithoutProductosInput, Categoria_ProductoUncheckedCreateWithoutProductosInput>
  }

  export type Factura_DetalleCreateWithoutProductoInput = {
    id?: bigint | number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    Factura_Encabezado: Factura_EncabezadoCreateNestedOneWithoutDetallesInput
  }

  export type Factura_DetalleUncheckedCreateWithoutProductoInput = {
    id?: bigint | number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idFactura_Encabezado: bigint | number
  }

  export type Factura_DetalleCreateOrConnectWithoutProductoInput = {
    where: Factura_DetalleWhereUniqueInput
    create: XOR<Factura_DetalleCreateWithoutProductoInput, Factura_DetalleUncheckedCreateWithoutProductoInput>
  }

  export type Factura_DetalleCreateManyProductoInputEnvelope = {
    data: Enumerable<Factura_DetalleCreateManyProductoInput>
    skipDuplicates?: boolean
  }

  export type Pedido_ProductoCreateWithoutProductoInput = {
    Pedido: PedidoCreateNestedOneWithoutProductosInput
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUncheckedCreateWithoutProductoInput = {
    idPedido: bigint | number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoCreateOrConnectWithoutProductoInput = {
    where: Pedido_ProductoWhereUniqueInput
    create: XOR<Pedido_ProductoCreateWithoutProductoInput, Pedido_ProductoUncheckedCreateWithoutProductoInput>
  }

  export type Pedido_ProductoCreateManyProductoInputEnvelope = {
    data: Enumerable<Pedido_ProductoCreateManyProductoInput>
    skipDuplicates?: boolean
  }

  export type Sucursal_ProductoCreateWithoutProductoInput = {
    Sucursal: SucursalCreateNestedOneWithoutProductosInput
  }

  export type Sucursal_ProductoUncheckedCreateWithoutProductoInput = {
    idSucursal: bigint | number
  }

  export type Sucursal_ProductoCreateOrConnectWithoutProductoInput = {
    where: Sucursal_ProductoWhereUniqueInput
    create: XOR<Sucursal_ProductoCreateWithoutProductoInput, Sucursal_ProductoUncheckedCreateWithoutProductoInput>
  }

  export type Sucursal_ProductoCreateManyProductoInputEnvelope = {
    data: Enumerable<Sucursal_ProductoCreateManyProductoInput>
    skipDuplicates?: boolean
  }

  export type Categoria_ProductoUpsertWithoutProductosInput = {
    update: XOR<Categoria_ProductoUpdateWithoutProductosInput, Categoria_ProductoUncheckedUpdateWithoutProductosInput>
    create: XOR<Categoria_ProductoCreateWithoutProductosInput, Categoria_ProductoUncheckedCreateWithoutProductosInput>
  }

  export type Categoria_ProductoUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Categoria_ProductoUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_DetalleUpsertWithWhereUniqueWithoutProductoInput = {
    where: Factura_DetalleWhereUniqueInput
    update: XOR<Factura_DetalleUpdateWithoutProductoInput, Factura_DetalleUncheckedUpdateWithoutProductoInput>
    create: XOR<Factura_DetalleCreateWithoutProductoInput, Factura_DetalleUncheckedCreateWithoutProductoInput>
  }

  export type Factura_DetalleUpdateWithWhereUniqueWithoutProductoInput = {
    where: Factura_DetalleWhereUniqueInput
    data: XOR<Factura_DetalleUpdateWithoutProductoInput, Factura_DetalleUncheckedUpdateWithoutProductoInput>
  }

  export type Factura_DetalleUpdateManyWithWhereWithoutProductoInput = {
    where: Factura_DetalleScalarWhereInput
    data: XOR<Factura_DetalleUpdateManyMutationInput, Factura_DetalleUncheckedUpdateManyWithoutDetallesInput>
  }

  export type Factura_DetalleScalarWhereInput = {
    AND?: Enumerable<Factura_DetalleScalarWhereInput>
    OR?: Enumerable<Factura_DetalleScalarWhereInput>
    NOT?: Enumerable<Factura_DetalleScalarWhereInput>
    id?: BigIntFilter | bigint | number
    cantidad?: IntFilter | number
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFilter | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFilter | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: BigIntFilter | bigint | number
    idProducto?: BigIntFilter | bigint | number
  }

  export type Pedido_ProductoUpsertWithWhereUniqueWithoutProductoInput = {
    where: Pedido_ProductoWhereUniqueInput
    update: XOR<Pedido_ProductoUpdateWithoutProductoInput, Pedido_ProductoUncheckedUpdateWithoutProductoInput>
    create: XOR<Pedido_ProductoCreateWithoutProductoInput, Pedido_ProductoUncheckedCreateWithoutProductoInput>
  }

  export type Pedido_ProductoUpdateWithWhereUniqueWithoutProductoInput = {
    where: Pedido_ProductoWhereUniqueInput
    data: XOR<Pedido_ProductoUpdateWithoutProductoInput, Pedido_ProductoUncheckedUpdateWithoutProductoInput>
  }

  export type Pedido_ProductoUpdateManyWithWhereWithoutProductoInput = {
    where: Pedido_ProductoScalarWhereInput
    data: XOR<Pedido_ProductoUpdateManyMutationInput, Pedido_ProductoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type Pedido_ProductoScalarWhereInput = {
    AND?: Enumerable<Pedido_ProductoScalarWhereInput>
    OR?: Enumerable<Pedido_ProductoScalarWhereInput>
    NOT?: Enumerable<Pedido_ProductoScalarWhereInput>
    idPedido?: BigIntFilter | bigint | number
    idProducto?: BigIntFilter | bigint | number
    cantidad?: IntFilter | number
    notas?: StringFilter | string
  }

  export type Sucursal_ProductoUpsertWithWhereUniqueWithoutProductoInput = {
    where: Sucursal_ProductoWhereUniqueInput
    update: XOR<Sucursal_ProductoUpdateWithoutProductoInput, Sucursal_ProductoUncheckedUpdateWithoutProductoInput>
    create: XOR<Sucursal_ProductoCreateWithoutProductoInput, Sucursal_ProductoUncheckedCreateWithoutProductoInput>
  }

  export type Sucursal_ProductoUpdateWithWhereUniqueWithoutProductoInput = {
    where: Sucursal_ProductoWhereUniqueInput
    data: XOR<Sucursal_ProductoUpdateWithoutProductoInput, Sucursal_ProductoUncheckedUpdateWithoutProductoInput>
  }

  export type Sucursal_ProductoUpdateManyWithWhereWithoutProductoInput = {
    where: Sucursal_ProductoScalarWhereInput
    data: XOR<Sucursal_ProductoUpdateManyMutationInput, Sucursal_ProductoUncheckedUpdateManyWithoutSucursalesInput>
  }

  export type ProductoCreateWithoutSucursalesInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    Categoria_Producto: Categoria_ProductoCreateNestedOneWithoutProductosInput
    detalles?: Factura_DetalleCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutSucursalesInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    idCategoria: number
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutSucursalesInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutSucursalesInput, ProductoUncheckedCreateWithoutSucursalesInput>
  }

  export type SucursalCreateWithoutProductosInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    mesas?: MesaCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionCreateNestedManyWithoutSucursalInput
    MeseroOnSucursal?: MeseroOnSucursalCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateWithoutProductosInput = {
    id: bigint | number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: bigint | number
    mesas?: MesaUncheckedCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutSucursalInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalCreateOrConnectWithoutProductosInput = {
    where: SucursalWhereUniqueInput
    create: XOR<SucursalCreateWithoutProductosInput, SucursalUncheckedCreateWithoutProductosInput>
  }

  export type ProductoUpsertWithoutSucursalesInput = {
    update: XOR<ProductoUpdateWithoutSucursalesInput, ProductoUncheckedUpdateWithoutSucursalesInput>
    create: XOR<ProductoCreateWithoutSucursalesInput, ProductoUncheckedCreateWithoutSucursalesInput>
  }

  export type ProductoUpdateWithoutSucursalesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    Categoria_Producto?: Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput
    detalles?: Factura_DetalleUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutSucursalesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    idCategoria?: IntFieldUpdateOperationsInput | number
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type SucursalUpsertWithoutProductosInput = {
    update: XOR<SucursalUpdateWithoutProductosInput, SucursalUncheckedUpdateWithoutProductosInput>
    create: XOR<SucursalCreateWithoutProductosInput, SucursalUncheckedCreateWithoutProductosInput>
  }

  export type SucursalUpdateWithoutProductosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    mesas?: MesaUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUpdateManyWithoutSucursalNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateWithoutProductosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: BigIntFieldUpdateOperationsInput | bigint | number
    mesas?: MesaUncheckedUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUncheckedUpdateManyWithoutSucursalNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type Factura_EncabezadoCreateWithoutTipoPagoInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    detalles?: Factura_DetalleCreateNestedManyWithoutFactura_EncabezadoInput
    Usuario: UsuarioCreateNestedOneWithoutFacturasInput
  }

  export type Factura_EncabezadoUncheckedCreateWithoutTipoPagoInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    idUsuario: string
  }

  export type Factura_EncabezadoCreateOrConnectWithoutTipoPagoInput = {
    where: Factura_EncabezadoWhereUniqueInput
    create: XOR<Factura_EncabezadoCreateWithoutTipoPagoInput, Factura_EncabezadoUncheckedCreateWithoutTipoPagoInput>
  }

  export type Factura_EncabezadoCreateManyTipoPagoInputEnvelope = {
    data: Enumerable<Factura_EncabezadoCreateManyTipoPagoInput>
    skipDuplicates?: boolean
  }

  export type Factura_EncabezadoUpsertWithWhereUniqueWithoutTipoPagoInput = {
    where: Factura_EncabezadoWhereUniqueInput
    update: XOR<Factura_EncabezadoUpdateWithoutTipoPagoInput, Factura_EncabezadoUncheckedUpdateWithoutTipoPagoInput>
    create: XOR<Factura_EncabezadoCreateWithoutTipoPagoInput, Factura_EncabezadoUncheckedCreateWithoutTipoPagoInput>
  }

  export type Factura_EncabezadoUpdateWithWhereUniqueWithoutTipoPagoInput = {
    where: Factura_EncabezadoWhereUniqueInput
    data: XOR<Factura_EncabezadoUpdateWithoutTipoPagoInput, Factura_EncabezadoUncheckedUpdateWithoutTipoPagoInput>
  }

  export type Factura_EncabezadoUpdateManyWithWhereWithoutTipoPagoInput = {
    where: Factura_EncabezadoScalarWhereInput
    data: XOR<Factura_EncabezadoUpdateManyMutationInput, Factura_EncabezadoUncheckedUpdateManyWithoutFacturasInput>
  }

  export type Factura_DetalleCreateWithoutFactura_EncabezadoInput = {
    id?: bigint | number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    Producto: ProductoCreateNestedOneWithoutDetallesInput
  }

  export type Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput = {
    id?: bigint | number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idProducto: bigint | number
  }

  export type Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput = {
    where: Factura_DetalleWhereUniqueInput
    create: XOR<Factura_DetalleCreateWithoutFactura_EncabezadoInput, Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>
  }

  export type Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope = {
    data: Enumerable<Factura_DetalleCreateManyFactura_EncabezadoInput>
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutFacturasInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
    MeseroOnSucursal?: MeseroOnSucursalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutFacturasInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    idPerfil: number
    MeseroOnSucursal?: MeseroOnSucursalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutFacturasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutFacturasInput, UsuarioUncheckedCreateWithoutFacturasInput>
  }

  export type TipoPagoCreateWithoutFacturasInput = {
    id: number
    descripcion: string
  }

  export type TipoPagoUncheckedCreateWithoutFacturasInput = {
    id: number
    descripcion: string
  }

  export type TipoPagoCreateOrConnectWithoutFacturasInput = {
    where: TipoPagoWhereUniqueInput
    create: XOR<TipoPagoCreateWithoutFacturasInput, TipoPagoUncheckedCreateWithoutFacturasInput>
  }

  export type Factura_DetalleUpsertWithWhereUniqueWithoutFactura_EncabezadoInput = {
    where: Factura_DetalleWhereUniqueInput
    update: XOR<Factura_DetalleUpdateWithoutFactura_EncabezadoInput, Factura_DetalleUncheckedUpdateWithoutFactura_EncabezadoInput>
    create: XOR<Factura_DetalleCreateWithoutFactura_EncabezadoInput, Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>
  }

  export type Factura_DetalleUpdateWithWhereUniqueWithoutFactura_EncabezadoInput = {
    where: Factura_DetalleWhereUniqueInput
    data: XOR<Factura_DetalleUpdateWithoutFactura_EncabezadoInput, Factura_DetalleUncheckedUpdateWithoutFactura_EncabezadoInput>
  }

  export type Factura_DetalleUpdateManyWithWhereWithoutFactura_EncabezadoInput = {
    where: Factura_DetalleScalarWhereInput
    data: XOR<Factura_DetalleUpdateManyMutationInput, Factura_DetalleUncheckedUpdateManyWithoutDetallesInput>
  }

  export type UsuarioUpsertWithoutFacturasInput = {
    update: XOR<UsuarioUpdateWithoutFacturasInput, UsuarioUncheckedUpdateWithoutFacturasInput>
    create: XOR<UsuarioCreateWithoutFacturasInput, UsuarioUncheckedCreateWithoutFacturasInput>
  }

  export type UsuarioUpdateWithoutFacturasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutFacturasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
    MeseroOnSucursal?: MeseroOnSucursalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type TipoPagoUpsertWithoutFacturasInput = {
    update: XOR<TipoPagoUpdateWithoutFacturasInput, TipoPagoUncheckedUpdateWithoutFacturasInput>
    create: XOR<TipoPagoCreateWithoutFacturasInput, TipoPagoUncheckedCreateWithoutFacturasInput>
  }

  export type TipoPagoUpdateWithoutFacturasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoPagoUncheckedUpdateWithoutFacturasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_EncabezadoCreateWithoutDetallesInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    Usuario: UsuarioCreateNestedOneWithoutFacturasInput
    TipoPago: TipoPagoCreateNestedOneWithoutFacturasInput
  }

  export type Factura_EncabezadoUncheckedCreateWithoutDetallesInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    idUsuario: string
    idTipoPago: number
  }

  export type Factura_EncabezadoCreateOrConnectWithoutDetallesInput = {
    where: Factura_EncabezadoWhereUniqueInput
    create: XOR<Factura_EncabezadoCreateWithoutDetallesInput, Factura_EncabezadoUncheckedCreateWithoutDetallesInput>
  }

  export type ProductoCreateWithoutDetallesInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    Categoria_Producto: Categoria_ProductoCreateNestedOneWithoutProductosInput
    pedidos?: Pedido_ProductoCreateNestedManyWithoutProductoInput
    sucursales?: Sucursal_ProductoCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutDetallesInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    idCategoria: number
    pedidos?: Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput
    sucursales?: Sucursal_ProductoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutDetallesInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutDetallesInput, ProductoUncheckedCreateWithoutDetallesInput>
  }

  export type Factura_EncabezadoUpsertWithoutDetallesInput = {
    update: XOR<Factura_EncabezadoUpdateWithoutDetallesInput, Factura_EncabezadoUncheckedUpdateWithoutDetallesInput>
    create: XOR<Factura_EncabezadoCreateWithoutDetallesInput, Factura_EncabezadoUncheckedCreateWithoutDetallesInput>
  }

  export type Factura_EncabezadoUpdateWithoutDetallesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Usuario?: UsuarioUpdateOneRequiredWithoutFacturasNestedInput
    TipoPago?: TipoPagoUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateWithoutDetallesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idUsuario?: StringFieldUpdateOperationsInput | string
    idTipoPago?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoUpsertWithoutDetallesInput = {
    update: XOR<ProductoUpdateWithoutDetallesInput, ProductoUncheckedUpdateWithoutDetallesInput>
    create: XOR<ProductoCreateWithoutDetallesInput, ProductoUncheckedCreateWithoutDetallesInput>
  }

  export type ProductoUpdateWithoutDetallesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    Categoria_Producto?: Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput
    pedidos?: Pedido_ProductoUpdateManyWithoutProductoNestedInput
    sucursales?: Sucursal_ProductoUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutDetallesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    idCategoria?: IntFieldUpdateOperationsInput | number
    pedidos?: Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput
    sucursales?: Sucursal_ProductoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type Pedido_ProductoCreateWithoutPedidoInput = {
    Producto: ProductoCreateNestedOneWithoutPedidosInput
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUncheckedCreateWithoutPedidoInput = {
    idProducto: bigint | number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoCreateOrConnectWithoutPedidoInput = {
    where: Pedido_ProductoWhereUniqueInput
    create: XOR<Pedido_ProductoCreateWithoutPedidoInput, Pedido_ProductoUncheckedCreateWithoutPedidoInput>
  }

  export type Pedido_ProductoCreateManyPedidoInputEnvelope = {
    data: Enumerable<Pedido_ProductoCreateManyPedidoInput>
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutPedidosInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
    MeseroOnSucursal?: MeseroOnSucursalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPedidosInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    idPerfil: number
    MeseroOnSucursal?: MeseroOnSucursalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPedidosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type Pedido_ProductoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: Pedido_ProductoWhereUniqueInput
    update: XOR<Pedido_ProductoUpdateWithoutPedidoInput, Pedido_ProductoUncheckedUpdateWithoutPedidoInput>
    create: XOR<Pedido_ProductoCreateWithoutPedidoInput, Pedido_ProductoUncheckedCreateWithoutPedidoInput>
  }

  export type Pedido_ProductoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: Pedido_ProductoWhereUniqueInput
    data: XOR<Pedido_ProductoUpdateWithoutPedidoInput, Pedido_ProductoUncheckedUpdateWithoutPedidoInput>
  }

  export type Pedido_ProductoUpdateManyWithWhereWithoutPedidoInput = {
    where: Pedido_ProductoScalarWhereInput
    data: XOR<Pedido_ProductoUpdateManyMutationInput, Pedido_ProductoUncheckedUpdateManyWithoutProductosInput>
  }

  export type UsuarioUpsertWithoutPedidosInput = {
    update: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type UsuarioUpdateWithoutPedidosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPedidosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
    MeseroOnSucursal?: MeseroOnSucursalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PedidoCreateWithoutProductosInput = {
    id?: bigint | number
    nombre?: string | null
    precio: Decimal | DecimalJsLike | number | string
    Usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutProductosInput = {
    id?: bigint | number
    nombre?: string | null
    precio: Decimal | DecimalJsLike | number | string
    idUsuario: string
  }

  export type PedidoCreateOrConnectWithoutProductosInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutProductosInput, PedidoUncheckedCreateWithoutProductosInput>
  }

  export type ProductoCreateWithoutPedidosInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    Categoria_Producto: Categoria_ProductoCreateNestedOneWithoutProductosInput
    detalles?: Factura_DetalleCreateNestedManyWithoutProductoInput
    sucursales?: Sucursal_ProductoCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutPedidosInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
    idCategoria: number
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput
    sucursales?: Sucursal_ProductoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutPedidosInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutPedidosInput, ProductoUncheckedCreateWithoutPedidosInput>
  }

  export type PedidoUpsertWithoutProductosInput = {
    update: XOR<PedidoUpdateWithoutProductosInput, PedidoUncheckedUpdateWithoutProductosInput>
    create: XOR<PedidoCreateWithoutProductosInput, PedidoUncheckedCreateWithoutProductosInput>
  }

  export type PedidoUpdateWithoutProductosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutProductosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoUpsertWithoutPedidosInput = {
    update: XOR<ProductoUpdateWithoutPedidosInput, ProductoUncheckedUpdateWithoutPedidosInput>
    create: XOR<ProductoCreateWithoutPedidosInput, ProductoUncheckedCreateWithoutPedidosInput>
  }

  export type ProductoUpdateWithoutPedidosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    Categoria_Producto?: Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput
    detalles?: Factura_DetalleUpdateManyWithoutProductoNestedInput
    sucursales?: Sucursal_ProductoUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutPedidosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    idCategoria?: IntFieldUpdateOperationsInput | number
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput
    sucursales?: Sucursal_ProductoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type UsuarioCreateManyPerfilInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
  }

  export type UsuarioUpdateWithoutPerfilInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPerfilInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    MeseroOnSucursal?: MeseroOnSucursalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservacionCreateManyUsuarioInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    idSucursal: bigint | number
  }

  export type Factura_EncabezadoCreateManyUsuarioInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    idTipoPago: number
  }

  export type PedidoCreateManyUsuarioInput = {
    id?: bigint | number
    nombre?: string | null
    precio: Decimal | DecimalJsLike | number | string
  }

  export type MeseroOnSucursalCreateManyUsuarioInput = {
    idSucursal: bigint | number
  }

  export type ReservacionUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    mesas?: Reservacion_MesaUpdateManyWithoutReservacionNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutReservacionesNestedInput
  }

  export type ReservacionUncheckedUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    mesas?: Reservacion_MesaUncheckedUpdateManyWithoutReservacionNestedInput
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ReservacionUncheckedUpdateManyWithoutReservacionesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Factura_EncabezadoUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUpdateManyWithoutFactura_EncabezadoNestedInput
    TipoPago?: TipoPagoUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    idTipoPago?: IntFieldUpdateOperationsInput | number
  }

  export type Factura_EncabezadoUncheckedUpdateManyWithoutFacturasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idTipoPago?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productos?: Pedido_ProductoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productos?: Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutPedidosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type MeseroOnSucursalUpdateWithoutUsuarioInput = {
    Sucursal?: SucursalUpdateOneRequiredWithoutMeseroOnSucursalNestedInput
  }

  export type MeseroOnSucursalUncheckedUpdateWithoutUsuarioInput = {
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MeseroOnSucursalUncheckedUpdateManyWithoutMeseroOnSucursalInput = {
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MesaCreateManySucursalInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    idEstadoMesa: number
  }

  export type ReservacionCreateManySucursalInput = {
    id?: bigint | number
    fecha_hora?: Date | string
    idUsuario: string
  }

  export type Sucursal_ProductoCreateManySucursalInput = {
    idProducto: bigint | number
  }

  export type MeseroOnSucursalCreateManySucursalInput = {
    idMesero: string
  }

  export type MesaUpdateWithoutSucursalInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: Reservacion_MesaUpdateManyWithoutMesaNestedInput
    EstadoMesa?: EstadoMesaUpdateOneRequiredWithoutMesasNestedInput
  }

  export type MesaUncheckedUpdateWithoutSucursalInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: Reservacion_MesaUncheckedUpdateManyWithoutMesaNestedInput
    idEstadoMesa?: IntFieldUpdateOperationsInput | number
  }

  export type MesaUncheckedUpdateManyWithoutMesasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    idEstadoMesa?: IntFieldUpdateOperationsInput | number
  }

  export type ReservacionUpdateWithoutSucursalInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    mesas?: Reservacion_MesaUpdateManyWithoutReservacionNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReservacionesNestedInput
  }

  export type ReservacionUncheckedUpdateWithoutSucursalInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    mesas?: Reservacion_MesaUncheckedUpdateManyWithoutReservacionNestedInput
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type Sucursal_ProductoUpdateWithoutSucursalInput = {
    Producto?: ProductoUpdateOneRequiredWithoutSucursalesNestedInput
  }

  export type Sucursal_ProductoUncheckedUpdateWithoutSucursalInput = {
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Sucursal_ProductoUncheckedUpdateManyWithoutProductosInput = {
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MeseroOnSucursalUpdateWithoutSucursalInput = {
    Usuario?: UsuarioUpdateOneRequiredWithoutMeseroOnSucursalNestedInput
  }

  export type MeseroOnSucursalUncheckedUpdateWithoutSucursalInput = {
    idMesero?: StringFieldUpdateOperationsInput | string
  }

  export type Reservacion_MesaCreateManyMesaInput = {
    idReservacion: bigint | number
    cantidad: number
  }

  export type Reservacion_MesaUpdateWithoutMesaInput = {
    Reservacion?: ReservacionUpdateOneRequiredWithoutMesasNestedInput
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type Reservacion_MesaUncheckedUpdateWithoutMesaInput = {
    idReservacion?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type Reservacion_MesaUncheckedUpdateManyWithoutReservacionesInput = {
    idReservacion?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type MesaCreateManyEstadoMesaInput = {
    id?: bigint | number
    codigo: string
    capacidad: number
    disponibilidad?: number
    estado: boolean
    idSucursal: bigint | number
  }

  export type MesaUpdateWithoutEstadoMesaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: Reservacion_MesaUpdateManyWithoutMesaNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutMesasNestedInput
  }

  export type MesaUncheckedUpdateWithoutEstadoMesaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    disponibilidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: Reservacion_MesaUncheckedUpdateManyWithoutMesaNestedInput
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Reservacion_MesaCreateManyReservacionInput = {
    idMesa: bigint | number
    cantidad: number
  }

  export type Reservacion_MesaUpdateWithoutReservacionInput = {
    Mesa?: MesaUpdateOneRequiredWithoutReservacionesNestedInput
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type Reservacion_MesaUncheckedUpdateWithoutReservacionInput = {
    idMesa?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type Reservacion_MesaUncheckedUpdateManyWithoutMesasInput = {
    idMesa?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoCreateManyCategoria_ProductoInput = {
    id: bigint | number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado: number
  }

  export type ProductoUpdateWithoutCategoria_ProductoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    detalles?: Factura_DetalleUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUpdateManyWithoutProductoNestedInput
    sucursales?: Sucursal_ProductoUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutCategoria_ProductoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput
    sucursales?: Sucursal_ProductoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateManyWithoutProductosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: IntFieldUpdateOperationsInput | number
  }

  export type Factura_DetalleCreateManyProductoInput = {
    id?: bigint | number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idFactura_Encabezado: bigint | number
  }

  export type Pedido_ProductoCreateManyProductoInput = {
    idPedido: bigint | number
    cantidad?: number
    notas: string
  }

  export type Sucursal_ProductoCreateManyProductoInput = {
    idSucursal: bigint | number
  }

  export type Factura_DetalleUpdateWithoutProductoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Factura_Encabezado?: Factura_EncabezadoUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type Factura_DetalleUncheckedUpdateWithoutProductoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Factura_DetalleUncheckedUpdateManyWithoutDetallesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Pedido_ProductoUpdateWithoutProductoInput = {
    Pedido?: PedidoUpdateOneRequiredWithoutProductosNestedInput
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateWithoutProductoInput = {
    idPedido?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateManyWithoutPedidosInput = {
    idPedido?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Sucursal_ProductoUpdateWithoutProductoInput = {
    Sucursal?: SucursalUpdateOneRequiredWithoutProductosNestedInput
  }

  export type Sucursal_ProductoUncheckedUpdateWithoutProductoInput = {
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Sucursal_ProductoUncheckedUpdateManyWithoutSucursalesInput = {
    idSucursal?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Factura_EncabezadoCreateManyTipoPagoInput = {
    id?: bigint | number
    numero_tarjeta?: string | null
    tarjeta?: TipoTarjeta | null
    fecha?: Date | string
    estado: boolean
    idUsuario: string
  }

  export type Factura_EncabezadoUpdateWithoutTipoPagoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUpdateManyWithoutFactura_EncabezadoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateWithoutTipoPagoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    tarjeta?: NullableEnumTipoTarjetaFieldUpdateOperationsInput | TipoTarjeta | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_DetalleCreateManyFactura_EncabezadoInput = {
    id?: bigint | number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idProducto: bigint | number
  }

  export type Factura_DetalleUpdateWithoutFactura_EncabezadoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Producto?: ProductoUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type Factura_DetalleUncheckedUpdateWithoutFactura_EncabezadoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Pedido_ProductoCreateManyPedidoInput = {
    idProducto: bigint | number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUpdateWithoutPedidoInput = {
    Producto?: ProductoUpdateOneRequiredWithoutPedidosNestedInput
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateWithoutPedidoInput = {
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateManyWithoutProductosInput = {
    idProducto?: BigIntFieldUpdateOperationsInput | bigint | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}