
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Perfil
 * 
 */
export type Perfil = {
  id: number
  descripcion: string
}

/**
 * Model Usuario
 * 
 */
export type Usuario = {
  id: string
  nombre: string
  apellido1: string
  apellido2: string
  correo: string
  username: string
  clave: string
  telefono: string
  direccion: string | null
  idPerfil: number
}

/**
 * Model Sucursal
 * 
 */
export type Sucursal = {
  id: number
  codigo: string
  nombre: string
  ubicacion: string
  capacidad: number
}

/**
 * Model Mesa
 * 
 */
export type Mesa = {
  id: number
  codigo: string
  capacidad: number
  estado: boolean
  idSucursal: number
  idDisponibilidad: number
}

/**
 * Model DisponibilidadMesa
 * 
 */
export type DisponibilidadMesa = {
  id: number
  descripcion: string
}

/**
 * Model Reservacion
 * 
 */
export type Reservacion = {
  id: number
  fecha_hora: Date
  cantidad: number
  idSucursal: number
  idUsuario: string
}

/**
 * Model Categoria_Producto
 * 
 */
export type Categoria_Producto = {
  id: number
  descripcion: string
}

/**
 * Model Producto
 * 
 */
export type Producto = {
  id: number
  nombre: string
  descripcion: string
  ingredientes: string | null
  precio: Prisma.Decimal
  imagen: string
  estado: boolean
  idCategoria: number
}

/**
 * Model TipoPago
 * 
 */
export type TipoPago = {
  id: number
  descripcion: string
}

/**
 * Model TipoTarjeta
 * 
 */
export type TipoTarjeta = {
  id: number
  descripcion: string
}

/**
 * Model Factura_Encabezado
 * 
 */
export type Factura_Encabezado = {
  id: number
  numero_tarjeta: string | null
  idTipoTarjeta: number | null
  fecha: Date
  estado: boolean
  idUsuario: string
}

/**
 * Model Factura_Detalle
 * 
 */
export type Factura_Detalle = {
  id: number
  cantidad: number
  precio: Prisma.Decimal
  impuesto: Prisma.Decimal
  total_detalle: Prisma.Decimal
  idFactura_Encabezado: number
  idProducto: number
}

/**
 * Model FacturaEncabezadoTipoPago
 * 
 */
export type FacturaEncabezadoTipoPago = {
  idFactura_Encabezado: number
  idTipoPago: number
  monto: Prisma.Decimal
}

/**
 * Model EstadoPedido
 * 
 */
export type EstadoPedido = {
  id: number
  descripcion: string
}

/**
 * Model TipoPedido
 * 
 */
export type TipoPedido = {
  id: number
  descripcion: string
}

/**
 * Model Pedido
 * 
 */
export type Pedido = {
  id: number
  nombre: string | null
  precio: Prisma.Decimal
  fecha: Date
  idEstado: number
  idCliente: string
  idMesero: string | null
  idSucursal: number
  idMesa: number | null
  idTipoPedido: number
}

/**
 * Model Pedido_Producto
 * 
 */
export type Pedido_Producto = {
  idPedido: number
  idProducto: number
  cantidad: number
  notas: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Perfils
 * const perfils = await prisma.perfil.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Perfils
   * const perfils = await prisma.perfil.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.perfil`: Exposes CRUD operations for the **Perfil** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Perfils
    * const perfils = await prisma.perfil.findMany()
    * ```
    */
  get perfil(): Prisma.PerfilDelegate<GlobalReject>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<GlobalReject>;

  /**
   * `prisma.sucursal`: Exposes CRUD operations for the **Sucursal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sucursals
    * const sucursals = await prisma.sucursal.findMany()
    * ```
    */
  get sucursal(): Prisma.SucursalDelegate<GlobalReject>;

  /**
   * `prisma.mesa`: Exposes CRUD operations for the **Mesa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mesas
    * const mesas = await prisma.mesa.findMany()
    * ```
    */
  get mesa(): Prisma.MesaDelegate<GlobalReject>;

  /**
   * `prisma.disponibilidadMesa`: Exposes CRUD operations for the **DisponibilidadMesa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisponibilidadMesas
    * const disponibilidadMesas = await prisma.disponibilidadMesa.findMany()
    * ```
    */
  get disponibilidadMesa(): Prisma.DisponibilidadMesaDelegate<GlobalReject>;

  /**
   * `prisma.reservacion`: Exposes CRUD operations for the **Reservacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservacions
    * const reservacions = await prisma.reservacion.findMany()
    * ```
    */
  get reservacion(): Prisma.ReservacionDelegate<GlobalReject>;

  /**
   * `prisma.categoria_Producto`: Exposes CRUD operations for the **Categoria_Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categoria_Productos
    * const categoria_Productos = await prisma.categoria_Producto.findMany()
    * ```
    */
  get categoria_Producto(): Prisma.Categoria_ProductoDelegate<GlobalReject>;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.ProductoDelegate<GlobalReject>;

  /**
   * `prisma.tipoPago`: Exposes CRUD operations for the **TipoPago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoPagos
    * const tipoPagos = await prisma.tipoPago.findMany()
    * ```
    */
  get tipoPago(): Prisma.TipoPagoDelegate<GlobalReject>;

  /**
   * `prisma.tipoTarjeta`: Exposes CRUD operations for the **TipoTarjeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoTarjetas
    * const tipoTarjetas = await prisma.tipoTarjeta.findMany()
    * ```
    */
  get tipoTarjeta(): Prisma.TipoTarjetaDelegate<GlobalReject>;

  /**
   * `prisma.factura_Encabezado`: Exposes CRUD operations for the **Factura_Encabezado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Factura_Encabezados
    * const factura_Encabezados = await prisma.factura_Encabezado.findMany()
    * ```
    */
  get factura_Encabezado(): Prisma.Factura_EncabezadoDelegate<GlobalReject>;

  /**
   * `prisma.factura_Detalle`: Exposes CRUD operations for the **Factura_Detalle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Factura_Detalles
    * const factura_Detalles = await prisma.factura_Detalle.findMany()
    * ```
    */
  get factura_Detalle(): Prisma.Factura_DetalleDelegate<GlobalReject>;

  /**
   * `prisma.facturaEncabezadoTipoPago`: Exposes CRUD operations for the **FacturaEncabezadoTipoPago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacturaEncabezadoTipoPagos
    * const facturaEncabezadoTipoPagos = await prisma.facturaEncabezadoTipoPago.findMany()
    * ```
    */
  get facturaEncabezadoTipoPago(): Prisma.FacturaEncabezadoTipoPagoDelegate<GlobalReject>;

  /**
   * `prisma.estadoPedido`: Exposes CRUD operations for the **EstadoPedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EstadoPedidos
    * const estadoPedidos = await prisma.estadoPedido.findMany()
    * ```
    */
  get estadoPedido(): Prisma.EstadoPedidoDelegate<GlobalReject>;

  /**
   * `prisma.tipoPedido`: Exposes CRUD operations for the **TipoPedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoPedidos
    * const tipoPedidos = await prisma.tipoPedido.findMany()
    * ```
    */
  get tipoPedido(): Prisma.TipoPedidoDelegate<GlobalReject>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<GlobalReject>;

  /**
   * `prisma.pedido_Producto`: Exposes CRUD operations for the **Pedido_Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedido_Productos
    * const pedido_Productos = await prisma.pedido_Producto.findMany()
    * ```
    */
  get pedido_Producto(): Prisma.Pedido_ProductoDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.3.1
   * Query Engine version: 694eea289a8462c80264df36757e4fdc129b1b32
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Perfil: 'Perfil',
    Usuario: 'Usuario',
    Sucursal: 'Sucursal',
    Mesa: 'Mesa',
    DisponibilidadMesa: 'DisponibilidadMesa',
    Reservacion: 'Reservacion',
    Categoria_Producto: 'Categoria_Producto',
    Producto: 'Producto',
    TipoPago: 'TipoPago',
    TipoTarjeta: 'TipoTarjeta',
    Factura_Encabezado: 'Factura_Encabezado',
    Factura_Detalle: 'Factura_Detalle',
    FacturaEncabezadoTipoPago: 'FacturaEncabezadoTipoPago',
    EstadoPedido: 'EstadoPedido',
    TipoPedido: 'TipoPedido',
    Pedido: 'Pedido',
    Pedido_Producto: 'Pedido_Producto'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PerfilCountOutputType
   */


  export type PerfilCountOutputType = {
    usuarios: number
  }

  export type PerfilCountOutputTypeSelect = {
    usuarios?: boolean
  }

  export type PerfilCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PerfilCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PerfilCountOutputType
    : S extends undefined
    ? never
    : S extends PerfilCountOutputTypeArgs
    ?'include' extends U
    ? PerfilCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PerfilCountOutputType ? PerfilCountOutputType[P] : never
  } 
    : PerfilCountOutputType
  : PerfilCountOutputType




  // Custom InputTypes

  /**
   * PerfilCountOutputType without action
   */
  export type PerfilCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PerfilCountOutputType
     * 
    **/
    select?: PerfilCountOutputTypeSelect | null
  }



  /**
   * Count Type UsuarioCountOutputType
   */


  export type UsuarioCountOutputType = {
    reservaciones: number
    facturas: number
    pedidos: number
    encargos: number
    sucursales: number
  }

  export type UsuarioCountOutputTypeSelect = {
    reservaciones?: boolean
    facturas?: boolean
    pedidos?: boolean
    encargos?: boolean
    sucursales?: boolean
  }

  export type UsuarioCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsuarioCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsuarioCountOutputType
    : S extends undefined
    ? never
    : S extends UsuarioCountOutputTypeArgs
    ?'include' extends U
    ? UsuarioCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsuarioCountOutputType ? UsuarioCountOutputType[P] : never
  } 
    : UsuarioCountOutputType
  : UsuarioCountOutputType




  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     * 
    **/
    select?: UsuarioCountOutputTypeSelect | null
  }



  /**
   * Count Type SucursalCountOutputType
   */


  export type SucursalCountOutputType = {
    mesas: number
    reservaciones: number
    productos: number
    meseros: number
    pedidos: number
  }

  export type SucursalCountOutputTypeSelect = {
    mesas?: boolean
    reservaciones?: boolean
    productos?: boolean
    meseros?: boolean
    pedidos?: boolean
  }

  export type SucursalCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SucursalCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SucursalCountOutputType
    : S extends undefined
    ? never
    : S extends SucursalCountOutputTypeArgs
    ?'include' extends U
    ? SucursalCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SucursalCountOutputType ? SucursalCountOutputType[P] : never
  } 
    : SucursalCountOutputType
  : SucursalCountOutputType




  // Custom InputTypes

  /**
   * SucursalCountOutputType without action
   */
  export type SucursalCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SucursalCountOutputType
     * 
    **/
    select?: SucursalCountOutputTypeSelect | null
  }



  /**
   * Count Type MesaCountOutputType
   */


  export type MesaCountOutputType = {
    reservaciones: number
    pedidos: number
  }

  export type MesaCountOutputTypeSelect = {
    reservaciones?: boolean
    pedidos?: boolean
  }

  export type MesaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MesaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MesaCountOutputType
    : S extends undefined
    ? never
    : S extends MesaCountOutputTypeArgs
    ?'include' extends U
    ? MesaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MesaCountOutputType ? MesaCountOutputType[P] : never
  } 
    : MesaCountOutputType
  : MesaCountOutputType




  // Custom InputTypes

  /**
   * MesaCountOutputType without action
   */
  export type MesaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MesaCountOutputType
     * 
    **/
    select?: MesaCountOutputTypeSelect | null
  }



  /**
   * Count Type DisponibilidadMesaCountOutputType
   */


  export type DisponibilidadMesaCountOutputType = {
    mesas: number
  }

  export type DisponibilidadMesaCountOutputTypeSelect = {
    mesas?: boolean
  }

  export type DisponibilidadMesaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DisponibilidadMesaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DisponibilidadMesaCountOutputType
    : S extends undefined
    ? never
    : S extends DisponibilidadMesaCountOutputTypeArgs
    ?'include' extends U
    ? DisponibilidadMesaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DisponibilidadMesaCountOutputType ? DisponibilidadMesaCountOutputType[P] : never
  } 
    : DisponibilidadMesaCountOutputType
  : DisponibilidadMesaCountOutputType




  // Custom InputTypes

  /**
   * DisponibilidadMesaCountOutputType without action
   */
  export type DisponibilidadMesaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DisponibilidadMesaCountOutputType
     * 
    **/
    select?: DisponibilidadMesaCountOutputTypeSelect | null
  }



  /**
   * Count Type ReservacionCountOutputType
   */


  export type ReservacionCountOutputType = {
    mesas: number
  }

  export type ReservacionCountOutputTypeSelect = {
    mesas?: boolean
  }

  export type ReservacionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ReservacionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ReservacionCountOutputType
    : S extends undefined
    ? never
    : S extends ReservacionCountOutputTypeArgs
    ?'include' extends U
    ? ReservacionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ReservacionCountOutputType ? ReservacionCountOutputType[P] : never
  } 
    : ReservacionCountOutputType
  : ReservacionCountOutputType




  // Custom InputTypes

  /**
   * ReservacionCountOutputType without action
   */
  export type ReservacionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReservacionCountOutputType
     * 
    **/
    select?: ReservacionCountOutputTypeSelect | null
  }



  /**
   * Count Type Categoria_ProductoCountOutputType
   */


  export type Categoria_ProductoCountOutputType = {
    productos: number
  }

  export type Categoria_ProductoCountOutputTypeSelect = {
    productos?: boolean
  }

  export type Categoria_ProductoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Categoria_ProductoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Categoria_ProductoCountOutputType
    : S extends undefined
    ? never
    : S extends Categoria_ProductoCountOutputTypeArgs
    ?'include' extends U
    ? Categoria_ProductoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Categoria_ProductoCountOutputType ? Categoria_ProductoCountOutputType[P] : never
  } 
    : Categoria_ProductoCountOutputType
  : Categoria_ProductoCountOutputType




  // Custom InputTypes

  /**
   * Categoria_ProductoCountOutputType without action
   */
  export type Categoria_ProductoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Categoria_ProductoCountOutputType
     * 
    **/
    select?: Categoria_ProductoCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductoCountOutputType
   */


  export type ProductoCountOutputType = {
    detalles: number
    pedidos: number
    sucursales: number
  }

  export type ProductoCountOutputTypeSelect = {
    detalles?: boolean
    pedidos?: boolean
    sucursales?: boolean
  }

  export type ProductoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductoCountOutputType
    : S extends undefined
    ? never
    : S extends ProductoCountOutputTypeArgs
    ?'include' extends U
    ? ProductoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductoCountOutputType ? ProductoCountOutputType[P] : never
  } 
    : ProductoCountOutputType
  : ProductoCountOutputType




  // Custom InputTypes

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductoCountOutputType
     * 
    **/
    select?: ProductoCountOutputTypeSelect | null
  }



  /**
   * Count Type TipoPagoCountOutputType
   */


  export type TipoPagoCountOutputType = {
    facturasEncabezado: number
  }

  export type TipoPagoCountOutputTypeSelect = {
    facturasEncabezado?: boolean
  }

  export type TipoPagoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TipoPagoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TipoPagoCountOutputType
    : S extends undefined
    ? never
    : S extends TipoPagoCountOutputTypeArgs
    ?'include' extends U
    ? TipoPagoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TipoPagoCountOutputType ? TipoPagoCountOutputType[P] : never
  } 
    : TipoPagoCountOutputType
  : TipoPagoCountOutputType




  // Custom InputTypes

  /**
   * TipoPagoCountOutputType without action
   */
  export type TipoPagoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TipoPagoCountOutputType
     * 
    **/
    select?: TipoPagoCountOutputTypeSelect | null
  }



  /**
   * Count Type TipoTarjetaCountOutputType
   */


  export type TipoTarjetaCountOutputType = {
    facturas: number
  }

  export type TipoTarjetaCountOutputTypeSelect = {
    facturas?: boolean
  }

  export type TipoTarjetaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TipoTarjetaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TipoTarjetaCountOutputType
    : S extends undefined
    ? never
    : S extends TipoTarjetaCountOutputTypeArgs
    ?'include' extends U
    ? TipoTarjetaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TipoTarjetaCountOutputType ? TipoTarjetaCountOutputType[P] : never
  } 
    : TipoTarjetaCountOutputType
  : TipoTarjetaCountOutputType




  // Custom InputTypes

  /**
   * TipoTarjetaCountOutputType without action
   */
  export type TipoTarjetaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TipoTarjetaCountOutputType
     * 
    **/
    select?: TipoTarjetaCountOutputTypeSelect | null
  }



  /**
   * Count Type Factura_EncabezadoCountOutputType
   */


  export type Factura_EncabezadoCountOutputType = {
    detalles: number
    tipoPagos: number
  }

  export type Factura_EncabezadoCountOutputTypeSelect = {
    detalles?: boolean
    tipoPagos?: boolean
  }

  export type Factura_EncabezadoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Factura_EncabezadoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Factura_EncabezadoCountOutputType
    : S extends undefined
    ? never
    : S extends Factura_EncabezadoCountOutputTypeArgs
    ?'include' extends U
    ? Factura_EncabezadoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Factura_EncabezadoCountOutputType ? Factura_EncabezadoCountOutputType[P] : never
  } 
    : Factura_EncabezadoCountOutputType
  : Factura_EncabezadoCountOutputType




  // Custom InputTypes

  /**
   * Factura_EncabezadoCountOutputType without action
   */
  export type Factura_EncabezadoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Factura_EncabezadoCountOutputType
     * 
    **/
    select?: Factura_EncabezadoCountOutputTypeSelect | null
  }



  /**
   * Count Type EstadoPedidoCountOutputType
   */


  export type EstadoPedidoCountOutputType = {
    pedidos: number
  }

  export type EstadoPedidoCountOutputTypeSelect = {
    pedidos?: boolean
  }

  export type EstadoPedidoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EstadoPedidoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EstadoPedidoCountOutputType
    : S extends undefined
    ? never
    : S extends EstadoPedidoCountOutputTypeArgs
    ?'include' extends U
    ? EstadoPedidoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EstadoPedidoCountOutputType ? EstadoPedidoCountOutputType[P] : never
  } 
    : EstadoPedidoCountOutputType
  : EstadoPedidoCountOutputType




  // Custom InputTypes

  /**
   * EstadoPedidoCountOutputType without action
   */
  export type EstadoPedidoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EstadoPedidoCountOutputType
     * 
    **/
    select?: EstadoPedidoCountOutputTypeSelect | null
  }



  /**
   * Count Type TipoPedidoCountOutputType
   */


  export type TipoPedidoCountOutputType = {
    pedidos: number
  }

  export type TipoPedidoCountOutputTypeSelect = {
    pedidos?: boolean
  }

  export type TipoPedidoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TipoPedidoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TipoPedidoCountOutputType
    : S extends undefined
    ? never
    : S extends TipoPedidoCountOutputTypeArgs
    ?'include' extends U
    ? TipoPedidoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TipoPedidoCountOutputType ? TipoPedidoCountOutputType[P] : never
  } 
    : TipoPedidoCountOutputType
  : TipoPedidoCountOutputType




  // Custom InputTypes

  /**
   * TipoPedidoCountOutputType without action
   */
  export type TipoPedidoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TipoPedidoCountOutputType
     * 
    **/
    select?: TipoPedidoCountOutputTypeSelect | null
  }



  /**
   * Count Type PedidoCountOutputType
   */


  export type PedidoCountOutputType = {
    detalles: number
  }

  export type PedidoCountOutputTypeSelect = {
    detalles?: boolean
  }

  export type PedidoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PedidoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PedidoCountOutputType
    : S extends undefined
    ? never
    : S extends PedidoCountOutputTypeArgs
    ?'include' extends U
    ? PedidoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PedidoCountOutputType ? PedidoCountOutputType[P] : never
  } 
    : PedidoCountOutputType
  : PedidoCountOutputType




  // Custom InputTypes

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     * 
    **/
    select?: PedidoCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Perfil
   */


  export type AggregatePerfil = {
    _count: PerfilCountAggregateOutputType | null
    _avg: PerfilAvgAggregateOutputType | null
    _sum: PerfilSumAggregateOutputType | null
    _min: PerfilMinAggregateOutputType | null
    _max: PerfilMaxAggregateOutputType | null
  }

  export type PerfilAvgAggregateOutputType = {
    id: number | null
  }

  export type PerfilSumAggregateOutputType = {
    id: number | null
  }

  export type PerfilMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type PerfilMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type PerfilCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type PerfilAvgAggregateInputType = {
    id?: true
  }

  export type PerfilSumAggregateInputType = {
    id?: true
  }

  export type PerfilMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type PerfilMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type PerfilCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type PerfilAggregateArgs = {
    /**
     * Filter which Perfil to aggregate.
     * 
    **/
    where?: PerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<PerfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Perfils.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Perfils
    **/
    _count?: true | PerfilCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerfilAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerfilSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerfilMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerfilMaxAggregateInputType
  }

  export type GetPerfilAggregateType<T extends PerfilAggregateArgs> = {
        [P in keyof T & keyof AggregatePerfil]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerfil[P]>
      : GetScalarType<T[P], AggregatePerfil[P]>
  }




  export type PerfilGroupByArgs = {
    where?: PerfilWhereInput
    orderBy?: Enumerable<PerfilOrderByWithAggregationInput>
    by: Array<PerfilScalarFieldEnum>
    having?: PerfilScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerfilCountAggregateInputType | true
    _avg?: PerfilAvgAggregateInputType
    _sum?: PerfilSumAggregateInputType
    _min?: PerfilMinAggregateInputType
    _max?: PerfilMaxAggregateInputType
  }


  export type PerfilGroupByOutputType = {
    id: number
    descripcion: string
    _count: PerfilCountAggregateOutputType | null
    _avg: PerfilAvgAggregateOutputType | null
    _sum: PerfilSumAggregateOutputType | null
    _min: PerfilMinAggregateOutputType | null
    _max: PerfilMaxAggregateOutputType | null
  }

  type GetPerfilGroupByPayload<T extends PerfilGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PerfilGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerfilGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerfilGroupByOutputType[P]>
            : GetScalarType<T[P], PerfilGroupByOutputType[P]>
        }
      >
    >


  export type PerfilSelect = {
    id?: boolean
    descripcion?: boolean
    usuarios?: boolean | UsuarioFindManyArgs
    _count?: boolean | PerfilCountOutputTypeArgs
  }

  export type PerfilInclude = {
    usuarios?: boolean | UsuarioFindManyArgs
    _count?: boolean | PerfilCountOutputTypeArgs
  }

  export type PerfilGetPayload<
    S extends boolean | null | undefined | PerfilArgs,
    U = keyof S
      > = S extends true
        ? Perfil
    : S extends undefined
    ? never
    : S extends PerfilArgs | PerfilFindManyArgs
    ?'include' extends U
    ? Perfil  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuarios' ? Array < UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PerfilCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuarios' ? Array < UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PerfilCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Perfil ? Perfil[P] : never
  } 
    : Perfil
  : Perfil


  type PerfilCountArgs = Merge<
    Omit<PerfilFindManyArgs, 'select' | 'include'> & {
      select?: PerfilCountAggregateInputType | true
    }
  >

  export interface PerfilDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Perfil that matches the filter.
     * @param {PerfilFindUniqueArgs} args - Arguments to find a Perfil
     * @example
     * // Get one Perfil
     * const perfil = await prisma.perfil.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PerfilFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PerfilFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Perfil'> extends True ? CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>> : CheckSelect<T, Prisma__PerfilClient<Perfil | null >, Prisma__PerfilClient<PerfilGetPayload<T> | null >>

    /**
     * Find the first Perfil that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilFindFirstArgs} args - Arguments to find a Perfil
     * @example
     * // Get one Perfil
     * const perfil = await prisma.perfil.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PerfilFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PerfilFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Perfil'> extends True ? CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>> : CheckSelect<T, Prisma__PerfilClient<Perfil | null >, Prisma__PerfilClient<PerfilGetPayload<T> | null >>

    /**
     * Find zero or more Perfils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Perfils
     * const perfils = await prisma.perfil.findMany()
     * 
     * // Get first 10 Perfils
     * const perfils = await prisma.perfil.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perfilWithIdOnly = await prisma.perfil.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PerfilFindManyArgs>(
      args?: SelectSubset<T, PerfilFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Perfil>>, PrismaPromise<Array<PerfilGetPayload<T>>>>

    /**
     * Create a Perfil.
     * @param {PerfilCreateArgs} args - Arguments to create a Perfil.
     * @example
     * // Create one Perfil
     * const Perfil = await prisma.perfil.create({
     *   data: {
     *     // ... data to create a Perfil
     *   }
     * })
     * 
    **/
    create<T extends PerfilCreateArgs>(
      args: SelectSubset<T, PerfilCreateArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Create many Perfils.
     *     @param {PerfilCreateManyArgs} args - Arguments to create many Perfils.
     *     @example
     *     // Create many Perfils
     *     const perfil = await prisma.perfil.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PerfilCreateManyArgs>(
      args?: SelectSubset<T, PerfilCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Perfil.
     * @param {PerfilDeleteArgs} args - Arguments to delete one Perfil.
     * @example
     * // Delete one Perfil
     * const Perfil = await prisma.perfil.delete({
     *   where: {
     *     // ... filter to delete one Perfil
     *   }
     * })
     * 
    **/
    delete<T extends PerfilDeleteArgs>(
      args: SelectSubset<T, PerfilDeleteArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Update one Perfil.
     * @param {PerfilUpdateArgs} args - Arguments to update one Perfil.
     * @example
     * // Update one Perfil
     * const perfil = await prisma.perfil.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PerfilUpdateArgs>(
      args: SelectSubset<T, PerfilUpdateArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Delete zero or more Perfils.
     * @param {PerfilDeleteManyArgs} args - Arguments to filter Perfils to delete.
     * @example
     * // Delete a few Perfils
     * const { count } = await prisma.perfil.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PerfilDeleteManyArgs>(
      args?: SelectSubset<T, PerfilDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Perfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Perfils
     * const perfil = await prisma.perfil.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PerfilUpdateManyArgs>(
      args: SelectSubset<T, PerfilUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Perfil.
     * @param {PerfilUpsertArgs} args - Arguments to update or create a Perfil.
     * @example
     * // Update or create a Perfil
     * const perfil = await prisma.perfil.upsert({
     *   create: {
     *     // ... data to create a Perfil
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Perfil we want to update
     *   }
     * })
    **/
    upsert<T extends PerfilUpsertArgs>(
      args: SelectSubset<T, PerfilUpsertArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Find one Perfil that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PerfilFindUniqueOrThrowArgs} args - Arguments to find a Perfil
     * @example
     * // Get one Perfil
     * const perfil = await prisma.perfil.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PerfilFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PerfilFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Find the first Perfil that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilFindFirstOrThrowArgs} args - Arguments to find a Perfil
     * @example
     * // Get one Perfil
     * const perfil = await prisma.perfil.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PerfilFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PerfilFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PerfilClient<Perfil>, Prisma__PerfilClient<PerfilGetPayload<T>>>

    /**
     * Count the number of Perfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilCountArgs} args - Arguments to filter Perfils to count.
     * @example
     * // Count the number of Perfils
     * const count = await prisma.perfil.count({
     *   where: {
     *     // ... the filter for the Perfils we want to count
     *   }
     * })
    **/
    count<T extends PerfilCountArgs>(
      args?: Subset<T, PerfilCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerfilCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Perfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerfilAggregateArgs>(args: Subset<T, PerfilAggregateArgs>): PrismaPromise<GetPerfilAggregateType<T>>

    /**
     * Group by Perfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerfilGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerfilGroupByArgs['orderBy'] }
        : { orderBy?: PerfilGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerfilGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerfilGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Perfil.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PerfilClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuarios<T extends UsuarioFindManyArgs = {}>(args?: Subset<T, UsuarioFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Usuario>>, PrismaPromise<Array<UsuarioGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Perfil base type for findUnique actions
   */
  export type PerfilFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * Filter, which Perfil to fetch.
     * 
    **/
    where: PerfilWhereUniqueInput
  }

  /**
   * Perfil: findUnique
   */
  export interface PerfilFindUniqueArgs extends PerfilFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Perfil base type for findFirst actions
   */
  export type PerfilFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * Filter, which Perfil to fetch.
     * 
    **/
    where?: PerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<PerfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Perfils.
     * 
    **/
    cursor?: PerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Perfils.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Perfils.
     * 
    **/
    distinct?: Enumerable<PerfilScalarFieldEnum>
  }

  /**
   * Perfil: findFirst
   */
  export interface PerfilFindFirstArgs extends PerfilFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Perfil findMany
   */
  export type PerfilFindManyArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * Filter, which Perfils to fetch.
     * 
    **/
    where?: PerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<PerfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Perfils.
     * 
    **/
    cursor?: PerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Perfils.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PerfilScalarFieldEnum>
  }


  /**
   * Perfil create
   */
  export type PerfilCreateArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * The data needed to create a Perfil.
     * 
    **/
    data: XOR<PerfilCreateInput, PerfilUncheckedCreateInput>
  }


  /**
   * Perfil createMany
   */
  export type PerfilCreateManyArgs = {
    /**
     * The data used to create many Perfils.
     * 
    **/
    data: Enumerable<PerfilCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Perfil update
   */
  export type PerfilUpdateArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * The data needed to update a Perfil.
     * 
    **/
    data: XOR<PerfilUpdateInput, PerfilUncheckedUpdateInput>
    /**
     * Choose, which Perfil to update.
     * 
    **/
    where: PerfilWhereUniqueInput
  }


  /**
   * Perfil updateMany
   */
  export type PerfilUpdateManyArgs = {
    /**
     * The data used to update Perfils.
     * 
    **/
    data: XOR<PerfilUpdateManyMutationInput, PerfilUncheckedUpdateManyInput>
    /**
     * Filter which Perfils to update
     * 
    **/
    where?: PerfilWhereInput
  }


  /**
   * Perfil upsert
   */
  export type PerfilUpsertArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * The filter to search for the Perfil to update in case it exists.
     * 
    **/
    where: PerfilWhereUniqueInput
    /**
     * In case the Perfil found by the `where` argument doesn't exist, create a new Perfil with this data.
     * 
    **/
    create: XOR<PerfilCreateInput, PerfilUncheckedCreateInput>
    /**
     * In case the Perfil was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PerfilUpdateInput, PerfilUncheckedUpdateInput>
  }


  /**
   * Perfil delete
   */
  export type PerfilDeleteArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
    /**
     * Filter which Perfil to delete.
     * 
    **/
    where: PerfilWhereUniqueInput
  }


  /**
   * Perfil deleteMany
   */
  export type PerfilDeleteManyArgs = {
    /**
     * Filter which Perfils to delete
     * 
    **/
    where?: PerfilWhereInput
  }


  /**
   * Perfil: findUniqueOrThrow
   */
  export type PerfilFindUniqueOrThrowArgs = PerfilFindUniqueArgsBase
      

  /**
   * Perfil: findFirstOrThrow
   */
  export type PerfilFindFirstOrThrowArgs = PerfilFindFirstArgsBase
      

  /**
   * Perfil without action
   */
  export type PerfilArgs = {
    /**
     * Select specific fields to fetch from the Perfil
     * 
    **/
    select?: PerfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PerfilInclude | null
  }



  /**
   * Model Usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    idPerfil: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    idPerfil: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido1: string | null
    apellido2: string | null
    correo: string | null
    username: string | null
    clave: string | null
    telefono: string | null
    direccion: string | null
    idPerfil: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido1: string | null
    apellido2: string | null
    correo: string | null
    username: string | null
    clave: string | null
    telefono: string | null
    direccion: string | null
    idPerfil: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    apellido1: number
    apellido2: number
    correo: number
    username: number
    clave: number
    telefono: number
    direccion: number
    idPerfil: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    idPerfil?: true
  }

  export type UsuarioSumAggregateInputType = {
    idPerfil?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido1?: true
    apellido2?: true
    correo?: true
    username?: true
    clave?: true
    telefono?: true
    direccion?: true
    idPerfil?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido1?: true
    apellido2?: true
    correo?: true
    username?: true
    clave?: true
    telefono?: true
    direccion?: true
    idPerfil?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido1?: true
    apellido2?: true
    correo?: true
    username?: true
    clave?: true
    telefono?: true
    direccion?: true
    idPerfil?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which Usuario to aggregate.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: UsuarioWhereInput
    orderBy?: Enumerable<UsuarioOrderByWithAggregationInput>
    by: Array<UsuarioScalarFieldEnum>
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion: string | null
    idPerfil: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect = {
    id?: boolean
    nombre?: boolean
    apellido1?: boolean
    apellido2?: boolean
    correo?: boolean
    username?: boolean
    clave?: boolean
    telefono?: boolean
    direccion?: boolean
    reservaciones?: boolean | ReservacionFindManyArgs
    facturas?: boolean | Factura_EncabezadoFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    encargos?: boolean | PedidoFindManyArgs
    Perfil?: boolean | PerfilArgs
    idPerfil?: boolean
    sucursales?: boolean | SucursalFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type UsuarioInclude = {
    reservaciones?: boolean | ReservacionFindManyArgs
    facturas?: boolean | Factura_EncabezadoFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    encargos?: boolean | PedidoFindManyArgs
    Perfil?: boolean | PerfilArgs
    sucursales?: boolean | SucursalFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type UsuarioGetPayload<
    S extends boolean | null | undefined | UsuarioArgs,
    U = keyof S
      > = S extends true
        ? Usuario
    : S extends undefined
    ? never
    : S extends UsuarioArgs | UsuarioFindManyArgs
    ?'include' extends U
    ? Usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'facturas' ? Array < Factura_EncabezadoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'encargos' ? Array < PedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Perfil' ? PerfilGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'sucursales' ? Array < SucursalGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'facturas' ? Array < Factura_EncabezadoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'encargos' ? Array < PedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Perfil' ? PerfilGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'sucursales' ? Array < SucursalGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Usuario ? Usuario[P] : never
  } 
    : Usuario
  : Usuario


  type UsuarioCountArgs = Merge<
    Omit<UsuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }
  >

  export interface UsuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Usuario'> extends True ? CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Usuario'> extends True ? CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs>(
      args?: SelectSubset<T, UsuarioFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Usuario>>, PrismaPromise<Array<UsuarioGetPayload<T>>>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs>(
      args: SelectSubset<T, UsuarioCreateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs>(
      args?: SelectSubset<T, UsuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs>(
      args: SelectSubset<T, UsuarioDeleteArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs>(
      args: SelectSubset<T, UsuarioUpdateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs>(
      args: SelectSubset<T, UsuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs>(
      args: SelectSubset<T, UsuarioUpsertArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Find one Usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsuarioClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    reservaciones<T extends ReservacionFindManyArgs = {}>(args?: Subset<T, ReservacionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reservacion>>, PrismaPromise<Array<ReservacionGetPayload<T>>>>;

    facturas<T extends Factura_EncabezadoFindManyArgs = {}>(args?: Subset<T, Factura_EncabezadoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Factura_Encabezado>>, PrismaPromise<Array<Factura_EncabezadoGetPayload<T>>>>;

    pedidos<T extends PedidoFindManyArgs = {}>(args?: Subset<T, PedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>;

    encargos<T extends PedidoFindManyArgs = {}>(args?: Subset<T, PedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>;

    Perfil<T extends PerfilArgs = {}>(args?: Subset<T, PerfilArgs>): CheckSelect<T, Prisma__PerfilClient<Perfil | null >, Prisma__PerfilClient<PerfilGetPayload<T> | null >>;

    sucursales<T extends SucursalFindManyArgs = {}>(args?: Subset<T, SucursalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Sucursal>>, PrismaPromise<Array<SucursalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Usuario base type for findUnique actions
   */
  export type UsuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario: findUnique
   */
  export interface UsuarioFindUniqueArgs extends UsuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario base type for findFirst actions
   */
  export type UsuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     * 
    **/
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * Usuario: findFirst
   */
  export interface UsuarioFindFirstArgs extends UsuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuarios to fetch.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * The data needed to create a Usuario.
     * 
    **/
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs = {
    /**
     * The data used to create many Usuarios.
     * 
    **/
    data: Enumerable<UsuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * The data needed to update a Usuario.
     * 
    **/
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs = {
    /**
     * The data used to update Usuarios.
     * 
    **/
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     * 
    **/
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     * 
    **/
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     * 
    **/
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter which Usuario to delete.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs = {
    /**
     * Filter which Usuarios to delete
     * 
    **/
    where?: UsuarioWhereInput
  }


  /**
   * Usuario: findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs = UsuarioFindUniqueArgsBase
      

  /**
   * Usuario: findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs = UsuarioFindFirstArgsBase
      

  /**
   * Usuario without action
   */
  export type UsuarioArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
  }



  /**
   * Model Sucursal
   */


  export type AggregateSucursal = {
    _count: SucursalCountAggregateOutputType | null
    _avg: SucursalAvgAggregateOutputType | null
    _sum: SucursalSumAggregateOutputType | null
    _min: SucursalMinAggregateOutputType | null
    _max: SucursalMaxAggregateOutputType | null
  }

  export type SucursalAvgAggregateOutputType = {
    id: number | null
    capacidad: number | null
  }

  export type SucursalSumAggregateOutputType = {
    id: number | null
    capacidad: number | null
  }

  export type SucursalMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    nombre: string | null
    ubicacion: string | null
    capacidad: number | null
  }

  export type SucursalMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    nombre: string | null
    ubicacion: string | null
    capacidad: number | null
  }

  export type SucursalCountAggregateOutputType = {
    id: number
    codigo: number
    nombre: number
    ubicacion: number
    capacidad: number
    _all: number
  }


  export type SucursalAvgAggregateInputType = {
    id?: true
    capacidad?: true
  }

  export type SucursalSumAggregateInputType = {
    id?: true
    capacidad?: true
  }

  export type SucursalMinAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    ubicacion?: true
    capacidad?: true
  }

  export type SucursalMaxAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    ubicacion?: true
    capacidad?: true
  }

  export type SucursalCountAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    ubicacion?: true
    capacidad?: true
    _all?: true
  }

  export type SucursalAggregateArgs = {
    /**
     * Filter which Sucursal to aggregate.
     * 
    **/
    where?: SucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sucursals to fetch.
     * 
    **/
    orderBy?: Enumerable<SucursalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sucursals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sucursals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sucursals
    **/
    _count?: true | SucursalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SucursalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SucursalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SucursalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SucursalMaxAggregateInputType
  }

  export type GetSucursalAggregateType<T extends SucursalAggregateArgs> = {
        [P in keyof T & keyof AggregateSucursal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSucursal[P]>
      : GetScalarType<T[P], AggregateSucursal[P]>
  }




  export type SucursalGroupByArgs = {
    where?: SucursalWhereInput
    orderBy?: Enumerable<SucursalOrderByWithAggregationInput>
    by: Array<SucursalScalarFieldEnum>
    having?: SucursalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SucursalCountAggregateInputType | true
    _avg?: SucursalAvgAggregateInputType
    _sum?: SucursalSumAggregateInputType
    _min?: SucursalMinAggregateInputType
    _max?: SucursalMaxAggregateInputType
  }


  export type SucursalGroupByOutputType = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    _count: SucursalCountAggregateOutputType | null
    _avg: SucursalAvgAggregateOutputType | null
    _sum: SucursalSumAggregateOutputType | null
    _min: SucursalMinAggregateOutputType | null
    _max: SucursalMaxAggregateOutputType | null
  }

  type GetSucursalGroupByPayload<T extends SucursalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SucursalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SucursalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SucursalGroupByOutputType[P]>
            : GetScalarType<T[P], SucursalGroupByOutputType[P]>
        }
      >
    >


  export type SucursalSelect = {
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    ubicacion?: boolean
    capacidad?: boolean
    mesas?: boolean | MesaFindManyArgs
    reservaciones?: boolean | ReservacionFindManyArgs
    productos?: boolean | ProductoFindManyArgs
    meseros?: boolean | UsuarioFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    _count?: boolean | SucursalCountOutputTypeArgs
  }

  export type SucursalInclude = {
    mesas?: boolean | MesaFindManyArgs
    reservaciones?: boolean | ReservacionFindManyArgs
    productos?: boolean | ProductoFindManyArgs
    meseros?: boolean | UsuarioFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    _count?: boolean | SucursalCountOutputTypeArgs
  }

  export type SucursalGetPayload<
    S extends boolean | null | undefined | SucursalArgs,
    U = keyof S
      > = S extends true
        ? Sucursal
    : S extends undefined
    ? never
    : S extends SucursalArgs | SucursalFindManyArgs
    ?'include' extends U
    ? Sucursal  & {
    [P in TrueKeys<S['include']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'productos' ? Array < ProductoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'meseros' ? Array < UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? SucursalCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'productos' ? Array < ProductoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'meseros' ? Array < UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? SucursalCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Sucursal ? Sucursal[P] : never
  } 
    : Sucursal
  : Sucursal


  type SucursalCountArgs = Merge<
    Omit<SucursalFindManyArgs, 'select' | 'include'> & {
      select?: SucursalCountAggregateInputType | true
    }
  >

  export interface SucursalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Sucursal that matches the filter.
     * @param {SucursalFindUniqueArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SucursalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SucursalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sucursal'> extends True ? CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>> : CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>

    /**
     * Find the first Sucursal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalFindFirstArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SucursalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SucursalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sucursal'> extends True ? CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>> : CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>

    /**
     * Find zero or more Sucursals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sucursals
     * const sucursals = await prisma.sucursal.findMany()
     * 
     * // Get first 10 Sucursals
     * const sucursals = await prisma.sucursal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sucursalWithIdOnly = await prisma.sucursal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SucursalFindManyArgs>(
      args?: SelectSubset<T, SucursalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Sucursal>>, PrismaPromise<Array<SucursalGetPayload<T>>>>

    /**
     * Create a Sucursal.
     * @param {SucursalCreateArgs} args - Arguments to create a Sucursal.
     * @example
     * // Create one Sucursal
     * const Sucursal = await prisma.sucursal.create({
     *   data: {
     *     // ... data to create a Sucursal
     *   }
     * })
     * 
    **/
    create<T extends SucursalCreateArgs>(
      args: SelectSubset<T, SucursalCreateArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Create many Sucursals.
     *     @param {SucursalCreateManyArgs} args - Arguments to create many Sucursals.
     *     @example
     *     // Create many Sucursals
     *     const sucursal = await prisma.sucursal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SucursalCreateManyArgs>(
      args?: SelectSubset<T, SucursalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sucursal.
     * @param {SucursalDeleteArgs} args - Arguments to delete one Sucursal.
     * @example
     * // Delete one Sucursal
     * const Sucursal = await prisma.sucursal.delete({
     *   where: {
     *     // ... filter to delete one Sucursal
     *   }
     * })
     * 
    **/
    delete<T extends SucursalDeleteArgs>(
      args: SelectSubset<T, SucursalDeleteArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Update one Sucursal.
     * @param {SucursalUpdateArgs} args - Arguments to update one Sucursal.
     * @example
     * // Update one Sucursal
     * const sucursal = await prisma.sucursal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SucursalUpdateArgs>(
      args: SelectSubset<T, SucursalUpdateArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Delete zero or more Sucursals.
     * @param {SucursalDeleteManyArgs} args - Arguments to filter Sucursals to delete.
     * @example
     * // Delete a few Sucursals
     * const { count } = await prisma.sucursal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SucursalDeleteManyArgs>(
      args?: SelectSubset<T, SucursalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sucursals
     * const sucursal = await prisma.sucursal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SucursalUpdateManyArgs>(
      args: SelectSubset<T, SucursalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sucursal.
     * @param {SucursalUpsertArgs} args - Arguments to update or create a Sucursal.
     * @example
     * // Update or create a Sucursal
     * const sucursal = await prisma.sucursal.upsert({
     *   create: {
     *     // ... data to create a Sucursal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sucursal we want to update
     *   }
     * })
    **/
    upsert<T extends SucursalUpsertArgs>(
      args: SelectSubset<T, SucursalUpsertArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Find one Sucursal that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SucursalFindUniqueOrThrowArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SucursalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SucursalFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Find the first Sucursal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalFindFirstOrThrowArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SucursalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SucursalFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SucursalClient<Sucursal>, Prisma__SucursalClient<SucursalGetPayload<T>>>

    /**
     * Count the number of Sucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalCountArgs} args - Arguments to filter Sucursals to count.
     * @example
     * // Count the number of Sucursals
     * const count = await prisma.sucursal.count({
     *   where: {
     *     // ... the filter for the Sucursals we want to count
     *   }
     * })
    **/
    count<T extends SucursalCountArgs>(
      args?: Subset<T, SucursalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SucursalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SucursalAggregateArgs>(args: Subset<T, SucursalAggregateArgs>): PrismaPromise<GetSucursalAggregateType<T>>

    /**
     * Group by Sucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SucursalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SucursalGroupByArgs['orderBy'] }
        : { orderBy?: SucursalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SucursalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSucursalGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Sucursal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SucursalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    mesas<T extends MesaFindManyArgs = {}>(args?: Subset<T, MesaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mesa>>, PrismaPromise<Array<MesaGetPayload<T>>>>;

    reservaciones<T extends ReservacionFindManyArgs = {}>(args?: Subset<T, ReservacionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reservacion>>, PrismaPromise<Array<ReservacionGetPayload<T>>>>;

    productos<T extends ProductoFindManyArgs = {}>(args?: Subset<T, ProductoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Producto>>, PrismaPromise<Array<ProductoGetPayload<T>>>>;

    meseros<T extends UsuarioFindManyArgs = {}>(args?: Subset<T, UsuarioFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Usuario>>, PrismaPromise<Array<UsuarioGetPayload<T>>>>;

    pedidos<T extends PedidoFindManyArgs = {}>(args?: Subset<T, PedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Sucursal base type for findUnique actions
   */
  export type SucursalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * Filter, which Sucursal to fetch.
     * 
    **/
    where: SucursalWhereUniqueInput
  }

  /**
   * Sucursal: findUnique
   */
  export interface SucursalFindUniqueArgs extends SucursalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sucursal base type for findFirst actions
   */
  export type SucursalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * Filter, which Sucursal to fetch.
     * 
    **/
    where?: SucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sucursals to fetch.
     * 
    **/
    orderBy?: Enumerable<SucursalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sucursals.
     * 
    **/
    cursor?: SucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sucursals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sucursals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sucursals.
     * 
    **/
    distinct?: Enumerable<SucursalScalarFieldEnum>
  }

  /**
   * Sucursal: findFirst
   */
  export interface SucursalFindFirstArgs extends SucursalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sucursal findMany
   */
  export type SucursalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * Filter, which Sucursals to fetch.
     * 
    **/
    where?: SucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sucursals to fetch.
     * 
    **/
    orderBy?: Enumerable<SucursalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sucursals.
     * 
    **/
    cursor?: SucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sucursals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sucursals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SucursalScalarFieldEnum>
  }


  /**
   * Sucursal create
   */
  export type SucursalCreateArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * The data needed to create a Sucursal.
     * 
    **/
    data: XOR<SucursalCreateInput, SucursalUncheckedCreateInput>
  }


  /**
   * Sucursal createMany
   */
  export type SucursalCreateManyArgs = {
    /**
     * The data used to create many Sucursals.
     * 
    **/
    data: Enumerable<SucursalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Sucursal update
   */
  export type SucursalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * The data needed to update a Sucursal.
     * 
    **/
    data: XOR<SucursalUpdateInput, SucursalUncheckedUpdateInput>
    /**
     * Choose, which Sucursal to update.
     * 
    **/
    where: SucursalWhereUniqueInput
  }


  /**
   * Sucursal updateMany
   */
  export type SucursalUpdateManyArgs = {
    /**
     * The data used to update Sucursals.
     * 
    **/
    data: XOR<SucursalUpdateManyMutationInput, SucursalUncheckedUpdateManyInput>
    /**
     * Filter which Sucursals to update
     * 
    **/
    where?: SucursalWhereInput
  }


  /**
   * Sucursal upsert
   */
  export type SucursalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * The filter to search for the Sucursal to update in case it exists.
     * 
    **/
    where: SucursalWhereUniqueInput
    /**
     * In case the Sucursal found by the `where` argument doesn't exist, create a new Sucursal with this data.
     * 
    **/
    create: XOR<SucursalCreateInput, SucursalUncheckedCreateInput>
    /**
     * In case the Sucursal was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SucursalUpdateInput, SucursalUncheckedUpdateInput>
  }


  /**
   * Sucursal delete
   */
  export type SucursalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
    /**
     * Filter which Sucursal to delete.
     * 
    **/
    where: SucursalWhereUniqueInput
  }


  /**
   * Sucursal deleteMany
   */
  export type SucursalDeleteManyArgs = {
    /**
     * Filter which Sucursals to delete
     * 
    **/
    where?: SucursalWhereInput
  }


  /**
   * Sucursal: findUniqueOrThrow
   */
  export type SucursalFindUniqueOrThrowArgs = SucursalFindUniqueArgsBase
      

  /**
   * Sucursal: findFirstOrThrow
   */
  export type SucursalFindFirstOrThrowArgs = SucursalFindFirstArgsBase
      

  /**
   * Sucursal without action
   */
  export type SucursalArgs = {
    /**
     * Select specific fields to fetch from the Sucursal
     * 
    **/
    select?: SucursalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SucursalInclude | null
  }



  /**
   * Model Mesa
   */


  export type AggregateMesa = {
    _count: MesaCountAggregateOutputType | null
    _avg: MesaAvgAggregateOutputType | null
    _sum: MesaSumAggregateOutputType | null
    _min: MesaMinAggregateOutputType | null
    _max: MesaMaxAggregateOutputType | null
  }

  export type MesaAvgAggregateOutputType = {
    id: number | null
    capacidad: number | null
    idSucursal: number | null
    idDisponibilidad: number | null
  }

  export type MesaSumAggregateOutputType = {
    id: number | null
    capacidad: number | null
    idSucursal: number | null
    idDisponibilidad: number | null
  }

  export type MesaMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    capacidad: number | null
    estado: boolean | null
    idSucursal: number | null
    idDisponibilidad: number | null
  }

  export type MesaMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    capacidad: number | null
    estado: boolean | null
    idSucursal: number | null
    idDisponibilidad: number | null
  }

  export type MesaCountAggregateOutputType = {
    id: number
    codigo: number
    capacidad: number
    estado: number
    idSucursal: number
    idDisponibilidad: number
    _all: number
  }


  export type MesaAvgAggregateInputType = {
    id?: true
    capacidad?: true
    idSucursal?: true
    idDisponibilidad?: true
  }

  export type MesaSumAggregateInputType = {
    id?: true
    capacidad?: true
    idSucursal?: true
    idDisponibilidad?: true
  }

  export type MesaMinAggregateInputType = {
    id?: true
    codigo?: true
    capacidad?: true
    estado?: true
    idSucursal?: true
    idDisponibilidad?: true
  }

  export type MesaMaxAggregateInputType = {
    id?: true
    codigo?: true
    capacidad?: true
    estado?: true
    idSucursal?: true
    idDisponibilidad?: true
  }

  export type MesaCountAggregateInputType = {
    id?: true
    codigo?: true
    capacidad?: true
    estado?: true
    idSucursal?: true
    idDisponibilidad?: true
    _all?: true
  }

  export type MesaAggregateArgs = {
    /**
     * Filter which Mesa to aggregate.
     * 
    **/
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     * 
    **/
    orderBy?: Enumerable<MesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mesas
    **/
    _count?: true | MesaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MesaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MesaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MesaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MesaMaxAggregateInputType
  }

  export type GetMesaAggregateType<T extends MesaAggregateArgs> = {
        [P in keyof T & keyof AggregateMesa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMesa[P]>
      : GetScalarType<T[P], AggregateMesa[P]>
  }




  export type MesaGroupByArgs = {
    where?: MesaWhereInput
    orderBy?: Enumerable<MesaOrderByWithAggregationInput>
    by: Array<MesaScalarFieldEnum>
    having?: MesaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MesaCountAggregateInputType | true
    _avg?: MesaAvgAggregateInputType
    _sum?: MesaSumAggregateInputType
    _min?: MesaMinAggregateInputType
    _max?: MesaMaxAggregateInputType
  }


  export type MesaGroupByOutputType = {
    id: number
    codigo: string
    capacidad: number
    estado: boolean
    idSucursal: number
    idDisponibilidad: number
    _count: MesaCountAggregateOutputType | null
    _avg: MesaAvgAggregateOutputType | null
    _sum: MesaSumAggregateOutputType | null
    _min: MesaMinAggregateOutputType | null
    _max: MesaMaxAggregateOutputType | null
  }

  type GetMesaGroupByPayload<T extends MesaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MesaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MesaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MesaGroupByOutputType[P]>
            : GetScalarType<T[P], MesaGroupByOutputType[P]>
        }
      >
    >


  export type MesaSelect = {
    id?: boolean
    codigo?: boolean
    capacidad?: boolean
    estado?: boolean
    reservaciones?: boolean | ReservacionFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    Sucursal?: boolean | SucursalArgs
    idSucursal?: boolean
    EstadoMesa?: boolean | DisponibilidadMesaArgs
    idDisponibilidad?: boolean
    _count?: boolean | MesaCountOutputTypeArgs
  }

  export type MesaInclude = {
    reservaciones?: boolean | ReservacionFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    Sucursal?: boolean | SucursalArgs
    EstadoMesa?: boolean | DisponibilidadMesaArgs
    _count?: boolean | MesaCountOutputTypeArgs
  }

  export type MesaGetPayload<
    S extends boolean | null | undefined | MesaArgs,
    U = keyof S
      > = S extends true
        ? Mesa
    : S extends undefined
    ? never
    : S extends MesaArgs | MesaFindManyArgs
    ?'include' extends U
    ? Mesa  & {
    [P in TrueKeys<S['include']>]:
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'EstadoMesa' ? DisponibilidadMesaGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? MesaCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'reservaciones' ? Array < ReservacionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'EstadoMesa' ? DisponibilidadMesaGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? MesaCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Mesa ? Mesa[P] : never
  } 
    : Mesa
  : Mesa


  type MesaCountArgs = Merge<
    Omit<MesaFindManyArgs, 'select' | 'include'> & {
      select?: MesaCountAggregateInputType | true
    }
  >

  export interface MesaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Mesa that matches the filter.
     * @param {MesaFindUniqueArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MesaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MesaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Mesa'> extends True ? CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>> : CheckSelect<T, Prisma__MesaClient<Mesa | null >, Prisma__MesaClient<MesaGetPayload<T> | null >>

    /**
     * Find the first Mesa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaFindFirstArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MesaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MesaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Mesa'> extends True ? CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>> : CheckSelect<T, Prisma__MesaClient<Mesa | null >, Prisma__MesaClient<MesaGetPayload<T> | null >>

    /**
     * Find zero or more Mesas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mesas
     * const mesas = await prisma.mesa.findMany()
     * 
     * // Get first 10 Mesas
     * const mesas = await prisma.mesa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mesaWithIdOnly = await prisma.mesa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MesaFindManyArgs>(
      args?: SelectSubset<T, MesaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Mesa>>, PrismaPromise<Array<MesaGetPayload<T>>>>

    /**
     * Create a Mesa.
     * @param {MesaCreateArgs} args - Arguments to create a Mesa.
     * @example
     * // Create one Mesa
     * const Mesa = await prisma.mesa.create({
     *   data: {
     *     // ... data to create a Mesa
     *   }
     * })
     * 
    **/
    create<T extends MesaCreateArgs>(
      args: SelectSubset<T, MesaCreateArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Create many Mesas.
     *     @param {MesaCreateManyArgs} args - Arguments to create many Mesas.
     *     @example
     *     // Create many Mesas
     *     const mesa = await prisma.mesa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MesaCreateManyArgs>(
      args?: SelectSubset<T, MesaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Mesa.
     * @param {MesaDeleteArgs} args - Arguments to delete one Mesa.
     * @example
     * // Delete one Mesa
     * const Mesa = await prisma.mesa.delete({
     *   where: {
     *     // ... filter to delete one Mesa
     *   }
     * })
     * 
    **/
    delete<T extends MesaDeleteArgs>(
      args: SelectSubset<T, MesaDeleteArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Update one Mesa.
     * @param {MesaUpdateArgs} args - Arguments to update one Mesa.
     * @example
     * // Update one Mesa
     * const mesa = await prisma.mesa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MesaUpdateArgs>(
      args: SelectSubset<T, MesaUpdateArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Delete zero or more Mesas.
     * @param {MesaDeleteManyArgs} args - Arguments to filter Mesas to delete.
     * @example
     * // Delete a few Mesas
     * const { count } = await prisma.mesa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MesaDeleteManyArgs>(
      args?: SelectSubset<T, MesaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mesas
     * const mesa = await prisma.mesa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MesaUpdateManyArgs>(
      args: SelectSubset<T, MesaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Mesa.
     * @param {MesaUpsertArgs} args - Arguments to update or create a Mesa.
     * @example
     * // Update or create a Mesa
     * const mesa = await prisma.mesa.upsert({
     *   create: {
     *     // ... data to create a Mesa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mesa we want to update
     *   }
     * })
    **/
    upsert<T extends MesaUpsertArgs>(
      args: SelectSubset<T, MesaUpsertArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Find one Mesa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {MesaFindUniqueOrThrowArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MesaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MesaFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Find the first Mesa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaFindFirstOrThrowArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MesaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MesaFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__MesaClient<Mesa>, Prisma__MesaClient<MesaGetPayload<T>>>

    /**
     * Count the number of Mesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaCountArgs} args - Arguments to filter Mesas to count.
     * @example
     * // Count the number of Mesas
     * const count = await prisma.mesa.count({
     *   where: {
     *     // ... the filter for the Mesas we want to count
     *   }
     * })
    **/
    count<T extends MesaCountArgs>(
      args?: Subset<T, MesaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MesaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MesaAggregateArgs>(args: Subset<T, MesaAggregateArgs>): PrismaPromise<GetMesaAggregateType<T>>

    /**
     * Group by Mesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MesaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MesaGroupByArgs['orderBy'] }
        : { orderBy?: MesaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MesaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMesaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Mesa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MesaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    reservaciones<T extends ReservacionFindManyArgs = {}>(args?: Subset<T, ReservacionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reservacion>>, PrismaPromise<Array<ReservacionGetPayload<T>>>>;

    pedidos<T extends PedidoFindManyArgs = {}>(args?: Subset<T, PedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>;

    Sucursal<T extends SucursalArgs = {}>(args?: Subset<T, SucursalArgs>): CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>;

    EstadoMesa<T extends DisponibilidadMesaArgs = {}>(args?: Subset<T, DisponibilidadMesaArgs>): CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa | null >, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Mesa base type for findUnique actions
   */
  export type MesaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * Filter, which Mesa to fetch.
     * 
    **/
    where: MesaWhereUniqueInput
  }

  /**
   * Mesa: findUnique
   */
  export interface MesaFindUniqueArgs extends MesaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Mesa base type for findFirst actions
   */
  export type MesaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * Filter, which Mesa to fetch.
     * 
    **/
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     * 
    **/
    orderBy?: Enumerable<MesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mesas.
     * 
    **/
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mesas.
     * 
    **/
    distinct?: Enumerable<MesaScalarFieldEnum>
  }

  /**
   * Mesa: findFirst
   */
  export interface MesaFindFirstArgs extends MesaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Mesa findMany
   */
  export type MesaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * Filter, which Mesas to fetch.
     * 
    **/
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     * 
    **/
    orderBy?: Enumerable<MesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mesas.
     * 
    **/
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MesaScalarFieldEnum>
  }


  /**
   * Mesa create
   */
  export type MesaCreateArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * The data needed to create a Mesa.
     * 
    **/
    data: XOR<MesaCreateInput, MesaUncheckedCreateInput>
  }


  /**
   * Mesa createMany
   */
  export type MesaCreateManyArgs = {
    /**
     * The data used to create many Mesas.
     * 
    **/
    data: Enumerable<MesaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Mesa update
   */
  export type MesaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * The data needed to update a Mesa.
     * 
    **/
    data: XOR<MesaUpdateInput, MesaUncheckedUpdateInput>
    /**
     * Choose, which Mesa to update.
     * 
    **/
    where: MesaWhereUniqueInput
  }


  /**
   * Mesa updateMany
   */
  export type MesaUpdateManyArgs = {
    /**
     * The data used to update Mesas.
     * 
    **/
    data: XOR<MesaUpdateManyMutationInput, MesaUncheckedUpdateManyInput>
    /**
     * Filter which Mesas to update
     * 
    **/
    where?: MesaWhereInput
  }


  /**
   * Mesa upsert
   */
  export type MesaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * The filter to search for the Mesa to update in case it exists.
     * 
    **/
    where: MesaWhereUniqueInput
    /**
     * In case the Mesa found by the `where` argument doesn't exist, create a new Mesa with this data.
     * 
    **/
    create: XOR<MesaCreateInput, MesaUncheckedCreateInput>
    /**
     * In case the Mesa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MesaUpdateInput, MesaUncheckedUpdateInput>
  }


  /**
   * Mesa delete
   */
  export type MesaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
    /**
     * Filter which Mesa to delete.
     * 
    **/
    where: MesaWhereUniqueInput
  }


  /**
   * Mesa deleteMany
   */
  export type MesaDeleteManyArgs = {
    /**
     * Filter which Mesas to delete
     * 
    **/
    where?: MesaWhereInput
  }


  /**
   * Mesa: findUniqueOrThrow
   */
  export type MesaFindUniqueOrThrowArgs = MesaFindUniqueArgsBase
      

  /**
   * Mesa: findFirstOrThrow
   */
  export type MesaFindFirstOrThrowArgs = MesaFindFirstArgsBase
      

  /**
   * Mesa without action
   */
  export type MesaArgs = {
    /**
     * Select specific fields to fetch from the Mesa
     * 
    **/
    select?: MesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MesaInclude | null
  }



  /**
   * Model DisponibilidadMesa
   */


  export type AggregateDisponibilidadMesa = {
    _count: DisponibilidadMesaCountAggregateOutputType | null
    _avg: DisponibilidadMesaAvgAggregateOutputType | null
    _sum: DisponibilidadMesaSumAggregateOutputType | null
    _min: DisponibilidadMesaMinAggregateOutputType | null
    _max: DisponibilidadMesaMaxAggregateOutputType | null
  }

  export type DisponibilidadMesaAvgAggregateOutputType = {
    id: number | null
  }

  export type DisponibilidadMesaSumAggregateOutputType = {
    id: number | null
  }

  export type DisponibilidadMesaMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type DisponibilidadMesaMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type DisponibilidadMesaCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type DisponibilidadMesaAvgAggregateInputType = {
    id?: true
  }

  export type DisponibilidadMesaSumAggregateInputType = {
    id?: true
  }

  export type DisponibilidadMesaMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type DisponibilidadMesaMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type DisponibilidadMesaCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type DisponibilidadMesaAggregateArgs = {
    /**
     * Filter which DisponibilidadMesa to aggregate.
     * 
    **/
    where?: DisponibilidadMesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibilidadMesas to fetch.
     * 
    **/
    orderBy?: Enumerable<DisponibilidadMesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DisponibilidadMesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibilidadMesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibilidadMesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisponibilidadMesas
    **/
    _count?: true | DisponibilidadMesaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisponibilidadMesaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisponibilidadMesaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisponibilidadMesaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisponibilidadMesaMaxAggregateInputType
  }

  export type GetDisponibilidadMesaAggregateType<T extends DisponibilidadMesaAggregateArgs> = {
        [P in keyof T & keyof AggregateDisponibilidadMesa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisponibilidadMesa[P]>
      : GetScalarType<T[P], AggregateDisponibilidadMesa[P]>
  }




  export type DisponibilidadMesaGroupByArgs = {
    where?: DisponibilidadMesaWhereInput
    orderBy?: Enumerable<DisponibilidadMesaOrderByWithAggregationInput>
    by: Array<DisponibilidadMesaScalarFieldEnum>
    having?: DisponibilidadMesaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisponibilidadMesaCountAggregateInputType | true
    _avg?: DisponibilidadMesaAvgAggregateInputType
    _sum?: DisponibilidadMesaSumAggregateInputType
    _min?: DisponibilidadMesaMinAggregateInputType
    _max?: DisponibilidadMesaMaxAggregateInputType
  }


  export type DisponibilidadMesaGroupByOutputType = {
    id: number
    descripcion: string
    _count: DisponibilidadMesaCountAggregateOutputType | null
    _avg: DisponibilidadMesaAvgAggregateOutputType | null
    _sum: DisponibilidadMesaSumAggregateOutputType | null
    _min: DisponibilidadMesaMinAggregateOutputType | null
    _max: DisponibilidadMesaMaxAggregateOutputType | null
  }

  type GetDisponibilidadMesaGroupByPayload<T extends DisponibilidadMesaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DisponibilidadMesaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisponibilidadMesaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisponibilidadMesaGroupByOutputType[P]>
            : GetScalarType<T[P], DisponibilidadMesaGroupByOutputType[P]>
        }
      >
    >


  export type DisponibilidadMesaSelect = {
    id?: boolean
    descripcion?: boolean
    mesas?: boolean | MesaFindManyArgs
    _count?: boolean | DisponibilidadMesaCountOutputTypeArgs
  }

  export type DisponibilidadMesaInclude = {
    mesas?: boolean | MesaFindManyArgs
    _count?: boolean | DisponibilidadMesaCountOutputTypeArgs
  }

  export type DisponibilidadMesaGetPayload<
    S extends boolean | null | undefined | DisponibilidadMesaArgs,
    U = keyof S
      > = S extends true
        ? DisponibilidadMesa
    : S extends undefined
    ? never
    : S extends DisponibilidadMesaArgs | DisponibilidadMesaFindManyArgs
    ?'include' extends U
    ? DisponibilidadMesa  & {
    [P in TrueKeys<S['include']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? DisponibilidadMesaCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? DisponibilidadMesaCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof DisponibilidadMesa ? DisponibilidadMesa[P] : never
  } 
    : DisponibilidadMesa
  : DisponibilidadMesa


  type DisponibilidadMesaCountArgs = Merge<
    Omit<DisponibilidadMesaFindManyArgs, 'select' | 'include'> & {
      select?: DisponibilidadMesaCountAggregateInputType | true
    }
  >

  export interface DisponibilidadMesaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DisponibilidadMesa that matches the filter.
     * @param {DisponibilidadMesaFindUniqueArgs} args - Arguments to find a DisponibilidadMesa
     * @example
     * // Get one DisponibilidadMesa
     * const disponibilidadMesa = await prisma.disponibilidadMesa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DisponibilidadMesaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DisponibilidadMesaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DisponibilidadMesa'> extends True ? CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa>, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T>>> : CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa | null >, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T> | null >>

    /**
     * Find the first DisponibilidadMesa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadMesaFindFirstArgs} args - Arguments to find a DisponibilidadMesa
     * @example
     * // Get one DisponibilidadMesa
     * const disponibilidadMesa = await prisma.disponibilidadMesa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DisponibilidadMesaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DisponibilidadMesaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DisponibilidadMesa'> extends True ? CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa>, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T>>> : CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa | null >, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T> | null >>

    /**
     * Find zero or more DisponibilidadMesas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadMesaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisponibilidadMesas
     * const disponibilidadMesas = await prisma.disponibilidadMesa.findMany()
     * 
     * // Get first 10 DisponibilidadMesas
     * const disponibilidadMesas = await prisma.disponibilidadMesa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disponibilidadMesaWithIdOnly = await prisma.disponibilidadMesa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DisponibilidadMesaFindManyArgs>(
      args?: SelectSubset<T, DisponibilidadMesaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DisponibilidadMesa>>, PrismaPromise<Array<DisponibilidadMesaGetPayload<T>>>>

    /**
     * Create a DisponibilidadMesa.
     * @param {DisponibilidadMesaCreateArgs} args - Arguments to create a DisponibilidadMesa.
     * @example
     * // Create one DisponibilidadMesa
     * const DisponibilidadMesa = await prisma.disponibilidadMesa.create({
     *   data: {
     *     // ... data to create a DisponibilidadMesa
     *   }
     * })
     * 
    **/
    create<T extends DisponibilidadMesaCreateArgs>(
      args: SelectSubset<T, DisponibilidadMesaCreateArgs>
    ): CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa>, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T>>>

    /**
     * Create many DisponibilidadMesas.
     *     @param {DisponibilidadMesaCreateManyArgs} args - Arguments to create many DisponibilidadMesas.
     *     @example
     *     // Create many DisponibilidadMesas
     *     const disponibilidadMesa = await prisma.disponibilidadMesa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DisponibilidadMesaCreateManyArgs>(
      args?: SelectSubset<T, DisponibilidadMesaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DisponibilidadMesa.
     * @param {DisponibilidadMesaDeleteArgs} args - Arguments to delete one DisponibilidadMesa.
     * @example
     * // Delete one DisponibilidadMesa
     * const DisponibilidadMesa = await prisma.disponibilidadMesa.delete({
     *   where: {
     *     // ... filter to delete one DisponibilidadMesa
     *   }
     * })
     * 
    **/
    delete<T extends DisponibilidadMesaDeleteArgs>(
      args: SelectSubset<T, DisponibilidadMesaDeleteArgs>
    ): CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa>, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T>>>

    /**
     * Update one DisponibilidadMesa.
     * @param {DisponibilidadMesaUpdateArgs} args - Arguments to update one DisponibilidadMesa.
     * @example
     * // Update one DisponibilidadMesa
     * const disponibilidadMesa = await prisma.disponibilidadMesa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DisponibilidadMesaUpdateArgs>(
      args: SelectSubset<T, DisponibilidadMesaUpdateArgs>
    ): CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa>, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T>>>

    /**
     * Delete zero or more DisponibilidadMesas.
     * @param {DisponibilidadMesaDeleteManyArgs} args - Arguments to filter DisponibilidadMesas to delete.
     * @example
     * // Delete a few DisponibilidadMesas
     * const { count } = await prisma.disponibilidadMesa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DisponibilidadMesaDeleteManyArgs>(
      args?: SelectSubset<T, DisponibilidadMesaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisponibilidadMesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadMesaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisponibilidadMesas
     * const disponibilidadMesa = await prisma.disponibilidadMesa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DisponibilidadMesaUpdateManyArgs>(
      args: SelectSubset<T, DisponibilidadMesaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DisponibilidadMesa.
     * @param {DisponibilidadMesaUpsertArgs} args - Arguments to update or create a DisponibilidadMesa.
     * @example
     * // Update or create a DisponibilidadMesa
     * const disponibilidadMesa = await prisma.disponibilidadMesa.upsert({
     *   create: {
     *     // ... data to create a DisponibilidadMesa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisponibilidadMesa we want to update
     *   }
     * })
    **/
    upsert<T extends DisponibilidadMesaUpsertArgs>(
      args: SelectSubset<T, DisponibilidadMesaUpsertArgs>
    ): CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa>, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T>>>

    /**
     * Find one DisponibilidadMesa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DisponibilidadMesaFindUniqueOrThrowArgs} args - Arguments to find a DisponibilidadMesa
     * @example
     * // Get one DisponibilidadMesa
     * const disponibilidadMesa = await prisma.disponibilidadMesa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DisponibilidadMesaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DisponibilidadMesaFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa>, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T>>>

    /**
     * Find the first DisponibilidadMesa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadMesaFindFirstOrThrowArgs} args - Arguments to find a DisponibilidadMesa
     * @example
     * // Get one DisponibilidadMesa
     * const disponibilidadMesa = await prisma.disponibilidadMesa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DisponibilidadMesaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DisponibilidadMesaFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DisponibilidadMesaClient<DisponibilidadMesa>, Prisma__DisponibilidadMesaClient<DisponibilidadMesaGetPayload<T>>>

    /**
     * Count the number of DisponibilidadMesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadMesaCountArgs} args - Arguments to filter DisponibilidadMesas to count.
     * @example
     * // Count the number of DisponibilidadMesas
     * const count = await prisma.disponibilidadMesa.count({
     *   where: {
     *     // ... the filter for the DisponibilidadMesas we want to count
     *   }
     * })
    **/
    count<T extends DisponibilidadMesaCountArgs>(
      args?: Subset<T, DisponibilidadMesaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisponibilidadMesaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisponibilidadMesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadMesaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisponibilidadMesaAggregateArgs>(args: Subset<T, DisponibilidadMesaAggregateArgs>): PrismaPromise<GetDisponibilidadMesaAggregateType<T>>

    /**
     * Group by DisponibilidadMesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadMesaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisponibilidadMesaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisponibilidadMesaGroupByArgs['orderBy'] }
        : { orderBy?: DisponibilidadMesaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisponibilidadMesaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisponibilidadMesaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DisponibilidadMesa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DisponibilidadMesaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    mesas<T extends MesaFindManyArgs = {}>(args?: Subset<T, MesaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mesa>>, PrismaPromise<Array<MesaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DisponibilidadMesa base type for findUnique actions
   */
  export type DisponibilidadMesaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DisponibilidadMesa
     * 
    **/
    select?: DisponibilidadMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DisponibilidadMesaInclude | null
    /**
     * Filter, which DisponibilidadMesa to fetch.
     * 
    **/
    where: DisponibilidadMesaWhereUniqueInput
  }

  /**
   * DisponibilidadMesa: findUnique
   */
  export interface DisponibilidadMesaFindUniqueArgs extends DisponibilidadMesaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DisponibilidadMesa base type for findFirst actions
   */
  export type DisponibilidadMesaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DisponibilidadMesa
     * 
    **/
    select?: DisponibilidadMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DisponibilidadMesaInclude | null
    /**
     * Filter, which DisponibilidadMesa to fetch.
     * 
    **/
    where?: DisponibilidadMesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibilidadMesas to fetch.
     * 
    **/
    orderBy?: Enumerable<DisponibilidadMesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisponibilidadMesas.
     * 
    **/
    cursor?: DisponibilidadMesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibilidadMesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibilidadMesas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisponibilidadMesas.
     * 
    **/
    distinct?: Enumerable<DisponibilidadMesaScalarFieldEnum>
  }

  /**
   * DisponibilidadMesa: findFirst
   */
  export interface DisponibilidadMesaFindFirstArgs extends DisponibilidadMesaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DisponibilidadMesa findMany
   */
  export type DisponibilidadMesaFindManyArgs = {
    /**
     * Select specific fields to fetch from the DisponibilidadMesa
     * 
    **/
    select?: DisponibilidadMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DisponibilidadMesaInclude | null
    /**
     * Filter, which DisponibilidadMesas to fetch.
     * 
    **/
    where?: DisponibilidadMesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibilidadMesas to fetch.
     * 
    **/
    orderBy?: Enumerable<DisponibilidadMesaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisponibilidadMesas.
     * 
    **/
    cursor?: DisponibilidadMesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibilidadMesas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibilidadMesas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DisponibilidadMesaScalarFieldEnum>
  }


  /**
   * DisponibilidadMesa create
   */
  export type DisponibilidadMesaCreateArgs = {
    /**
     * Select specific fields to fetch from the DisponibilidadMesa
     * 
    **/
    select?: DisponibilidadMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DisponibilidadMesaInclude | null
    /**
     * The data needed to create a DisponibilidadMesa.
     * 
    **/
    data: XOR<DisponibilidadMesaCreateInput, DisponibilidadMesaUncheckedCreateInput>
  }


  /**
   * DisponibilidadMesa createMany
   */
  export type DisponibilidadMesaCreateManyArgs = {
    /**
     * The data used to create many DisponibilidadMesas.
     * 
    **/
    data: Enumerable<DisponibilidadMesaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DisponibilidadMesa update
   */
  export type DisponibilidadMesaUpdateArgs = {
    /**
     * Select specific fields to fetch from the DisponibilidadMesa
     * 
    **/
    select?: DisponibilidadMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DisponibilidadMesaInclude | null
    /**
     * The data needed to update a DisponibilidadMesa.
     * 
    **/
    data: XOR<DisponibilidadMesaUpdateInput, DisponibilidadMesaUncheckedUpdateInput>
    /**
     * Choose, which DisponibilidadMesa to update.
     * 
    **/
    where: DisponibilidadMesaWhereUniqueInput
  }


  /**
   * DisponibilidadMesa updateMany
   */
  export type DisponibilidadMesaUpdateManyArgs = {
    /**
     * The data used to update DisponibilidadMesas.
     * 
    **/
    data: XOR<DisponibilidadMesaUpdateManyMutationInput, DisponibilidadMesaUncheckedUpdateManyInput>
    /**
     * Filter which DisponibilidadMesas to update
     * 
    **/
    where?: DisponibilidadMesaWhereInput
  }


  /**
   * DisponibilidadMesa upsert
   */
  export type DisponibilidadMesaUpsertArgs = {
    /**
     * Select specific fields to fetch from the DisponibilidadMesa
     * 
    **/
    select?: DisponibilidadMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DisponibilidadMesaInclude | null
    /**
     * The filter to search for the DisponibilidadMesa to update in case it exists.
     * 
    **/
    where: DisponibilidadMesaWhereUniqueInput
    /**
     * In case the DisponibilidadMesa found by the `where` argument doesn't exist, create a new DisponibilidadMesa with this data.
     * 
    **/
    create: XOR<DisponibilidadMesaCreateInput, DisponibilidadMesaUncheckedCreateInput>
    /**
     * In case the DisponibilidadMesa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DisponibilidadMesaUpdateInput, DisponibilidadMesaUncheckedUpdateInput>
  }


  /**
   * DisponibilidadMesa delete
   */
  export type DisponibilidadMesaDeleteArgs = {
    /**
     * Select specific fields to fetch from the DisponibilidadMesa
     * 
    **/
    select?: DisponibilidadMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DisponibilidadMesaInclude | null
    /**
     * Filter which DisponibilidadMesa to delete.
     * 
    **/
    where: DisponibilidadMesaWhereUniqueInput
  }


  /**
   * DisponibilidadMesa deleteMany
   */
  export type DisponibilidadMesaDeleteManyArgs = {
    /**
     * Filter which DisponibilidadMesas to delete
     * 
    **/
    where?: DisponibilidadMesaWhereInput
  }


  /**
   * DisponibilidadMesa: findUniqueOrThrow
   */
  export type DisponibilidadMesaFindUniqueOrThrowArgs = DisponibilidadMesaFindUniqueArgsBase
      

  /**
   * DisponibilidadMesa: findFirstOrThrow
   */
  export type DisponibilidadMesaFindFirstOrThrowArgs = DisponibilidadMesaFindFirstArgsBase
      

  /**
   * DisponibilidadMesa without action
   */
  export type DisponibilidadMesaArgs = {
    /**
     * Select specific fields to fetch from the DisponibilidadMesa
     * 
    **/
    select?: DisponibilidadMesaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DisponibilidadMesaInclude | null
  }



  /**
   * Model Reservacion
   */


  export type AggregateReservacion = {
    _count: ReservacionCountAggregateOutputType | null
    _avg: ReservacionAvgAggregateOutputType | null
    _sum: ReservacionSumAggregateOutputType | null
    _min: ReservacionMinAggregateOutputType | null
    _max: ReservacionMaxAggregateOutputType | null
  }

  export type ReservacionAvgAggregateOutputType = {
    id: number | null
    cantidad: number | null
    idSucursal: number | null
  }

  export type ReservacionSumAggregateOutputType = {
    id: number | null
    cantidad: number | null
    idSucursal: number | null
  }

  export type ReservacionMinAggregateOutputType = {
    id: number | null
    fecha_hora: Date | null
    cantidad: number | null
    idSucursal: number | null
    idUsuario: string | null
  }

  export type ReservacionMaxAggregateOutputType = {
    id: number | null
    fecha_hora: Date | null
    cantidad: number | null
    idSucursal: number | null
    idUsuario: string | null
  }

  export type ReservacionCountAggregateOutputType = {
    id: number
    fecha_hora: number
    cantidad: number
    idSucursal: number
    idUsuario: number
    _all: number
  }


  export type ReservacionAvgAggregateInputType = {
    id?: true
    cantidad?: true
    idSucursal?: true
  }

  export type ReservacionSumAggregateInputType = {
    id?: true
    cantidad?: true
    idSucursal?: true
  }

  export type ReservacionMinAggregateInputType = {
    id?: true
    fecha_hora?: true
    cantidad?: true
    idSucursal?: true
    idUsuario?: true
  }

  export type ReservacionMaxAggregateInputType = {
    id?: true
    fecha_hora?: true
    cantidad?: true
    idSucursal?: true
    idUsuario?: true
  }

  export type ReservacionCountAggregateInputType = {
    id?: true
    fecha_hora?: true
    cantidad?: true
    idSucursal?: true
    idUsuario?: true
    _all?: true
  }

  export type ReservacionAggregateArgs = {
    /**
     * Filter which Reservacion to aggregate.
     * 
    **/
    where?: ReservacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservacions to fetch.
     * 
    **/
    orderBy?: Enumerable<ReservacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReservacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservacions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservacions
    **/
    _count?: true | ReservacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservacionMaxAggregateInputType
  }

  export type GetReservacionAggregateType<T extends ReservacionAggregateArgs> = {
        [P in keyof T & keyof AggregateReservacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservacion[P]>
      : GetScalarType<T[P], AggregateReservacion[P]>
  }




  export type ReservacionGroupByArgs = {
    where?: ReservacionWhereInput
    orderBy?: Enumerable<ReservacionOrderByWithAggregationInput>
    by: Array<ReservacionScalarFieldEnum>
    having?: ReservacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservacionCountAggregateInputType | true
    _avg?: ReservacionAvgAggregateInputType
    _sum?: ReservacionSumAggregateInputType
    _min?: ReservacionMinAggregateInputType
    _max?: ReservacionMaxAggregateInputType
  }


  export type ReservacionGroupByOutputType = {
    id: number
    fecha_hora: Date
    cantidad: number
    idSucursal: number
    idUsuario: string
    _count: ReservacionCountAggregateOutputType | null
    _avg: ReservacionAvgAggregateOutputType | null
    _sum: ReservacionSumAggregateOutputType | null
    _min: ReservacionMinAggregateOutputType | null
    _max: ReservacionMaxAggregateOutputType | null
  }

  type GetReservacionGroupByPayload<T extends ReservacionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReservacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservacionGroupByOutputType[P]>
            : GetScalarType<T[P], ReservacionGroupByOutputType[P]>
        }
      >
    >


  export type ReservacionSelect = {
    id?: boolean
    fecha_hora?: boolean
    cantidad?: boolean
    mesas?: boolean | MesaFindManyArgs
    Sucursal?: boolean | SucursalArgs
    idSucursal?: boolean
    Usuario?: boolean | UsuarioArgs
    idUsuario?: boolean
    _count?: boolean | ReservacionCountOutputTypeArgs
  }

  export type ReservacionInclude = {
    mesas?: boolean | MesaFindManyArgs
    Sucursal?: boolean | SucursalArgs
    Usuario?: boolean | UsuarioArgs
    _count?: boolean | ReservacionCountOutputTypeArgs
  }

  export type ReservacionGetPayload<
    S extends boolean | null | undefined | ReservacionArgs,
    U = keyof S
      > = S extends true
        ? Reservacion
    : S extends undefined
    ? never
    : S extends ReservacionArgs | ReservacionFindManyArgs
    ?'include' extends U
    ? Reservacion  & {
    [P in TrueKeys<S['include']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? ReservacionCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'mesas' ? Array < MesaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? ReservacionCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Reservacion ? Reservacion[P] : never
  } 
    : Reservacion
  : Reservacion


  type ReservacionCountArgs = Merge<
    Omit<ReservacionFindManyArgs, 'select' | 'include'> & {
      select?: ReservacionCountAggregateInputType | true
    }
  >

  export interface ReservacionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reservacion that matches the filter.
     * @param {ReservacionFindUniqueArgs} args - Arguments to find a Reservacion
     * @example
     * // Get one Reservacion
     * const reservacion = await prisma.reservacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReservacionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReservacionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reservacion'> extends True ? CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>> : CheckSelect<T, Prisma__ReservacionClient<Reservacion | null >, Prisma__ReservacionClient<ReservacionGetPayload<T> | null >>

    /**
     * Find the first Reservacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionFindFirstArgs} args - Arguments to find a Reservacion
     * @example
     * // Get one Reservacion
     * const reservacion = await prisma.reservacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReservacionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReservacionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reservacion'> extends True ? CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>> : CheckSelect<T, Prisma__ReservacionClient<Reservacion | null >, Prisma__ReservacionClient<ReservacionGetPayload<T> | null >>

    /**
     * Find zero or more Reservacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservacions
     * const reservacions = await prisma.reservacion.findMany()
     * 
     * // Get first 10 Reservacions
     * const reservacions = await prisma.reservacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservacionWithIdOnly = await prisma.reservacion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReservacionFindManyArgs>(
      args?: SelectSubset<T, ReservacionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Reservacion>>, PrismaPromise<Array<ReservacionGetPayload<T>>>>

    /**
     * Create a Reservacion.
     * @param {ReservacionCreateArgs} args - Arguments to create a Reservacion.
     * @example
     * // Create one Reservacion
     * const Reservacion = await prisma.reservacion.create({
     *   data: {
     *     // ... data to create a Reservacion
     *   }
     * })
     * 
    **/
    create<T extends ReservacionCreateArgs>(
      args: SelectSubset<T, ReservacionCreateArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Create many Reservacions.
     *     @param {ReservacionCreateManyArgs} args - Arguments to create many Reservacions.
     *     @example
     *     // Create many Reservacions
     *     const reservacion = await prisma.reservacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReservacionCreateManyArgs>(
      args?: SelectSubset<T, ReservacionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reservacion.
     * @param {ReservacionDeleteArgs} args - Arguments to delete one Reservacion.
     * @example
     * // Delete one Reservacion
     * const Reservacion = await prisma.reservacion.delete({
     *   where: {
     *     // ... filter to delete one Reservacion
     *   }
     * })
     * 
    **/
    delete<T extends ReservacionDeleteArgs>(
      args: SelectSubset<T, ReservacionDeleteArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Update one Reservacion.
     * @param {ReservacionUpdateArgs} args - Arguments to update one Reservacion.
     * @example
     * // Update one Reservacion
     * const reservacion = await prisma.reservacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReservacionUpdateArgs>(
      args: SelectSubset<T, ReservacionUpdateArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Delete zero or more Reservacions.
     * @param {ReservacionDeleteManyArgs} args - Arguments to filter Reservacions to delete.
     * @example
     * // Delete a few Reservacions
     * const { count } = await prisma.reservacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReservacionDeleteManyArgs>(
      args?: SelectSubset<T, ReservacionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservacions
     * const reservacion = await prisma.reservacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReservacionUpdateManyArgs>(
      args: SelectSubset<T, ReservacionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservacion.
     * @param {ReservacionUpsertArgs} args - Arguments to update or create a Reservacion.
     * @example
     * // Update or create a Reservacion
     * const reservacion = await prisma.reservacion.upsert({
     *   create: {
     *     // ... data to create a Reservacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservacion we want to update
     *   }
     * })
    **/
    upsert<T extends ReservacionUpsertArgs>(
      args: SelectSubset<T, ReservacionUpsertArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Find one Reservacion that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ReservacionFindUniqueOrThrowArgs} args - Arguments to find a Reservacion
     * @example
     * // Get one Reservacion
     * const reservacion = await prisma.reservacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReservacionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReservacionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Find the first Reservacion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionFindFirstOrThrowArgs} args - Arguments to find a Reservacion
     * @example
     * // Get one Reservacion
     * const reservacion = await prisma.reservacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReservacionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReservacionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ReservacionClient<Reservacion>, Prisma__ReservacionClient<ReservacionGetPayload<T>>>

    /**
     * Count the number of Reservacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionCountArgs} args - Arguments to filter Reservacions to count.
     * @example
     * // Count the number of Reservacions
     * const count = await prisma.reservacion.count({
     *   where: {
     *     // ... the filter for the Reservacions we want to count
     *   }
     * })
    **/
    count<T extends ReservacionCountArgs>(
      args?: Subset<T, ReservacionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservacionAggregateArgs>(args: Subset<T, ReservacionAggregateArgs>): PrismaPromise<GetReservacionAggregateType<T>>

    /**
     * Group by Reservacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservacionGroupByArgs['orderBy'] }
        : { orderBy?: ReservacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservacionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReservacionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    mesas<T extends MesaFindManyArgs = {}>(args?: Subset<T, MesaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mesa>>, PrismaPromise<Array<MesaGetPayload<T>>>>;

    Sucursal<T extends SucursalArgs = {}>(args?: Subset<T, SucursalArgs>): CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>;

    Usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reservacion base type for findUnique actions
   */
  export type ReservacionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * Filter, which Reservacion to fetch.
     * 
    **/
    where: ReservacionWhereUniqueInput
  }

  /**
   * Reservacion: findUnique
   */
  export interface ReservacionFindUniqueArgs extends ReservacionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reservacion base type for findFirst actions
   */
  export type ReservacionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * Filter, which Reservacion to fetch.
     * 
    **/
    where?: ReservacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservacions to fetch.
     * 
    **/
    orderBy?: Enumerable<ReservacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservacions.
     * 
    **/
    cursor?: ReservacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservacions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservacions.
     * 
    **/
    distinct?: Enumerable<ReservacionScalarFieldEnum>
  }

  /**
   * Reservacion: findFirst
   */
  export interface ReservacionFindFirstArgs extends ReservacionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reservacion findMany
   */
  export type ReservacionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * Filter, which Reservacions to fetch.
     * 
    **/
    where?: ReservacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservacions to fetch.
     * 
    **/
    orderBy?: Enumerable<ReservacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservacions.
     * 
    **/
    cursor?: ReservacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservacions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservacions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReservacionScalarFieldEnum>
  }


  /**
   * Reservacion create
   */
  export type ReservacionCreateArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * The data needed to create a Reservacion.
     * 
    **/
    data: XOR<ReservacionCreateInput, ReservacionUncheckedCreateInput>
  }


  /**
   * Reservacion createMany
   */
  export type ReservacionCreateManyArgs = {
    /**
     * The data used to create many Reservacions.
     * 
    **/
    data: Enumerable<ReservacionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reservacion update
   */
  export type ReservacionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * The data needed to update a Reservacion.
     * 
    **/
    data: XOR<ReservacionUpdateInput, ReservacionUncheckedUpdateInput>
    /**
     * Choose, which Reservacion to update.
     * 
    **/
    where: ReservacionWhereUniqueInput
  }


  /**
   * Reservacion updateMany
   */
  export type ReservacionUpdateManyArgs = {
    /**
     * The data used to update Reservacions.
     * 
    **/
    data: XOR<ReservacionUpdateManyMutationInput, ReservacionUncheckedUpdateManyInput>
    /**
     * Filter which Reservacions to update
     * 
    **/
    where?: ReservacionWhereInput
  }


  /**
   * Reservacion upsert
   */
  export type ReservacionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * The filter to search for the Reservacion to update in case it exists.
     * 
    **/
    where: ReservacionWhereUniqueInput
    /**
     * In case the Reservacion found by the `where` argument doesn't exist, create a new Reservacion with this data.
     * 
    **/
    create: XOR<ReservacionCreateInput, ReservacionUncheckedCreateInput>
    /**
     * In case the Reservacion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReservacionUpdateInput, ReservacionUncheckedUpdateInput>
  }


  /**
   * Reservacion delete
   */
  export type ReservacionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
    /**
     * Filter which Reservacion to delete.
     * 
    **/
    where: ReservacionWhereUniqueInput
  }


  /**
   * Reservacion deleteMany
   */
  export type ReservacionDeleteManyArgs = {
    /**
     * Filter which Reservacions to delete
     * 
    **/
    where?: ReservacionWhereInput
  }


  /**
   * Reservacion: findUniqueOrThrow
   */
  export type ReservacionFindUniqueOrThrowArgs = ReservacionFindUniqueArgsBase
      

  /**
   * Reservacion: findFirstOrThrow
   */
  export type ReservacionFindFirstOrThrowArgs = ReservacionFindFirstArgsBase
      

  /**
   * Reservacion without action
   */
  export type ReservacionArgs = {
    /**
     * Select specific fields to fetch from the Reservacion
     * 
    **/
    select?: ReservacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReservacionInclude | null
  }



  /**
   * Model Categoria_Producto
   */


  export type AggregateCategoria_Producto = {
    _count: Categoria_ProductoCountAggregateOutputType | null
    _avg: Categoria_ProductoAvgAggregateOutputType | null
    _sum: Categoria_ProductoSumAggregateOutputType | null
    _min: Categoria_ProductoMinAggregateOutputType | null
    _max: Categoria_ProductoMaxAggregateOutputType | null
  }

  export type Categoria_ProductoAvgAggregateOutputType = {
    id: number | null
  }

  export type Categoria_ProductoSumAggregateOutputType = {
    id: number | null
  }

  export type Categoria_ProductoMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type Categoria_ProductoMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type Categoria_ProductoCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type Categoria_ProductoAvgAggregateInputType = {
    id?: true
  }

  export type Categoria_ProductoSumAggregateInputType = {
    id?: true
  }

  export type Categoria_ProductoMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type Categoria_ProductoMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type Categoria_ProductoCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type Categoria_ProductoAggregateArgs = {
    /**
     * Filter which Categoria_Producto to aggregate.
     * 
    **/
    where?: Categoria_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Categoria_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Categoria_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categoria_Productos
    **/
    _count?: true | Categoria_ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Categoria_ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Categoria_ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Categoria_ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Categoria_ProductoMaxAggregateInputType
  }

  export type GetCategoria_ProductoAggregateType<T extends Categoria_ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria_Producto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria_Producto[P]>
      : GetScalarType<T[P], AggregateCategoria_Producto[P]>
  }




  export type Categoria_ProductoGroupByArgs = {
    where?: Categoria_ProductoWhereInput
    orderBy?: Enumerable<Categoria_ProductoOrderByWithAggregationInput>
    by: Array<Categoria_ProductoScalarFieldEnum>
    having?: Categoria_ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Categoria_ProductoCountAggregateInputType | true
    _avg?: Categoria_ProductoAvgAggregateInputType
    _sum?: Categoria_ProductoSumAggregateInputType
    _min?: Categoria_ProductoMinAggregateInputType
    _max?: Categoria_ProductoMaxAggregateInputType
  }


  export type Categoria_ProductoGroupByOutputType = {
    id: number
    descripcion: string
    _count: Categoria_ProductoCountAggregateOutputType | null
    _avg: Categoria_ProductoAvgAggregateOutputType | null
    _sum: Categoria_ProductoSumAggregateOutputType | null
    _min: Categoria_ProductoMinAggregateOutputType | null
    _max: Categoria_ProductoMaxAggregateOutputType | null
  }

  type GetCategoria_ProductoGroupByPayload<T extends Categoria_ProductoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Categoria_ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Categoria_ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Categoria_ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], Categoria_ProductoGroupByOutputType[P]>
        }
      >
    >


  export type Categoria_ProductoSelect = {
    id?: boolean
    descripcion?: boolean
    productos?: boolean | ProductoFindManyArgs
    _count?: boolean | Categoria_ProductoCountOutputTypeArgs
  }

  export type Categoria_ProductoInclude = {
    productos?: boolean | ProductoFindManyArgs
    _count?: boolean | Categoria_ProductoCountOutputTypeArgs
  }

  export type Categoria_ProductoGetPayload<
    S extends boolean | null | undefined | Categoria_ProductoArgs,
    U = keyof S
      > = S extends true
        ? Categoria_Producto
    : S extends undefined
    ? never
    : S extends Categoria_ProductoArgs | Categoria_ProductoFindManyArgs
    ?'include' extends U
    ? Categoria_Producto  & {
    [P in TrueKeys<S['include']>]:
        P extends 'productos' ? Array < ProductoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Categoria_ProductoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'productos' ? Array < ProductoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Categoria_ProductoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Categoria_Producto ? Categoria_Producto[P] : never
  } 
    : Categoria_Producto
  : Categoria_Producto


  type Categoria_ProductoCountArgs = Merge<
    Omit<Categoria_ProductoFindManyArgs, 'select' | 'include'> & {
      select?: Categoria_ProductoCountAggregateInputType | true
    }
  >

  export interface Categoria_ProductoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Categoria_Producto that matches the filter.
     * @param {Categoria_ProductoFindUniqueArgs} args - Arguments to find a Categoria_Producto
     * @example
     * // Get one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Categoria_ProductoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Categoria_ProductoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Categoria_Producto'> extends True ? CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto | null >, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T> | null >>

    /**
     * Find the first Categoria_Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoFindFirstArgs} args - Arguments to find a Categoria_Producto
     * @example
     * // Get one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Categoria_ProductoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Categoria_ProductoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Categoria_Producto'> extends True ? CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto | null >, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T> | null >>

    /**
     * Find zero or more Categoria_Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categoria_Productos
     * const categoria_Productos = await prisma.categoria_Producto.findMany()
     * 
     * // Get first 10 Categoria_Productos
     * const categoria_Productos = await prisma.categoria_Producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoria_ProductoWithIdOnly = await prisma.categoria_Producto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Categoria_ProductoFindManyArgs>(
      args?: SelectSubset<T, Categoria_ProductoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Categoria_Producto>>, PrismaPromise<Array<Categoria_ProductoGetPayload<T>>>>

    /**
     * Create a Categoria_Producto.
     * @param {Categoria_ProductoCreateArgs} args - Arguments to create a Categoria_Producto.
     * @example
     * // Create one Categoria_Producto
     * const Categoria_Producto = await prisma.categoria_Producto.create({
     *   data: {
     *     // ... data to create a Categoria_Producto
     *   }
     * })
     * 
    **/
    create<T extends Categoria_ProductoCreateArgs>(
      args: SelectSubset<T, Categoria_ProductoCreateArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Create many Categoria_Productos.
     *     @param {Categoria_ProductoCreateManyArgs} args - Arguments to create many Categoria_Productos.
     *     @example
     *     // Create many Categoria_Productos
     *     const categoria_Producto = await prisma.categoria_Producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Categoria_ProductoCreateManyArgs>(
      args?: SelectSubset<T, Categoria_ProductoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria_Producto.
     * @param {Categoria_ProductoDeleteArgs} args - Arguments to delete one Categoria_Producto.
     * @example
     * // Delete one Categoria_Producto
     * const Categoria_Producto = await prisma.categoria_Producto.delete({
     *   where: {
     *     // ... filter to delete one Categoria_Producto
     *   }
     * })
     * 
    **/
    delete<T extends Categoria_ProductoDeleteArgs>(
      args: SelectSubset<T, Categoria_ProductoDeleteArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Update one Categoria_Producto.
     * @param {Categoria_ProductoUpdateArgs} args - Arguments to update one Categoria_Producto.
     * @example
     * // Update one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Categoria_ProductoUpdateArgs>(
      args: SelectSubset<T, Categoria_ProductoUpdateArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Delete zero or more Categoria_Productos.
     * @param {Categoria_ProductoDeleteManyArgs} args - Arguments to filter Categoria_Productos to delete.
     * @example
     * // Delete a few Categoria_Productos
     * const { count } = await prisma.categoria_Producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Categoria_ProductoDeleteManyArgs>(
      args?: SelectSubset<T, Categoria_ProductoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categoria_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categoria_Productos
     * const categoria_Producto = await prisma.categoria_Producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Categoria_ProductoUpdateManyArgs>(
      args: SelectSubset<T, Categoria_ProductoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria_Producto.
     * @param {Categoria_ProductoUpsertArgs} args - Arguments to update or create a Categoria_Producto.
     * @example
     * // Update or create a Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.upsert({
     *   create: {
     *     // ... data to create a Categoria_Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria_Producto we want to update
     *   }
     * })
    **/
    upsert<T extends Categoria_ProductoUpsertArgs>(
      args: SelectSubset<T, Categoria_ProductoUpsertArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Find one Categoria_Producto that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Categoria_ProductoFindUniqueOrThrowArgs} args - Arguments to find a Categoria_Producto
     * @example
     * // Get one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Categoria_ProductoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Categoria_ProductoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Find the first Categoria_Producto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoFindFirstOrThrowArgs} args - Arguments to find a Categoria_Producto
     * @example
     * // Get one Categoria_Producto
     * const categoria_Producto = await prisma.categoria_Producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Categoria_ProductoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Categoria_ProductoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto>, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T>>>

    /**
     * Count the number of Categoria_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoCountArgs} args - Arguments to filter Categoria_Productos to count.
     * @example
     * // Count the number of Categoria_Productos
     * const count = await prisma.categoria_Producto.count({
     *   where: {
     *     // ... the filter for the Categoria_Productos we want to count
     *   }
     * })
    **/
    count<T extends Categoria_ProductoCountArgs>(
      args?: Subset<T, Categoria_ProductoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Categoria_ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Categoria_ProductoAggregateArgs>(args: Subset<T, Categoria_ProductoAggregateArgs>): PrismaPromise<GetCategoria_ProductoAggregateType<T>>

    /**
     * Group by Categoria_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Categoria_ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Categoria_ProductoGroupByArgs['orderBy'] }
        : { orderBy?: Categoria_ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Categoria_ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoria_ProductoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria_Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Categoria_ProductoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    productos<T extends ProductoFindManyArgs = {}>(args?: Subset<T, ProductoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Producto>>, PrismaPromise<Array<ProductoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Categoria_Producto base type for findUnique actions
   */
  export type Categoria_ProductoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * Filter, which Categoria_Producto to fetch.
     * 
    **/
    where: Categoria_ProductoWhereUniqueInput
  }

  /**
   * Categoria_Producto: findUnique
   */
  export interface Categoria_ProductoFindUniqueArgs extends Categoria_ProductoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Categoria_Producto base type for findFirst actions
   */
  export type Categoria_ProductoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * Filter, which Categoria_Producto to fetch.
     * 
    **/
    where?: Categoria_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Categoria_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categoria_Productos.
     * 
    **/
    cursor?: Categoria_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categoria_Productos.
     * 
    **/
    distinct?: Enumerable<Categoria_ProductoScalarFieldEnum>
  }

  /**
   * Categoria_Producto: findFirst
   */
  export interface Categoria_ProductoFindFirstArgs extends Categoria_ProductoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Categoria_Producto findMany
   */
  export type Categoria_ProductoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * Filter, which Categoria_Productos to fetch.
     * 
    **/
    where?: Categoria_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Categoria_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categoria_Productos.
     * 
    **/
    cursor?: Categoria_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_Productos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Categoria_ProductoScalarFieldEnum>
  }


  /**
   * Categoria_Producto create
   */
  export type Categoria_ProductoCreateArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * The data needed to create a Categoria_Producto.
     * 
    **/
    data: XOR<Categoria_ProductoCreateInput, Categoria_ProductoUncheckedCreateInput>
  }


  /**
   * Categoria_Producto createMany
   */
  export type Categoria_ProductoCreateManyArgs = {
    /**
     * The data used to create many Categoria_Productos.
     * 
    **/
    data: Enumerable<Categoria_ProductoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Categoria_Producto update
   */
  export type Categoria_ProductoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * The data needed to update a Categoria_Producto.
     * 
    **/
    data: XOR<Categoria_ProductoUpdateInput, Categoria_ProductoUncheckedUpdateInput>
    /**
     * Choose, which Categoria_Producto to update.
     * 
    **/
    where: Categoria_ProductoWhereUniqueInput
  }


  /**
   * Categoria_Producto updateMany
   */
  export type Categoria_ProductoUpdateManyArgs = {
    /**
     * The data used to update Categoria_Productos.
     * 
    **/
    data: XOR<Categoria_ProductoUpdateManyMutationInput, Categoria_ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Categoria_Productos to update
     * 
    **/
    where?: Categoria_ProductoWhereInput
  }


  /**
   * Categoria_Producto upsert
   */
  export type Categoria_ProductoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * The filter to search for the Categoria_Producto to update in case it exists.
     * 
    **/
    where: Categoria_ProductoWhereUniqueInput
    /**
     * In case the Categoria_Producto found by the `where` argument doesn't exist, create a new Categoria_Producto with this data.
     * 
    **/
    create: XOR<Categoria_ProductoCreateInput, Categoria_ProductoUncheckedCreateInput>
    /**
     * In case the Categoria_Producto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Categoria_ProductoUpdateInput, Categoria_ProductoUncheckedUpdateInput>
  }


  /**
   * Categoria_Producto delete
   */
  export type Categoria_ProductoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
    /**
     * Filter which Categoria_Producto to delete.
     * 
    **/
    where: Categoria_ProductoWhereUniqueInput
  }


  /**
   * Categoria_Producto deleteMany
   */
  export type Categoria_ProductoDeleteManyArgs = {
    /**
     * Filter which Categoria_Productos to delete
     * 
    **/
    where?: Categoria_ProductoWhereInput
  }


  /**
   * Categoria_Producto: findUniqueOrThrow
   */
  export type Categoria_ProductoFindUniqueOrThrowArgs = Categoria_ProductoFindUniqueArgsBase
      

  /**
   * Categoria_Producto: findFirstOrThrow
   */
  export type Categoria_ProductoFindFirstOrThrowArgs = Categoria_ProductoFindFirstArgsBase
      

  /**
   * Categoria_Producto without action
   */
  export type Categoria_ProductoArgs = {
    /**
     * Select specific fields to fetch from the Categoria_Producto
     * 
    **/
    select?: Categoria_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Categoria_ProductoInclude | null
  }



  /**
   * Model Producto
   */


  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoAvgAggregateOutputType = {
    id: number | null
    precio: Decimal | null
    idCategoria: number | null
  }

  export type ProductoSumAggregateOutputType = {
    id: number | null
    precio: Decimal | null
    idCategoria: number | null
  }

  export type ProductoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    ingredientes: string | null
    precio: Decimal | null
    imagen: string | null
    estado: boolean | null
    idCategoria: number | null
  }

  export type ProductoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    ingredientes: string | null
    precio: Decimal | null
    imagen: string | null
    estado: boolean | null
    idCategoria: number | null
  }

  export type ProductoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    ingredientes: number
    precio: number
    imagen: number
    estado: number
    idCategoria: number
    _all: number
  }


  export type ProductoAvgAggregateInputType = {
    id?: true
    precio?: true
    idCategoria?: true
  }

  export type ProductoSumAggregateInputType = {
    id?: true
    precio?: true
    idCategoria?: true
  }

  export type ProductoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    ingredientes?: true
    precio?: true
    imagen?: true
    estado?: true
    idCategoria?: true
  }

  export type ProductoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    ingredientes?: true
    precio?: true
    imagen?: true
    estado?: true
    idCategoria?: true
  }

  export type ProductoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    ingredientes?: true
    precio?: true
    imagen?: true
    estado?: true
    idCategoria?: true
    _all?: true
  }

  export type ProductoAggregateArgs = {
    /**
     * Filter which Producto to aggregate.
     * 
    **/
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type ProductoGroupByArgs = {
    where?: ProductoWhereInput
    orderBy?: Enumerable<ProductoOrderByWithAggregationInput>
    by: Array<ProductoScalarFieldEnum>
    having?: ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _avg?: ProductoAvgAggregateInputType
    _sum?: ProductoSumAggregateInputType
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }


  export type ProductoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    ingredientes: string | null
    precio: Decimal
    imagen: string
    estado: boolean
    idCategoria: number
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type ProductoSelect = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    ingredientes?: boolean
    precio?: boolean
    imagen?: boolean
    estado?: boolean
    Categoria_Producto?: boolean | Categoria_ProductoArgs
    idCategoria?: boolean
    detalles?: boolean | Factura_DetalleFindManyArgs
    pedidos?: boolean | Pedido_ProductoFindManyArgs
    sucursales?: boolean | SucursalFindManyArgs
    _count?: boolean | ProductoCountOutputTypeArgs
  }

  export type ProductoInclude = {
    Categoria_Producto?: boolean | Categoria_ProductoArgs
    detalles?: boolean | Factura_DetalleFindManyArgs
    pedidos?: boolean | Pedido_ProductoFindManyArgs
    sucursales?: boolean | SucursalFindManyArgs
    _count?: boolean | ProductoCountOutputTypeArgs
  }

  export type ProductoGetPayload<
    S extends boolean | null | undefined | ProductoArgs,
    U = keyof S
      > = S extends true
        ? Producto
    : S extends undefined
    ? never
    : S extends ProductoArgs | ProductoFindManyArgs
    ?'include' extends U
    ? Producto  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Categoria_Producto' ? Categoria_ProductoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'detalles' ? Array < Factura_DetalleGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < Pedido_ProductoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sucursales' ? Array < SucursalGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ProductoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Categoria_Producto' ? Categoria_ProductoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'detalles' ? Array < Factura_DetalleGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < Pedido_ProductoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sucursales' ? Array < SucursalGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ProductoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Producto ? Producto[P] : never
  } 
    : Producto
  : Producto


  type ProductoCountArgs = Merge<
    Omit<ProductoFindManyArgs, 'select' | 'include'> & {
      select?: ProductoCountAggregateInputType | true
    }
  >

  export interface ProductoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Producto'> extends True ? CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>> : CheckSelect<T, Prisma__ProductoClient<Producto | null >, Prisma__ProductoClient<ProductoGetPayload<T> | null >>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Producto'> extends True ? CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>> : CheckSelect<T, Prisma__ProductoClient<Producto | null >, Prisma__ProductoClient<ProductoGetPayload<T> | null >>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productoWithIdOnly = await prisma.producto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductoFindManyArgs>(
      args?: SelectSubset<T, ProductoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Producto>>, PrismaPromise<Array<ProductoGetPayload<T>>>>

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
    **/
    create<T extends ProductoCreateArgs>(
      args: SelectSubset<T, ProductoCreateArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Create many Productos.
     *     @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     *     @example
     *     // Create many Productos
     *     const producto = await prisma.producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductoCreateManyArgs>(
      args?: SelectSubset<T, ProductoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
    **/
    delete<T extends ProductoDeleteArgs>(
      args: SelectSubset<T, ProductoDeleteArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductoUpdateArgs>(
      args: SelectSubset<T, ProductoUpdateArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductoDeleteManyArgs>(
      args?: SelectSubset<T, ProductoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductoUpdateManyArgs>(
      args: SelectSubset<T, ProductoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
    **/
    upsert<T extends ProductoUpsertArgs>(
      args: SelectSubset<T, ProductoUpsertArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Find one Producto that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Find the first Producto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Categoria_Producto<T extends Categoria_ProductoArgs = {}>(args?: Subset<T, Categoria_ProductoArgs>): CheckSelect<T, Prisma__Categoria_ProductoClient<Categoria_Producto | null >, Prisma__Categoria_ProductoClient<Categoria_ProductoGetPayload<T> | null >>;

    detalles<T extends Factura_DetalleFindManyArgs = {}>(args?: Subset<T, Factura_DetalleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Factura_Detalle>>, PrismaPromise<Array<Factura_DetalleGetPayload<T>>>>;

    pedidos<T extends Pedido_ProductoFindManyArgs = {}>(args?: Subset<T, Pedido_ProductoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido_Producto>>, PrismaPromise<Array<Pedido_ProductoGetPayload<T>>>>;

    sucursales<T extends SucursalFindManyArgs = {}>(args?: Subset<T, SucursalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Sucursal>>, PrismaPromise<Array<SucursalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Producto base type for findUnique actions
   */
  export type ProductoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter, which Producto to fetch.
     * 
    **/
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto: findUnique
   */
  export interface ProductoFindUniqueArgs extends ProductoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Producto base type for findFirst actions
   */
  export type ProductoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter, which Producto to fetch.
     * 
    **/
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     * 
    **/
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     * 
    **/
    distinct?: Enumerable<ProductoScalarFieldEnum>
  }

  /**
   * Producto: findFirst
   */
  export interface ProductoFindFirstArgs extends ProductoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter, which Productos to fetch.
     * 
    **/
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     * 
    **/
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductoScalarFieldEnum>
  }


  /**
   * Producto create
   */
  export type ProductoCreateArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * The data needed to create a Producto.
     * 
    **/
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
  }


  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs = {
    /**
     * The data used to create many Productos.
     * 
    **/
    data: Enumerable<ProductoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Producto update
   */
  export type ProductoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * The data needed to update a Producto.
     * 
    **/
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
    /**
     * Choose, which Producto to update.
     * 
    **/
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs = {
    /**
     * The data used to update Productos.
     * 
    **/
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     * 
    **/
    where?: ProductoWhereInput
  }


  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * The filter to search for the Producto to update in case it exists.
     * 
    **/
    where: ProductoWhereUniqueInput
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     * 
    **/
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
  }


  /**
   * Producto delete
   */
  export type ProductoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter which Producto to delete.
     * 
    **/
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs = {
    /**
     * Filter which Productos to delete
     * 
    **/
    where?: ProductoWhereInput
  }


  /**
   * Producto: findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs = ProductoFindUniqueArgsBase
      

  /**
   * Producto: findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs = ProductoFindFirstArgsBase
      

  /**
   * Producto without action
   */
  export type ProductoArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
  }



  /**
   * Model TipoPago
   */


  export type AggregateTipoPago = {
    _count: TipoPagoCountAggregateOutputType | null
    _avg: TipoPagoAvgAggregateOutputType | null
    _sum: TipoPagoSumAggregateOutputType | null
    _min: TipoPagoMinAggregateOutputType | null
    _max: TipoPagoMaxAggregateOutputType | null
  }

  export type TipoPagoAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoPagoSumAggregateOutputType = {
    id: number | null
  }

  export type TipoPagoMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type TipoPagoMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type TipoPagoCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type TipoPagoAvgAggregateInputType = {
    id?: true
  }

  export type TipoPagoSumAggregateInputType = {
    id?: true
  }

  export type TipoPagoMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type TipoPagoMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type TipoPagoCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type TipoPagoAggregateArgs = {
    /**
     * Filter which TipoPago to aggregate.
     * 
    **/
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoPagos
    **/
    _count?: true | TipoPagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoPagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoPagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoPagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoPagoMaxAggregateInputType
  }

  export type GetTipoPagoAggregateType<T extends TipoPagoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoPago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoPago[P]>
      : GetScalarType<T[P], AggregateTipoPago[P]>
  }




  export type TipoPagoGroupByArgs = {
    where?: TipoPagoWhereInput
    orderBy?: Enumerable<TipoPagoOrderByWithAggregationInput>
    by: Array<TipoPagoScalarFieldEnum>
    having?: TipoPagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoPagoCountAggregateInputType | true
    _avg?: TipoPagoAvgAggregateInputType
    _sum?: TipoPagoSumAggregateInputType
    _min?: TipoPagoMinAggregateInputType
    _max?: TipoPagoMaxAggregateInputType
  }


  export type TipoPagoGroupByOutputType = {
    id: number
    descripcion: string
    _count: TipoPagoCountAggregateOutputType | null
    _avg: TipoPagoAvgAggregateOutputType | null
    _sum: TipoPagoSumAggregateOutputType | null
    _min: TipoPagoMinAggregateOutputType | null
    _max: TipoPagoMaxAggregateOutputType | null
  }

  type GetTipoPagoGroupByPayload<T extends TipoPagoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TipoPagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoPagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoPagoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoPagoGroupByOutputType[P]>
        }
      >
    >


  export type TipoPagoSelect = {
    id?: boolean
    descripcion?: boolean
    facturasEncabezado?: boolean | FacturaEncabezadoTipoPagoFindManyArgs
    _count?: boolean | TipoPagoCountOutputTypeArgs
  }

  export type TipoPagoInclude = {
    facturasEncabezado?: boolean | FacturaEncabezadoTipoPagoFindManyArgs
    _count?: boolean | TipoPagoCountOutputTypeArgs
  }

  export type TipoPagoGetPayload<
    S extends boolean | null | undefined | TipoPagoArgs,
    U = keyof S
      > = S extends true
        ? TipoPago
    : S extends undefined
    ? never
    : S extends TipoPagoArgs | TipoPagoFindManyArgs
    ?'include' extends U
    ? TipoPago  & {
    [P in TrueKeys<S['include']>]:
        P extends 'facturasEncabezado' ? Array < FacturaEncabezadoTipoPagoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TipoPagoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'facturasEncabezado' ? Array < FacturaEncabezadoTipoPagoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TipoPagoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof TipoPago ? TipoPago[P] : never
  } 
    : TipoPago
  : TipoPago


  type TipoPagoCountArgs = Merge<
    Omit<TipoPagoFindManyArgs, 'select' | 'include'> & {
      select?: TipoPagoCountAggregateInputType | true
    }
  >

  export interface TipoPagoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TipoPago that matches the filter.
     * @param {TipoPagoFindUniqueArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TipoPagoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TipoPagoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TipoPago'> extends True ? CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>> : CheckSelect<T, Prisma__TipoPagoClient<TipoPago | null >, Prisma__TipoPagoClient<TipoPagoGetPayload<T> | null >>

    /**
     * Find the first TipoPago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoFindFirstArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TipoPagoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TipoPagoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TipoPago'> extends True ? CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>> : CheckSelect<T, Prisma__TipoPagoClient<TipoPago | null >, Prisma__TipoPagoClient<TipoPagoGetPayload<T> | null >>

    /**
     * Find zero or more TipoPagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoPagos
     * const tipoPagos = await prisma.tipoPago.findMany()
     * 
     * // Get first 10 TipoPagos
     * const tipoPagos = await prisma.tipoPago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoPagoWithIdOnly = await prisma.tipoPago.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TipoPagoFindManyArgs>(
      args?: SelectSubset<T, TipoPagoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TipoPago>>, PrismaPromise<Array<TipoPagoGetPayload<T>>>>

    /**
     * Create a TipoPago.
     * @param {TipoPagoCreateArgs} args - Arguments to create a TipoPago.
     * @example
     * // Create one TipoPago
     * const TipoPago = await prisma.tipoPago.create({
     *   data: {
     *     // ... data to create a TipoPago
     *   }
     * })
     * 
    **/
    create<T extends TipoPagoCreateArgs>(
      args: SelectSubset<T, TipoPagoCreateArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Create many TipoPagos.
     *     @param {TipoPagoCreateManyArgs} args - Arguments to create many TipoPagos.
     *     @example
     *     // Create many TipoPagos
     *     const tipoPago = await prisma.tipoPago.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TipoPagoCreateManyArgs>(
      args?: SelectSubset<T, TipoPagoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TipoPago.
     * @param {TipoPagoDeleteArgs} args - Arguments to delete one TipoPago.
     * @example
     * // Delete one TipoPago
     * const TipoPago = await prisma.tipoPago.delete({
     *   where: {
     *     // ... filter to delete one TipoPago
     *   }
     * })
     * 
    **/
    delete<T extends TipoPagoDeleteArgs>(
      args: SelectSubset<T, TipoPagoDeleteArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Update one TipoPago.
     * @param {TipoPagoUpdateArgs} args - Arguments to update one TipoPago.
     * @example
     * // Update one TipoPago
     * const tipoPago = await prisma.tipoPago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TipoPagoUpdateArgs>(
      args: SelectSubset<T, TipoPagoUpdateArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Delete zero or more TipoPagos.
     * @param {TipoPagoDeleteManyArgs} args - Arguments to filter TipoPagos to delete.
     * @example
     * // Delete a few TipoPagos
     * const { count } = await prisma.tipoPago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TipoPagoDeleteManyArgs>(
      args?: SelectSubset<T, TipoPagoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoPagos
     * const tipoPago = await prisma.tipoPago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TipoPagoUpdateManyArgs>(
      args: SelectSubset<T, TipoPagoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoPago.
     * @param {TipoPagoUpsertArgs} args - Arguments to update or create a TipoPago.
     * @example
     * // Update or create a TipoPago
     * const tipoPago = await prisma.tipoPago.upsert({
     *   create: {
     *     // ... data to create a TipoPago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoPago we want to update
     *   }
     * })
    **/
    upsert<T extends TipoPagoUpsertArgs>(
      args: SelectSubset<T, TipoPagoUpsertArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Find one TipoPago that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TipoPagoFindUniqueOrThrowArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TipoPagoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TipoPagoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Find the first TipoPago that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoFindFirstOrThrowArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TipoPagoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TipoPagoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TipoPagoClient<TipoPago>, Prisma__TipoPagoClient<TipoPagoGetPayload<T>>>

    /**
     * Count the number of TipoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoCountArgs} args - Arguments to filter TipoPagos to count.
     * @example
     * // Count the number of TipoPagos
     * const count = await prisma.tipoPago.count({
     *   where: {
     *     // ... the filter for the TipoPagos we want to count
     *   }
     * })
    **/
    count<T extends TipoPagoCountArgs>(
      args?: Subset<T, TipoPagoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoPagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoPagoAggregateArgs>(args: Subset<T, TipoPagoAggregateArgs>): PrismaPromise<GetTipoPagoAggregateType<T>>

    /**
     * Group by TipoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoPagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoPagoGroupByArgs['orderBy'] }
        : { orderBy?: TipoPagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoPagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoPagoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoPago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TipoPagoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    facturasEncabezado<T extends FacturaEncabezadoTipoPagoFindManyArgs = {}>(args?: Subset<T, FacturaEncabezadoTipoPagoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FacturaEncabezadoTipoPago>>, PrismaPromise<Array<FacturaEncabezadoTipoPagoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TipoPago base type for findUnique actions
   */
  export type TipoPagoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * Filter, which TipoPago to fetch.
     * 
    **/
    where: TipoPagoWhereUniqueInput
  }

  /**
   * TipoPago: findUnique
   */
  export interface TipoPagoFindUniqueArgs extends TipoPagoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoPago base type for findFirst actions
   */
  export type TipoPagoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * Filter, which TipoPago to fetch.
     * 
    **/
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoPagos.
     * 
    **/
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoPagos.
     * 
    **/
    distinct?: Enumerable<TipoPagoScalarFieldEnum>
  }

  /**
   * TipoPago: findFirst
   */
  export interface TipoPagoFindFirstArgs extends TipoPagoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoPago findMany
   */
  export type TipoPagoFindManyArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * Filter, which TipoPagos to fetch.
     * 
    **/
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoPagos.
     * 
    **/
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TipoPagoScalarFieldEnum>
  }


  /**
   * TipoPago create
   */
  export type TipoPagoCreateArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * The data needed to create a TipoPago.
     * 
    **/
    data: XOR<TipoPagoCreateInput, TipoPagoUncheckedCreateInput>
  }


  /**
   * TipoPago createMany
   */
  export type TipoPagoCreateManyArgs = {
    /**
     * The data used to create many TipoPagos.
     * 
    **/
    data: Enumerable<TipoPagoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TipoPago update
   */
  export type TipoPagoUpdateArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * The data needed to update a TipoPago.
     * 
    **/
    data: XOR<TipoPagoUpdateInput, TipoPagoUncheckedUpdateInput>
    /**
     * Choose, which TipoPago to update.
     * 
    **/
    where: TipoPagoWhereUniqueInput
  }


  /**
   * TipoPago updateMany
   */
  export type TipoPagoUpdateManyArgs = {
    /**
     * The data used to update TipoPagos.
     * 
    **/
    data: XOR<TipoPagoUpdateManyMutationInput, TipoPagoUncheckedUpdateManyInput>
    /**
     * Filter which TipoPagos to update
     * 
    **/
    where?: TipoPagoWhereInput
  }


  /**
   * TipoPago upsert
   */
  export type TipoPagoUpsertArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * The filter to search for the TipoPago to update in case it exists.
     * 
    **/
    where: TipoPagoWhereUniqueInput
    /**
     * In case the TipoPago found by the `where` argument doesn't exist, create a new TipoPago with this data.
     * 
    **/
    create: XOR<TipoPagoCreateInput, TipoPagoUncheckedCreateInput>
    /**
     * In case the TipoPago was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TipoPagoUpdateInput, TipoPagoUncheckedUpdateInput>
  }


  /**
   * TipoPago delete
   */
  export type TipoPagoDeleteArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
    /**
     * Filter which TipoPago to delete.
     * 
    **/
    where: TipoPagoWhereUniqueInput
  }


  /**
   * TipoPago deleteMany
   */
  export type TipoPagoDeleteManyArgs = {
    /**
     * Filter which TipoPagos to delete
     * 
    **/
    where?: TipoPagoWhereInput
  }


  /**
   * TipoPago: findUniqueOrThrow
   */
  export type TipoPagoFindUniqueOrThrowArgs = TipoPagoFindUniqueArgsBase
      

  /**
   * TipoPago: findFirstOrThrow
   */
  export type TipoPagoFindFirstOrThrowArgs = TipoPagoFindFirstArgsBase
      

  /**
   * TipoPago without action
   */
  export type TipoPagoArgs = {
    /**
     * Select specific fields to fetch from the TipoPago
     * 
    **/
    select?: TipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPagoInclude | null
  }



  /**
   * Model TipoTarjeta
   */


  export type AggregateTipoTarjeta = {
    _count: TipoTarjetaCountAggregateOutputType | null
    _avg: TipoTarjetaAvgAggregateOutputType | null
    _sum: TipoTarjetaSumAggregateOutputType | null
    _min: TipoTarjetaMinAggregateOutputType | null
    _max: TipoTarjetaMaxAggregateOutputType | null
  }

  export type TipoTarjetaAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoTarjetaSumAggregateOutputType = {
    id: number | null
  }

  export type TipoTarjetaMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type TipoTarjetaMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type TipoTarjetaCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type TipoTarjetaAvgAggregateInputType = {
    id?: true
  }

  export type TipoTarjetaSumAggregateInputType = {
    id?: true
  }

  export type TipoTarjetaMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type TipoTarjetaMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type TipoTarjetaCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type TipoTarjetaAggregateArgs = {
    /**
     * Filter which TipoTarjeta to aggregate.
     * 
    **/
    where?: TipoTarjetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoTarjetas to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoTarjetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TipoTarjetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoTarjetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoTarjetas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoTarjetas
    **/
    _count?: true | TipoTarjetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoTarjetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoTarjetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoTarjetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoTarjetaMaxAggregateInputType
  }

  export type GetTipoTarjetaAggregateType<T extends TipoTarjetaAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoTarjeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoTarjeta[P]>
      : GetScalarType<T[P], AggregateTipoTarjeta[P]>
  }




  export type TipoTarjetaGroupByArgs = {
    where?: TipoTarjetaWhereInput
    orderBy?: Enumerable<TipoTarjetaOrderByWithAggregationInput>
    by: Array<TipoTarjetaScalarFieldEnum>
    having?: TipoTarjetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoTarjetaCountAggregateInputType | true
    _avg?: TipoTarjetaAvgAggregateInputType
    _sum?: TipoTarjetaSumAggregateInputType
    _min?: TipoTarjetaMinAggregateInputType
    _max?: TipoTarjetaMaxAggregateInputType
  }


  export type TipoTarjetaGroupByOutputType = {
    id: number
    descripcion: string
    _count: TipoTarjetaCountAggregateOutputType | null
    _avg: TipoTarjetaAvgAggregateOutputType | null
    _sum: TipoTarjetaSumAggregateOutputType | null
    _min: TipoTarjetaMinAggregateOutputType | null
    _max: TipoTarjetaMaxAggregateOutputType | null
  }

  type GetTipoTarjetaGroupByPayload<T extends TipoTarjetaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TipoTarjetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoTarjetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoTarjetaGroupByOutputType[P]>
            : GetScalarType<T[P], TipoTarjetaGroupByOutputType[P]>
        }
      >
    >


  export type TipoTarjetaSelect = {
    id?: boolean
    descripcion?: boolean
    facturas?: boolean | Factura_EncabezadoFindManyArgs
    _count?: boolean | TipoTarjetaCountOutputTypeArgs
  }

  export type TipoTarjetaInclude = {
    facturas?: boolean | Factura_EncabezadoFindManyArgs
    _count?: boolean | TipoTarjetaCountOutputTypeArgs
  }

  export type TipoTarjetaGetPayload<
    S extends boolean | null | undefined | TipoTarjetaArgs,
    U = keyof S
      > = S extends true
        ? TipoTarjeta
    : S extends undefined
    ? never
    : S extends TipoTarjetaArgs | TipoTarjetaFindManyArgs
    ?'include' extends U
    ? TipoTarjeta  & {
    [P in TrueKeys<S['include']>]:
        P extends 'facturas' ? Array < Factura_EncabezadoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TipoTarjetaCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'facturas' ? Array < Factura_EncabezadoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TipoTarjetaCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof TipoTarjeta ? TipoTarjeta[P] : never
  } 
    : TipoTarjeta
  : TipoTarjeta


  type TipoTarjetaCountArgs = Merge<
    Omit<TipoTarjetaFindManyArgs, 'select' | 'include'> & {
      select?: TipoTarjetaCountAggregateInputType | true
    }
  >

  export interface TipoTarjetaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TipoTarjeta that matches the filter.
     * @param {TipoTarjetaFindUniqueArgs} args - Arguments to find a TipoTarjeta
     * @example
     * // Get one TipoTarjeta
     * const tipoTarjeta = await prisma.tipoTarjeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TipoTarjetaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TipoTarjetaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TipoTarjeta'> extends True ? CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta>, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T>>> : CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta | null >, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T> | null >>

    /**
     * Find the first TipoTarjeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoTarjetaFindFirstArgs} args - Arguments to find a TipoTarjeta
     * @example
     * // Get one TipoTarjeta
     * const tipoTarjeta = await prisma.tipoTarjeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TipoTarjetaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TipoTarjetaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TipoTarjeta'> extends True ? CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta>, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T>>> : CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta | null >, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T> | null >>

    /**
     * Find zero or more TipoTarjetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoTarjetaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoTarjetas
     * const tipoTarjetas = await prisma.tipoTarjeta.findMany()
     * 
     * // Get first 10 TipoTarjetas
     * const tipoTarjetas = await prisma.tipoTarjeta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoTarjetaWithIdOnly = await prisma.tipoTarjeta.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TipoTarjetaFindManyArgs>(
      args?: SelectSubset<T, TipoTarjetaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TipoTarjeta>>, PrismaPromise<Array<TipoTarjetaGetPayload<T>>>>

    /**
     * Create a TipoTarjeta.
     * @param {TipoTarjetaCreateArgs} args - Arguments to create a TipoTarjeta.
     * @example
     * // Create one TipoTarjeta
     * const TipoTarjeta = await prisma.tipoTarjeta.create({
     *   data: {
     *     // ... data to create a TipoTarjeta
     *   }
     * })
     * 
    **/
    create<T extends TipoTarjetaCreateArgs>(
      args: SelectSubset<T, TipoTarjetaCreateArgs>
    ): CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta>, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T>>>

    /**
     * Create many TipoTarjetas.
     *     @param {TipoTarjetaCreateManyArgs} args - Arguments to create many TipoTarjetas.
     *     @example
     *     // Create many TipoTarjetas
     *     const tipoTarjeta = await prisma.tipoTarjeta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TipoTarjetaCreateManyArgs>(
      args?: SelectSubset<T, TipoTarjetaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TipoTarjeta.
     * @param {TipoTarjetaDeleteArgs} args - Arguments to delete one TipoTarjeta.
     * @example
     * // Delete one TipoTarjeta
     * const TipoTarjeta = await prisma.tipoTarjeta.delete({
     *   where: {
     *     // ... filter to delete one TipoTarjeta
     *   }
     * })
     * 
    **/
    delete<T extends TipoTarjetaDeleteArgs>(
      args: SelectSubset<T, TipoTarjetaDeleteArgs>
    ): CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta>, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T>>>

    /**
     * Update one TipoTarjeta.
     * @param {TipoTarjetaUpdateArgs} args - Arguments to update one TipoTarjeta.
     * @example
     * // Update one TipoTarjeta
     * const tipoTarjeta = await prisma.tipoTarjeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TipoTarjetaUpdateArgs>(
      args: SelectSubset<T, TipoTarjetaUpdateArgs>
    ): CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta>, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T>>>

    /**
     * Delete zero or more TipoTarjetas.
     * @param {TipoTarjetaDeleteManyArgs} args - Arguments to filter TipoTarjetas to delete.
     * @example
     * // Delete a few TipoTarjetas
     * const { count } = await prisma.tipoTarjeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TipoTarjetaDeleteManyArgs>(
      args?: SelectSubset<T, TipoTarjetaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoTarjetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoTarjetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoTarjetas
     * const tipoTarjeta = await prisma.tipoTarjeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TipoTarjetaUpdateManyArgs>(
      args: SelectSubset<T, TipoTarjetaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoTarjeta.
     * @param {TipoTarjetaUpsertArgs} args - Arguments to update or create a TipoTarjeta.
     * @example
     * // Update or create a TipoTarjeta
     * const tipoTarjeta = await prisma.tipoTarjeta.upsert({
     *   create: {
     *     // ... data to create a TipoTarjeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoTarjeta we want to update
     *   }
     * })
    **/
    upsert<T extends TipoTarjetaUpsertArgs>(
      args: SelectSubset<T, TipoTarjetaUpsertArgs>
    ): CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta>, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T>>>

    /**
     * Find one TipoTarjeta that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TipoTarjetaFindUniqueOrThrowArgs} args - Arguments to find a TipoTarjeta
     * @example
     * // Get one TipoTarjeta
     * const tipoTarjeta = await prisma.tipoTarjeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TipoTarjetaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TipoTarjetaFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta>, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T>>>

    /**
     * Find the first TipoTarjeta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoTarjetaFindFirstOrThrowArgs} args - Arguments to find a TipoTarjeta
     * @example
     * // Get one TipoTarjeta
     * const tipoTarjeta = await prisma.tipoTarjeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TipoTarjetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TipoTarjetaFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta>, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T>>>

    /**
     * Count the number of TipoTarjetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoTarjetaCountArgs} args - Arguments to filter TipoTarjetas to count.
     * @example
     * // Count the number of TipoTarjetas
     * const count = await prisma.tipoTarjeta.count({
     *   where: {
     *     // ... the filter for the TipoTarjetas we want to count
     *   }
     * })
    **/
    count<T extends TipoTarjetaCountArgs>(
      args?: Subset<T, TipoTarjetaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoTarjetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoTarjeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoTarjetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoTarjetaAggregateArgs>(args: Subset<T, TipoTarjetaAggregateArgs>): PrismaPromise<GetTipoTarjetaAggregateType<T>>

    /**
     * Group by TipoTarjeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoTarjetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoTarjetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoTarjetaGroupByArgs['orderBy'] }
        : { orderBy?: TipoTarjetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoTarjetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoTarjetaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoTarjeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TipoTarjetaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    facturas<T extends Factura_EncabezadoFindManyArgs = {}>(args?: Subset<T, Factura_EncabezadoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Factura_Encabezado>>, PrismaPromise<Array<Factura_EncabezadoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TipoTarjeta base type for findUnique actions
   */
  export type TipoTarjetaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TipoTarjeta
     * 
    **/
    select?: TipoTarjetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoTarjetaInclude | null
    /**
     * Filter, which TipoTarjeta to fetch.
     * 
    **/
    where: TipoTarjetaWhereUniqueInput
  }

  /**
   * TipoTarjeta: findUnique
   */
  export interface TipoTarjetaFindUniqueArgs extends TipoTarjetaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoTarjeta base type for findFirst actions
   */
  export type TipoTarjetaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TipoTarjeta
     * 
    **/
    select?: TipoTarjetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoTarjetaInclude | null
    /**
     * Filter, which TipoTarjeta to fetch.
     * 
    **/
    where?: TipoTarjetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoTarjetas to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoTarjetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoTarjetas.
     * 
    **/
    cursor?: TipoTarjetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoTarjetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoTarjetas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoTarjetas.
     * 
    **/
    distinct?: Enumerable<TipoTarjetaScalarFieldEnum>
  }

  /**
   * TipoTarjeta: findFirst
   */
  export interface TipoTarjetaFindFirstArgs extends TipoTarjetaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoTarjeta findMany
   */
  export type TipoTarjetaFindManyArgs = {
    /**
     * Select specific fields to fetch from the TipoTarjeta
     * 
    **/
    select?: TipoTarjetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoTarjetaInclude | null
    /**
     * Filter, which TipoTarjetas to fetch.
     * 
    **/
    where?: TipoTarjetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoTarjetas to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoTarjetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoTarjetas.
     * 
    **/
    cursor?: TipoTarjetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoTarjetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoTarjetas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TipoTarjetaScalarFieldEnum>
  }


  /**
   * TipoTarjeta create
   */
  export type TipoTarjetaCreateArgs = {
    /**
     * Select specific fields to fetch from the TipoTarjeta
     * 
    **/
    select?: TipoTarjetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoTarjetaInclude | null
    /**
     * The data needed to create a TipoTarjeta.
     * 
    **/
    data: XOR<TipoTarjetaCreateInput, TipoTarjetaUncheckedCreateInput>
  }


  /**
   * TipoTarjeta createMany
   */
  export type TipoTarjetaCreateManyArgs = {
    /**
     * The data used to create many TipoTarjetas.
     * 
    **/
    data: Enumerable<TipoTarjetaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TipoTarjeta update
   */
  export type TipoTarjetaUpdateArgs = {
    /**
     * Select specific fields to fetch from the TipoTarjeta
     * 
    **/
    select?: TipoTarjetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoTarjetaInclude | null
    /**
     * The data needed to update a TipoTarjeta.
     * 
    **/
    data: XOR<TipoTarjetaUpdateInput, TipoTarjetaUncheckedUpdateInput>
    /**
     * Choose, which TipoTarjeta to update.
     * 
    **/
    where: TipoTarjetaWhereUniqueInput
  }


  /**
   * TipoTarjeta updateMany
   */
  export type TipoTarjetaUpdateManyArgs = {
    /**
     * The data used to update TipoTarjetas.
     * 
    **/
    data: XOR<TipoTarjetaUpdateManyMutationInput, TipoTarjetaUncheckedUpdateManyInput>
    /**
     * Filter which TipoTarjetas to update
     * 
    **/
    where?: TipoTarjetaWhereInput
  }


  /**
   * TipoTarjeta upsert
   */
  export type TipoTarjetaUpsertArgs = {
    /**
     * Select specific fields to fetch from the TipoTarjeta
     * 
    **/
    select?: TipoTarjetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoTarjetaInclude | null
    /**
     * The filter to search for the TipoTarjeta to update in case it exists.
     * 
    **/
    where: TipoTarjetaWhereUniqueInput
    /**
     * In case the TipoTarjeta found by the `where` argument doesn't exist, create a new TipoTarjeta with this data.
     * 
    **/
    create: XOR<TipoTarjetaCreateInput, TipoTarjetaUncheckedCreateInput>
    /**
     * In case the TipoTarjeta was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TipoTarjetaUpdateInput, TipoTarjetaUncheckedUpdateInput>
  }


  /**
   * TipoTarjeta delete
   */
  export type TipoTarjetaDeleteArgs = {
    /**
     * Select specific fields to fetch from the TipoTarjeta
     * 
    **/
    select?: TipoTarjetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoTarjetaInclude | null
    /**
     * Filter which TipoTarjeta to delete.
     * 
    **/
    where: TipoTarjetaWhereUniqueInput
  }


  /**
   * TipoTarjeta deleteMany
   */
  export type TipoTarjetaDeleteManyArgs = {
    /**
     * Filter which TipoTarjetas to delete
     * 
    **/
    where?: TipoTarjetaWhereInput
  }


  /**
   * TipoTarjeta: findUniqueOrThrow
   */
  export type TipoTarjetaFindUniqueOrThrowArgs = TipoTarjetaFindUniqueArgsBase
      

  /**
   * TipoTarjeta: findFirstOrThrow
   */
  export type TipoTarjetaFindFirstOrThrowArgs = TipoTarjetaFindFirstArgsBase
      

  /**
   * TipoTarjeta without action
   */
  export type TipoTarjetaArgs = {
    /**
     * Select specific fields to fetch from the TipoTarjeta
     * 
    **/
    select?: TipoTarjetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoTarjetaInclude | null
  }



  /**
   * Model Factura_Encabezado
   */


  export type AggregateFactura_Encabezado = {
    _count: Factura_EncabezadoCountAggregateOutputType | null
    _avg: Factura_EncabezadoAvgAggregateOutputType | null
    _sum: Factura_EncabezadoSumAggregateOutputType | null
    _min: Factura_EncabezadoMinAggregateOutputType | null
    _max: Factura_EncabezadoMaxAggregateOutputType | null
  }

  export type Factura_EncabezadoAvgAggregateOutputType = {
    id: number | null
    idTipoTarjeta: number | null
  }

  export type Factura_EncabezadoSumAggregateOutputType = {
    id: number | null
    idTipoTarjeta: number | null
  }

  export type Factura_EncabezadoMinAggregateOutputType = {
    id: number | null
    numero_tarjeta: string | null
    idTipoTarjeta: number | null
    fecha: Date | null
    estado: boolean | null
    idUsuario: string | null
  }

  export type Factura_EncabezadoMaxAggregateOutputType = {
    id: number | null
    numero_tarjeta: string | null
    idTipoTarjeta: number | null
    fecha: Date | null
    estado: boolean | null
    idUsuario: string | null
  }

  export type Factura_EncabezadoCountAggregateOutputType = {
    id: number
    numero_tarjeta: number
    idTipoTarjeta: number
    fecha: number
    estado: number
    idUsuario: number
    _all: number
  }


  export type Factura_EncabezadoAvgAggregateInputType = {
    id?: true
    idTipoTarjeta?: true
  }

  export type Factura_EncabezadoSumAggregateInputType = {
    id?: true
    idTipoTarjeta?: true
  }

  export type Factura_EncabezadoMinAggregateInputType = {
    id?: true
    numero_tarjeta?: true
    idTipoTarjeta?: true
    fecha?: true
    estado?: true
    idUsuario?: true
  }

  export type Factura_EncabezadoMaxAggregateInputType = {
    id?: true
    numero_tarjeta?: true
    idTipoTarjeta?: true
    fecha?: true
    estado?: true
    idUsuario?: true
  }

  export type Factura_EncabezadoCountAggregateInputType = {
    id?: true
    numero_tarjeta?: true
    idTipoTarjeta?: true
    fecha?: true
    estado?: true
    idUsuario?: true
    _all?: true
  }

  export type Factura_EncabezadoAggregateArgs = {
    /**
     * Filter which Factura_Encabezado to aggregate.
     * 
    **/
    where?: Factura_EncabezadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Encabezados to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_EncabezadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Factura_EncabezadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Encabezados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Encabezados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Factura_Encabezados
    **/
    _count?: true | Factura_EncabezadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Factura_EncabezadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Factura_EncabezadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Factura_EncabezadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Factura_EncabezadoMaxAggregateInputType
  }

  export type GetFactura_EncabezadoAggregateType<T extends Factura_EncabezadoAggregateArgs> = {
        [P in keyof T & keyof AggregateFactura_Encabezado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactura_Encabezado[P]>
      : GetScalarType<T[P], AggregateFactura_Encabezado[P]>
  }




  export type Factura_EncabezadoGroupByArgs = {
    where?: Factura_EncabezadoWhereInput
    orderBy?: Enumerable<Factura_EncabezadoOrderByWithAggregationInput>
    by: Array<Factura_EncabezadoScalarFieldEnum>
    having?: Factura_EncabezadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Factura_EncabezadoCountAggregateInputType | true
    _avg?: Factura_EncabezadoAvgAggregateInputType
    _sum?: Factura_EncabezadoSumAggregateInputType
    _min?: Factura_EncabezadoMinAggregateInputType
    _max?: Factura_EncabezadoMaxAggregateInputType
  }


  export type Factura_EncabezadoGroupByOutputType = {
    id: number
    numero_tarjeta: string | null
    idTipoTarjeta: number | null
    fecha: Date
    estado: boolean
    idUsuario: string
    _count: Factura_EncabezadoCountAggregateOutputType | null
    _avg: Factura_EncabezadoAvgAggregateOutputType | null
    _sum: Factura_EncabezadoSumAggregateOutputType | null
    _min: Factura_EncabezadoMinAggregateOutputType | null
    _max: Factura_EncabezadoMaxAggregateOutputType | null
  }

  type GetFactura_EncabezadoGroupByPayload<T extends Factura_EncabezadoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Factura_EncabezadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Factura_EncabezadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Factura_EncabezadoGroupByOutputType[P]>
            : GetScalarType<T[P], Factura_EncabezadoGroupByOutputType[P]>
        }
      >
    >


  export type Factura_EncabezadoSelect = {
    id?: boolean
    numero_tarjeta?: boolean
    TipoTarjeta?: boolean | TipoTarjetaArgs
    idTipoTarjeta?: boolean
    fecha?: boolean
    estado?: boolean
    detalles?: boolean | Factura_DetalleFindManyArgs
    tipoPagos?: boolean | FacturaEncabezadoTipoPagoFindManyArgs
    Usuario?: boolean | UsuarioArgs
    idUsuario?: boolean
    _count?: boolean | Factura_EncabezadoCountOutputTypeArgs
  }

  export type Factura_EncabezadoInclude = {
    TipoTarjeta?: boolean | TipoTarjetaArgs
    detalles?: boolean | Factura_DetalleFindManyArgs
    tipoPagos?: boolean | FacturaEncabezadoTipoPagoFindManyArgs
    Usuario?: boolean | UsuarioArgs
    _count?: boolean | Factura_EncabezadoCountOutputTypeArgs
  }

  export type Factura_EncabezadoGetPayload<
    S extends boolean | null | undefined | Factura_EncabezadoArgs,
    U = keyof S
      > = S extends true
        ? Factura_Encabezado
    : S extends undefined
    ? never
    : S extends Factura_EncabezadoArgs | Factura_EncabezadoFindManyArgs
    ?'include' extends U
    ? Factura_Encabezado  & {
    [P in TrueKeys<S['include']>]:
        P extends 'TipoTarjeta' ? TipoTarjetaGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'detalles' ? Array < Factura_DetalleGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'tipoPagos' ? Array < FacturaEncabezadoTipoPagoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? Factura_EncabezadoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'TipoTarjeta' ? TipoTarjetaGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'detalles' ? Array < Factura_DetalleGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'tipoPagos' ? Array < FacturaEncabezadoTipoPagoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Usuario' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? Factura_EncabezadoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Factura_Encabezado ? Factura_Encabezado[P] : never
  } 
    : Factura_Encabezado
  : Factura_Encabezado


  type Factura_EncabezadoCountArgs = Merge<
    Omit<Factura_EncabezadoFindManyArgs, 'select' | 'include'> & {
      select?: Factura_EncabezadoCountAggregateInputType | true
    }
  >

  export interface Factura_EncabezadoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Factura_Encabezado that matches the filter.
     * @param {Factura_EncabezadoFindUniqueArgs} args - Arguments to find a Factura_Encabezado
     * @example
     * // Get one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Factura_EncabezadoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Factura_EncabezadoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Factura_Encabezado'> extends True ? CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>> : CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado | null >, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T> | null >>

    /**
     * Find the first Factura_Encabezado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoFindFirstArgs} args - Arguments to find a Factura_Encabezado
     * @example
     * // Get one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Factura_EncabezadoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Factura_EncabezadoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Factura_Encabezado'> extends True ? CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>> : CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado | null >, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T> | null >>

    /**
     * Find zero or more Factura_Encabezados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Factura_Encabezados
     * const factura_Encabezados = await prisma.factura_Encabezado.findMany()
     * 
     * // Get first 10 Factura_Encabezados
     * const factura_Encabezados = await prisma.factura_Encabezado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factura_EncabezadoWithIdOnly = await prisma.factura_Encabezado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Factura_EncabezadoFindManyArgs>(
      args?: SelectSubset<T, Factura_EncabezadoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Factura_Encabezado>>, PrismaPromise<Array<Factura_EncabezadoGetPayload<T>>>>

    /**
     * Create a Factura_Encabezado.
     * @param {Factura_EncabezadoCreateArgs} args - Arguments to create a Factura_Encabezado.
     * @example
     * // Create one Factura_Encabezado
     * const Factura_Encabezado = await prisma.factura_Encabezado.create({
     *   data: {
     *     // ... data to create a Factura_Encabezado
     *   }
     * })
     * 
    **/
    create<T extends Factura_EncabezadoCreateArgs>(
      args: SelectSubset<T, Factura_EncabezadoCreateArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Create many Factura_Encabezados.
     *     @param {Factura_EncabezadoCreateManyArgs} args - Arguments to create many Factura_Encabezados.
     *     @example
     *     // Create many Factura_Encabezados
     *     const factura_Encabezado = await prisma.factura_Encabezado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Factura_EncabezadoCreateManyArgs>(
      args?: SelectSubset<T, Factura_EncabezadoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Factura_Encabezado.
     * @param {Factura_EncabezadoDeleteArgs} args - Arguments to delete one Factura_Encabezado.
     * @example
     * // Delete one Factura_Encabezado
     * const Factura_Encabezado = await prisma.factura_Encabezado.delete({
     *   where: {
     *     // ... filter to delete one Factura_Encabezado
     *   }
     * })
     * 
    **/
    delete<T extends Factura_EncabezadoDeleteArgs>(
      args: SelectSubset<T, Factura_EncabezadoDeleteArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Update one Factura_Encabezado.
     * @param {Factura_EncabezadoUpdateArgs} args - Arguments to update one Factura_Encabezado.
     * @example
     * // Update one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Factura_EncabezadoUpdateArgs>(
      args: SelectSubset<T, Factura_EncabezadoUpdateArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Delete zero or more Factura_Encabezados.
     * @param {Factura_EncabezadoDeleteManyArgs} args - Arguments to filter Factura_Encabezados to delete.
     * @example
     * // Delete a few Factura_Encabezados
     * const { count } = await prisma.factura_Encabezado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Factura_EncabezadoDeleteManyArgs>(
      args?: SelectSubset<T, Factura_EncabezadoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factura_Encabezados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Factura_Encabezados
     * const factura_Encabezado = await prisma.factura_Encabezado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Factura_EncabezadoUpdateManyArgs>(
      args: SelectSubset<T, Factura_EncabezadoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Factura_Encabezado.
     * @param {Factura_EncabezadoUpsertArgs} args - Arguments to update or create a Factura_Encabezado.
     * @example
     * // Update or create a Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.upsert({
     *   create: {
     *     // ... data to create a Factura_Encabezado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Factura_Encabezado we want to update
     *   }
     * })
    **/
    upsert<T extends Factura_EncabezadoUpsertArgs>(
      args: SelectSubset<T, Factura_EncabezadoUpsertArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Find one Factura_Encabezado that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Factura_EncabezadoFindUniqueOrThrowArgs} args - Arguments to find a Factura_Encabezado
     * @example
     * // Get one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Factura_EncabezadoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Factura_EncabezadoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Find the first Factura_Encabezado that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoFindFirstOrThrowArgs} args - Arguments to find a Factura_Encabezado
     * @example
     * // Get one Factura_Encabezado
     * const factura_Encabezado = await prisma.factura_Encabezado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Factura_EncabezadoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Factura_EncabezadoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado>, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T>>>

    /**
     * Count the number of Factura_Encabezados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoCountArgs} args - Arguments to filter Factura_Encabezados to count.
     * @example
     * // Count the number of Factura_Encabezados
     * const count = await prisma.factura_Encabezado.count({
     *   where: {
     *     // ... the filter for the Factura_Encabezados we want to count
     *   }
     * })
    **/
    count<T extends Factura_EncabezadoCountArgs>(
      args?: Subset<T, Factura_EncabezadoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Factura_EncabezadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Factura_Encabezado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Factura_EncabezadoAggregateArgs>(args: Subset<T, Factura_EncabezadoAggregateArgs>): PrismaPromise<GetFactura_EncabezadoAggregateType<T>>

    /**
     * Group by Factura_Encabezado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_EncabezadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Factura_EncabezadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Factura_EncabezadoGroupByArgs['orderBy'] }
        : { orderBy?: Factura_EncabezadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Factura_EncabezadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactura_EncabezadoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Factura_Encabezado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Factura_EncabezadoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    TipoTarjeta<T extends TipoTarjetaArgs = {}>(args?: Subset<T, TipoTarjetaArgs>): CheckSelect<T, Prisma__TipoTarjetaClient<TipoTarjeta | null >, Prisma__TipoTarjetaClient<TipoTarjetaGetPayload<T> | null >>;

    detalles<T extends Factura_DetalleFindManyArgs = {}>(args?: Subset<T, Factura_DetalleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Factura_Detalle>>, PrismaPromise<Array<Factura_DetalleGetPayload<T>>>>;

    tipoPagos<T extends FacturaEncabezadoTipoPagoFindManyArgs = {}>(args?: Subset<T, FacturaEncabezadoTipoPagoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FacturaEncabezadoTipoPago>>, PrismaPromise<Array<FacturaEncabezadoTipoPagoGetPayload<T>>>>;

    Usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Factura_Encabezado base type for findUnique actions
   */
  export type Factura_EncabezadoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * Filter, which Factura_Encabezado to fetch.
     * 
    **/
    where: Factura_EncabezadoWhereUniqueInput
  }

  /**
   * Factura_Encabezado: findUnique
   */
  export interface Factura_EncabezadoFindUniqueArgs extends Factura_EncabezadoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Factura_Encabezado base type for findFirst actions
   */
  export type Factura_EncabezadoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * Filter, which Factura_Encabezado to fetch.
     * 
    **/
    where?: Factura_EncabezadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Encabezados to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_EncabezadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Factura_Encabezados.
     * 
    **/
    cursor?: Factura_EncabezadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Encabezados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Encabezados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Factura_Encabezados.
     * 
    **/
    distinct?: Enumerable<Factura_EncabezadoScalarFieldEnum>
  }

  /**
   * Factura_Encabezado: findFirst
   */
  export interface Factura_EncabezadoFindFirstArgs extends Factura_EncabezadoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Factura_Encabezado findMany
   */
  export type Factura_EncabezadoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * Filter, which Factura_Encabezados to fetch.
     * 
    **/
    where?: Factura_EncabezadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Encabezados to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_EncabezadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Factura_Encabezados.
     * 
    **/
    cursor?: Factura_EncabezadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Encabezados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Encabezados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Factura_EncabezadoScalarFieldEnum>
  }


  /**
   * Factura_Encabezado create
   */
  export type Factura_EncabezadoCreateArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * The data needed to create a Factura_Encabezado.
     * 
    **/
    data: XOR<Factura_EncabezadoCreateInput, Factura_EncabezadoUncheckedCreateInput>
  }


  /**
   * Factura_Encabezado createMany
   */
  export type Factura_EncabezadoCreateManyArgs = {
    /**
     * The data used to create many Factura_Encabezados.
     * 
    **/
    data: Enumerable<Factura_EncabezadoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Factura_Encabezado update
   */
  export type Factura_EncabezadoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * The data needed to update a Factura_Encabezado.
     * 
    **/
    data: XOR<Factura_EncabezadoUpdateInput, Factura_EncabezadoUncheckedUpdateInput>
    /**
     * Choose, which Factura_Encabezado to update.
     * 
    **/
    where: Factura_EncabezadoWhereUniqueInput
  }


  /**
   * Factura_Encabezado updateMany
   */
  export type Factura_EncabezadoUpdateManyArgs = {
    /**
     * The data used to update Factura_Encabezados.
     * 
    **/
    data: XOR<Factura_EncabezadoUpdateManyMutationInput, Factura_EncabezadoUncheckedUpdateManyInput>
    /**
     * Filter which Factura_Encabezados to update
     * 
    **/
    where?: Factura_EncabezadoWhereInput
  }


  /**
   * Factura_Encabezado upsert
   */
  export type Factura_EncabezadoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * The filter to search for the Factura_Encabezado to update in case it exists.
     * 
    **/
    where: Factura_EncabezadoWhereUniqueInput
    /**
     * In case the Factura_Encabezado found by the `where` argument doesn't exist, create a new Factura_Encabezado with this data.
     * 
    **/
    create: XOR<Factura_EncabezadoCreateInput, Factura_EncabezadoUncheckedCreateInput>
    /**
     * In case the Factura_Encabezado was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Factura_EncabezadoUpdateInput, Factura_EncabezadoUncheckedUpdateInput>
  }


  /**
   * Factura_Encabezado delete
   */
  export type Factura_EncabezadoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
    /**
     * Filter which Factura_Encabezado to delete.
     * 
    **/
    where: Factura_EncabezadoWhereUniqueInput
  }


  /**
   * Factura_Encabezado deleteMany
   */
  export type Factura_EncabezadoDeleteManyArgs = {
    /**
     * Filter which Factura_Encabezados to delete
     * 
    **/
    where?: Factura_EncabezadoWhereInput
  }


  /**
   * Factura_Encabezado: findUniqueOrThrow
   */
  export type Factura_EncabezadoFindUniqueOrThrowArgs = Factura_EncabezadoFindUniqueArgsBase
      

  /**
   * Factura_Encabezado: findFirstOrThrow
   */
  export type Factura_EncabezadoFindFirstOrThrowArgs = Factura_EncabezadoFindFirstArgsBase
      

  /**
   * Factura_Encabezado without action
   */
  export type Factura_EncabezadoArgs = {
    /**
     * Select specific fields to fetch from the Factura_Encabezado
     * 
    **/
    select?: Factura_EncabezadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_EncabezadoInclude | null
  }



  /**
   * Model Factura_Detalle
   */


  export type AggregateFactura_Detalle = {
    _count: Factura_DetalleCountAggregateOutputType | null
    _avg: Factura_DetalleAvgAggregateOutputType | null
    _sum: Factura_DetalleSumAggregateOutputType | null
    _min: Factura_DetalleMinAggregateOutputType | null
    _max: Factura_DetalleMaxAggregateOutputType | null
  }

  export type Factura_DetalleAvgAggregateOutputType = {
    id: number | null
    cantidad: number | null
    precio: Decimal | null
    impuesto: Decimal | null
    total_detalle: Decimal | null
    idFactura_Encabezado: number | null
    idProducto: number | null
  }

  export type Factura_DetalleSumAggregateOutputType = {
    id: number | null
    cantidad: number | null
    precio: Decimal | null
    impuesto: Decimal | null
    total_detalle: Decimal | null
    idFactura_Encabezado: number | null
    idProducto: number | null
  }

  export type Factura_DetalleMinAggregateOutputType = {
    id: number | null
    cantidad: number | null
    precio: Decimal | null
    impuesto: Decimal | null
    total_detalle: Decimal | null
    idFactura_Encabezado: number | null
    idProducto: number | null
  }

  export type Factura_DetalleMaxAggregateOutputType = {
    id: number | null
    cantidad: number | null
    precio: Decimal | null
    impuesto: Decimal | null
    total_detalle: Decimal | null
    idFactura_Encabezado: number | null
    idProducto: number | null
  }

  export type Factura_DetalleCountAggregateOutputType = {
    id: number
    cantidad: number
    precio: number
    impuesto: number
    total_detalle: number
    idFactura_Encabezado: number
    idProducto: number
    _all: number
  }


  export type Factura_DetalleAvgAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
  }

  export type Factura_DetalleSumAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
  }

  export type Factura_DetalleMinAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
  }

  export type Factura_DetalleMaxAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
  }

  export type Factura_DetalleCountAggregateInputType = {
    id?: true
    cantidad?: true
    precio?: true
    impuesto?: true
    total_detalle?: true
    idFactura_Encabezado?: true
    idProducto?: true
    _all?: true
  }

  export type Factura_DetalleAggregateArgs = {
    /**
     * Filter which Factura_Detalle to aggregate.
     * 
    **/
    where?: Factura_DetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Detalles to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_DetalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Factura_DetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Detalles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Detalles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Factura_Detalles
    **/
    _count?: true | Factura_DetalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Factura_DetalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Factura_DetalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Factura_DetalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Factura_DetalleMaxAggregateInputType
  }

  export type GetFactura_DetalleAggregateType<T extends Factura_DetalleAggregateArgs> = {
        [P in keyof T & keyof AggregateFactura_Detalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactura_Detalle[P]>
      : GetScalarType<T[P], AggregateFactura_Detalle[P]>
  }




  export type Factura_DetalleGroupByArgs = {
    where?: Factura_DetalleWhereInput
    orderBy?: Enumerable<Factura_DetalleOrderByWithAggregationInput>
    by: Array<Factura_DetalleScalarFieldEnum>
    having?: Factura_DetalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Factura_DetalleCountAggregateInputType | true
    _avg?: Factura_DetalleAvgAggregateInputType
    _sum?: Factura_DetalleSumAggregateInputType
    _min?: Factura_DetalleMinAggregateInputType
    _max?: Factura_DetalleMaxAggregateInputType
  }


  export type Factura_DetalleGroupByOutputType = {
    id: number
    cantidad: number
    precio: Decimal
    impuesto: Decimal
    total_detalle: Decimal
    idFactura_Encabezado: number
    idProducto: number
    _count: Factura_DetalleCountAggregateOutputType | null
    _avg: Factura_DetalleAvgAggregateOutputType | null
    _sum: Factura_DetalleSumAggregateOutputType | null
    _min: Factura_DetalleMinAggregateOutputType | null
    _max: Factura_DetalleMaxAggregateOutputType | null
  }

  type GetFactura_DetalleGroupByPayload<T extends Factura_DetalleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Factura_DetalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Factura_DetalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Factura_DetalleGroupByOutputType[P]>
            : GetScalarType<T[P], Factura_DetalleGroupByOutputType[P]>
        }
      >
    >


  export type Factura_DetalleSelect = {
    id?: boolean
    cantidad?: boolean
    precio?: boolean
    impuesto?: boolean
    total_detalle?: boolean
    Factura_Encabezado?: boolean | Factura_EncabezadoArgs
    idFactura_Encabezado?: boolean
    Producto?: boolean | ProductoArgs
    idProducto?: boolean
  }

  export type Factura_DetalleInclude = {
    Factura_Encabezado?: boolean | Factura_EncabezadoArgs
    Producto?: boolean | ProductoArgs
  }

  export type Factura_DetalleGetPayload<
    S extends boolean | null | undefined | Factura_DetalleArgs,
    U = keyof S
      > = S extends true
        ? Factura_Detalle
    : S extends undefined
    ? never
    : S extends Factura_DetalleArgs | Factura_DetalleFindManyArgs
    ?'include' extends U
    ? Factura_Detalle  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Factura_Encabezado' ? Factura_EncabezadoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Factura_Encabezado' ? Factura_EncabezadoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Factura_Detalle ? Factura_Detalle[P] : never
  } 
    : Factura_Detalle
  : Factura_Detalle


  type Factura_DetalleCountArgs = Merge<
    Omit<Factura_DetalleFindManyArgs, 'select' | 'include'> & {
      select?: Factura_DetalleCountAggregateInputType | true
    }
  >

  export interface Factura_DetalleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Factura_Detalle that matches the filter.
     * @param {Factura_DetalleFindUniqueArgs} args - Arguments to find a Factura_Detalle
     * @example
     * // Get one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Factura_DetalleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Factura_DetalleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Factura_Detalle'> extends True ? CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>> : CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle | null >, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T> | null >>

    /**
     * Find the first Factura_Detalle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleFindFirstArgs} args - Arguments to find a Factura_Detalle
     * @example
     * // Get one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Factura_DetalleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Factura_DetalleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Factura_Detalle'> extends True ? CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>> : CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle | null >, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T> | null >>

    /**
     * Find zero or more Factura_Detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Factura_Detalles
     * const factura_Detalles = await prisma.factura_Detalle.findMany()
     * 
     * // Get first 10 Factura_Detalles
     * const factura_Detalles = await prisma.factura_Detalle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factura_DetalleWithIdOnly = await prisma.factura_Detalle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Factura_DetalleFindManyArgs>(
      args?: SelectSubset<T, Factura_DetalleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Factura_Detalle>>, PrismaPromise<Array<Factura_DetalleGetPayload<T>>>>

    /**
     * Create a Factura_Detalle.
     * @param {Factura_DetalleCreateArgs} args - Arguments to create a Factura_Detalle.
     * @example
     * // Create one Factura_Detalle
     * const Factura_Detalle = await prisma.factura_Detalle.create({
     *   data: {
     *     // ... data to create a Factura_Detalle
     *   }
     * })
     * 
    **/
    create<T extends Factura_DetalleCreateArgs>(
      args: SelectSubset<T, Factura_DetalleCreateArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Create many Factura_Detalles.
     *     @param {Factura_DetalleCreateManyArgs} args - Arguments to create many Factura_Detalles.
     *     @example
     *     // Create many Factura_Detalles
     *     const factura_Detalle = await prisma.factura_Detalle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Factura_DetalleCreateManyArgs>(
      args?: SelectSubset<T, Factura_DetalleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Factura_Detalle.
     * @param {Factura_DetalleDeleteArgs} args - Arguments to delete one Factura_Detalle.
     * @example
     * // Delete one Factura_Detalle
     * const Factura_Detalle = await prisma.factura_Detalle.delete({
     *   where: {
     *     // ... filter to delete one Factura_Detalle
     *   }
     * })
     * 
    **/
    delete<T extends Factura_DetalleDeleteArgs>(
      args: SelectSubset<T, Factura_DetalleDeleteArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Update one Factura_Detalle.
     * @param {Factura_DetalleUpdateArgs} args - Arguments to update one Factura_Detalle.
     * @example
     * // Update one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Factura_DetalleUpdateArgs>(
      args: SelectSubset<T, Factura_DetalleUpdateArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Delete zero or more Factura_Detalles.
     * @param {Factura_DetalleDeleteManyArgs} args - Arguments to filter Factura_Detalles to delete.
     * @example
     * // Delete a few Factura_Detalles
     * const { count } = await prisma.factura_Detalle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Factura_DetalleDeleteManyArgs>(
      args?: SelectSubset<T, Factura_DetalleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factura_Detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Factura_Detalles
     * const factura_Detalle = await prisma.factura_Detalle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Factura_DetalleUpdateManyArgs>(
      args: SelectSubset<T, Factura_DetalleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Factura_Detalle.
     * @param {Factura_DetalleUpsertArgs} args - Arguments to update or create a Factura_Detalle.
     * @example
     * // Update or create a Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.upsert({
     *   create: {
     *     // ... data to create a Factura_Detalle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Factura_Detalle we want to update
     *   }
     * })
    **/
    upsert<T extends Factura_DetalleUpsertArgs>(
      args: SelectSubset<T, Factura_DetalleUpsertArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Find one Factura_Detalle that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Factura_DetalleFindUniqueOrThrowArgs} args - Arguments to find a Factura_Detalle
     * @example
     * // Get one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Factura_DetalleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Factura_DetalleFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Find the first Factura_Detalle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleFindFirstOrThrowArgs} args - Arguments to find a Factura_Detalle
     * @example
     * // Get one Factura_Detalle
     * const factura_Detalle = await prisma.factura_Detalle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Factura_DetalleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Factura_DetalleFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Factura_DetalleClient<Factura_Detalle>, Prisma__Factura_DetalleClient<Factura_DetalleGetPayload<T>>>

    /**
     * Count the number of Factura_Detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleCountArgs} args - Arguments to filter Factura_Detalles to count.
     * @example
     * // Count the number of Factura_Detalles
     * const count = await prisma.factura_Detalle.count({
     *   where: {
     *     // ... the filter for the Factura_Detalles we want to count
     *   }
     * })
    **/
    count<T extends Factura_DetalleCountArgs>(
      args?: Subset<T, Factura_DetalleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Factura_DetalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Factura_Detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Factura_DetalleAggregateArgs>(args: Subset<T, Factura_DetalleAggregateArgs>): PrismaPromise<GetFactura_DetalleAggregateType<T>>

    /**
     * Group by Factura_Detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factura_DetalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Factura_DetalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Factura_DetalleGroupByArgs['orderBy'] }
        : { orderBy?: Factura_DetalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Factura_DetalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactura_DetalleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Factura_Detalle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Factura_DetalleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Factura_Encabezado<T extends Factura_EncabezadoArgs = {}>(args?: Subset<T, Factura_EncabezadoArgs>): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado | null >, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T> | null >>;

    Producto<T extends ProductoArgs = {}>(args?: Subset<T, ProductoArgs>): CheckSelect<T, Prisma__ProductoClient<Producto | null >, Prisma__ProductoClient<ProductoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Factura_Detalle base type for findUnique actions
   */
  export type Factura_DetalleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * Filter, which Factura_Detalle to fetch.
     * 
    **/
    where: Factura_DetalleWhereUniqueInput
  }

  /**
   * Factura_Detalle: findUnique
   */
  export interface Factura_DetalleFindUniqueArgs extends Factura_DetalleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Factura_Detalle base type for findFirst actions
   */
  export type Factura_DetalleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * Filter, which Factura_Detalle to fetch.
     * 
    **/
    where?: Factura_DetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Detalles to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_DetalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Factura_Detalles.
     * 
    **/
    cursor?: Factura_DetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Detalles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Detalles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Factura_Detalles.
     * 
    **/
    distinct?: Enumerable<Factura_DetalleScalarFieldEnum>
  }

  /**
   * Factura_Detalle: findFirst
   */
  export interface Factura_DetalleFindFirstArgs extends Factura_DetalleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Factura_Detalle findMany
   */
  export type Factura_DetalleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * Filter, which Factura_Detalles to fetch.
     * 
    **/
    where?: Factura_DetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factura_Detalles to fetch.
     * 
    **/
    orderBy?: Enumerable<Factura_DetalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Factura_Detalles.
     * 
    **/
    cursor?: Factura_DetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factura_Detalles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factura_Detalles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Factura_DetalleScalarFieldEnum>
  }


  /**
   * Factura_Detalle create
   */
  export type Factura_DetalleCreateArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * The data needed to create a Factura_Detalle.
     * 
    **/
    data: XOR<Factura_DetalleCreateInput, Factura_DetalleUncheckedCreateInput>
  }


  /**
   * Factura_Detalle createMany
   */
  export type Factura_DetalleCreateManyArgs = {
    /**
     * The data used to create many Factura_Detalles.
     * 
    **/
    data: Enumerable<Factura_DetalleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Factura_Detalle update
   */
  export type Factura_DetalleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * The data needed to update a Factura_Detalle.
     * 
    **/
    data: XOR<Factura_DetalleUpdateInput, Factura_DetalleUncheckedUpdateInput>
    /**
     * Choose, which Factura_Detalle to update.
     * 
    **/
    where: Factura_DetalleWhereUniqueInput
  }


  /**
   * Factura_Detalle updateMany
   */
  export type Factura_DetalleUpdateManyArgs = {
    /**
     * The data used to update Factura_Detalles.
     * 
    **/
    data: XOR<Factura_DetalleUpdateManyMutationInput, Factura_DetalleUncheckedUpdateManyInput>
    /**
     * Filter which Factura_Detalles to update
     * 
    **/
    where?: Factura_DetalleWhereInput
  }


  /**
   * Factura_Detalle upsert
   */
  export type Factura_DetalleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * The filter to search for the Factura_Detalle to update in case it exists.
     * 
    **/
    where: Factura_DetalleWhereUniqueInput
    /**
     * In case the Factura_Detalle found by the `where` argument doesn't exist, create a new Factura_Detalle with this data.
     * 
    **/
    create: XOR<Factura_DetalleCreateInput, Factura_DetalleUncheckedCreateInput>
    /**
     * In case the Factura_Detalle was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Factura_DetalleUpdateInput, Factura_DetalleUncheckedUpdateInput>
  }


  /**
   * Factura_Detalle delete
   */
  export type Factura_DetalleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
    /**
     * Filter which Factura_Detalle to delete.
     * 
    **/
    where: Factura_DetalleWhereUniqueInput
  }


  /**
   * Factura_Detalle deleteMany
   */
  export type Factura_DetalleDeleteManyArgs = {
    /**
     * Filter which Factura_Detalles to delete
     * 
    **/
    where?: Factura_DetalleWhereInput
  }


  /**
   * Factura_Detalle: findUniqueOrThrow
   */
  export type Factura_DetalleFindUniqueOrThrowArgs = Factura_DetalleFindUniqueArgsBase
      

  /**
   * Factura_Detalle: findFirstOrThrow
   */
  export type Factura_DetalleFindFirstOrThrowArgs = Factura_DetalleFindFirstArgsBase
      

  /**
   * Factura_Detalle without action
   */
  export type Factura_DetalleArgs = {
    /**
     * Select specific fields to fetch from the Factura_Detalle
     * 
    **/
    select?: Factura_DetalleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Factura_DetalleInclude | null
  }



  /**
   * Model FacturaEncabezadoTipoPago
   */


  export type AggregateFacturaEncabezadoTipoPago = {
    _count: FacturaEncabezadoTipoPagoCountAggregateOutputType | null
    _avg: FacturaEncabezadoTipoPagoAvgAggregateOutputType | null
    _sum: FacturaEncabezadoTipoPagoSumAggregateOutputType | null
    _min: FacturaEncabezadoTipoPagoMinAggregateOutputType | null
    _max: FacturaEncabezadoTipoPagoMaxAggregateOutputType | null
  }

  export type FacturaEncabezadoTipoPagoAvgAggregateOutputType = {
    idFactura_Encabezado: number | null
    idTipoPago: number | null
    monto: Decimal | null
  }

  export type FacturaEncabezadoTipoPagoSumAggregateOutputType = {
    idFactura_Encabezado: number | null
    idTipoPago: number | null
    monto: Decimal | null
  }

  export type FacturaEncabezadoTipoPagoMinAggregateOutputType = {
    idFactura_Encabezado: number | null
    idTipoPago: number | null
    monto: Decimal | null
  }

  export type FacturaEncabezadoTipoPagoMaxAggregateOutputType = {
    idFactura_Encabezado: number | null
    idTipoPago: number | null
    monto: Decimal | null
  }

  export type FacturaEncabezadoTipoPagoCountAggregateOutputType = {
    idFactura_Encabezado: number
    idTipoPago: number
    monto: number
    _all: number
  }


  export type FacturaEncabezadoTipoPagoAvgAggregateInputType = {
    idFactura_Encabezado?: true
    idTipoPago?: true
    monto?: true
  }

  export type FacturaEncabezadoTipoPagoSumAggregateInputType = {
    idFactura_Encabezado?: true
    idTipoPago?: true
    monto?: true
  }

  export type FacturaEncabezadoTipoPagoMinAggregateInputType = {
    idFactura_Encabezado?: true
    idTipoPago?: true
    monto?: true
  }

  export type FacturaEncabezadoTipoPagoMaxAggregateInputType = {
    idFactura_Encabezado?: true
    idTipoPago?: true
    monto?: true
  }

  export type FacturaEncabezadoTipoPagoCountAggregateInputType = {
    idFactura_Encabezado?: true
    idTipoPago?: true
    monto?: true
    _all?: true
  }

  export type FacturaEncabezadoTipoPagoAggregateArgs = {
    /**
     * Filter which FacturaEncabezadoTipoPago to aggregate.
     * 
    **/
    where?: FacturaEncabezadoTipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacturaEncabezadoTipoPagos to fetch.
     * 
    **/
    orderBy?: Enumerable<FacturaEncabezadoTipoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FacturaEncabezadoTipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacturaEncabezadoTipoPagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacturaEncabezadoTipoPagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacturaEncabezadoTipoPagos
    **/
    _count?: true | FacturaEncabezadoTipoPagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacturaEncabezadoTipoPagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacturaEncabezadoTipoPagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacturaEncabezadoTipoPagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacturaEncabezadoTipoPagoMaxAggregateInputType
  }

  export type GetFacturaEncabezadoTipoPagoAggregateType<T extends FacturaEncabezadoTipoPagoAggregateArgs> = {
        [P in keyof T & keyof AggregateFacturaEncabezadoTipoPago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacturaEncabezadoTipoPago[P]>
      : GetScalarType<T[P], AggregateFacturaEncabezadoTipoPago[P]>
  }




  export type FacturaEncabezadoTipoPagoGroupByArgs = {
    where?: FacturaEncabezadoTipoPagoWhereInput
    orderBy?: Enumerable<FacturaEncabezadoTipoPagoOrderByWithAggregationInput>
    by: Array<FacturaEncabezadoTipoPagoScalarFieldEnum>
    having?: FacturaEncabezadoTipoPagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacturaEncabezadoTipoPagoCountAggregateInputType | true
    _avg?: FacturaEncabezadoTipoPagoAvgAggregateInputType
    _sum?: FacturaEncabezadoTipoPagoSumAggregateInputType
    _min?: FacturaEncabezadoTipoPagoMinAggregateInputType
    _max?: FacturaEncabezadoTipoPagoMaxAggregateInputType
  }


  export type FacturaEncabezadoTipoPagoGroupByOutputType = {
    idFactura_Encabezado: number
    idTipoPago: number
    monto: Decimal
    _count: FacturaEncabezadoTipoPagoCountAggregateOutputType | null
    _avg: FacturaEncabezadoTipoPagoAvgAggregateOutputType | null
    _sum: FacturaEncabezadoTipoPagoSumAggregateOutputType | null
    _min: FacturaEncabezadoTipoPagoMinAggregateOutputType | null
    _max: FacturaEncabezadoTipoPagoMaxAggregateOutputType | null
  }

  type GetFacturaEncabezadoTipoPagoGroupByPayload<T extends FacturaEncabezadoTipoPagoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FacturaEncabezadoTipoPagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacturaEncabezadoTipoPagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacturaEncabezadoTipoPagoGroupByOutputType[P]>
            : GetScalarType<T[P], FacturaEncabezadoTipoPagoGroupByOutputType[P]>
        }
      >
    >


  export type FacturaEncabezadoTipoPagoSelect = {
    Factura_Encabezado?: boolean | Factura_EncabezadoArgs
    idFactura_Encabezado?: boolean
    TipoPago?: boolean | TipoPagoArgs
    idTipoPago?: boolean
    monto?: boolean
  }

  export type FacturaEncabezadoTipoPagoInclude = {
    Factura_Encabezado?: boolean | Factura_EncabezadoArgs
    TipoPago?: boolean | TipoPagoArgs
  }

  export type FacturaEncabezadoTipoPagoGetPayload<
    S extends boolean | null | undefined | FacturaEncabezadoTipoPagoArgs,
    U = keyof S
      > = S extends true
        ? FacturaEncabezadoTipoPago
    : S extends undefined
    ? never
    : S extends FacturaEncabezadoTipoPagoArgs | FacturaEncabezadoTipoPagoFindManyArgs
    ?'include' extends U
    ? FacturaEncabezadoTipoPago  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Factura_Encabezado' ? Factura_EncabezadoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'TipoPago' ? TipoPagoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Factura_Encabezado' ? Factura_EncabezadoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'TipoPago' ? TipoPagoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof FacturaEncabezadoTipoPago ? FacturaEncabezadoTipoPago[P] : never
  } 
    : FacturaEncabezadoTipoPago
  : FacturaEncabezadoTipoPago


  type FacturaEncabezadoTipoPagoCountArgs = Merge<
    Omit<FacturaEncabezadoTipoPagoFindManyArgs, 'select' | 'include'> & {
      select?: FacturaEncabezadoTipoPagoCountAggregateInputType | true
    }
  >

  export interface FacturaEncabezadoTipoPagoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one FacturaEncabezadoTipoPago that matches the filter.
     * @param {FacturaEncabezadoTipoPagoFindUniqueArgs} args - Arguments to find a FacturaEncabezadoTipoPago
     * @example
     * // Get one FacturaEncabezadoTipoPago
     * const facturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacturaEncabezadoTipoPagoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacturaEncabezadoTipoPagoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacturaEncabezadoTipoPago'> extends True ? CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago>, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T>>> : CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago | null >, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T> | null >>

    /**
     * Find the first FacturaEncabezadoTipoPago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaEncabezadoTipoPagoFindFirstArgs} args - Arguments to find a FacturaEncabezadoTipoPago
     * @example
     * // Get one FacturaEncabezadoTipoPago
     * const facturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacturaEncabezadoTipoPagoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacturaEncabezadoTipoPagoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacturaEncabezadoTipoPago'> extends True ? CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago>, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T>>> : CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago | null >, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T> | null >>

    /**
     * Find zero or more FacturaEncabezadoTipoPagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaEncabezadoTipoPagoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacturaEncabezadoTipoPagos
     * const facturaEncabezadoTipoPagos = await prisma.facturaEncabezadoTipoPago.findMany()
     * 
     * // Get first 10 FacturaEncabezadoTipoPagos
     * const facturaEncabezadoTipoPagos = await prisma.facturaEncabezadoTipoPago.findMany({ take: 10 })
     * 
     * // Only select the `idFactura_Encabezado`
     * const facturaEncabezadoTipoPagoWithIdFactura_EncabezadoOnly = await prisma.facturaEncabezadoTipoPago.findMany({ select: { idFactura_Encabezado: true } })
     * 
    **/
    findMany<T extends FacturaEncabezadoTipoPagoFindManyArgs>(
      args?: SelectSubset<T, FacturaEncabezadoTipoPagoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FacturaEncabezadoTipoPago>>, PrismaPromise<Array<FacturaEncabezadoTipoPagoGetPayload<T>>>>

    /**
     * Create a FacturaEncabezadoTipoPago.
     * @param {FacturaEncabezadoTipoPagoCreateArgs} args - Arguments to create a FacturaEncabezadoTipoPago.
     * @example
     * // Create one FacturaEncabezadoTipoPago
     * const FacturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.create({
     *   data: {
     *     // ... data to create a FacturaEncabezadoTipoPago
     *   }
     * })
     * 
    **/
    create<T extends FacturaEncabezadoTipoPagoCreateArgs>(
      args: SelectSubset<T, FacturaEncabezadoTipoPagoCreateArgs>
    ): CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago>, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T>>>

    /**
     * Create many FacturaEncabezadoTipoPagos.
     *     @param {FacturaEncabezadoTipoPagoCreateManyArgs} args - Arguments to create many FacturaEncabezadoTipoPagos.
     *     @example
     *     // Create many FacturaEncabezadoTipoPagos
     *     const facturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacturaEncabezadoTipoPagoCreateManyArgs>(
      args?: SelectSubset<T, FacturaEncabezadoTipoPagoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FacturaEncabezadoTipoPago.
     * @param {FacturaEncabezadoTipoPagoDeleteArgs} args - Arguments to delete one FacturaEncabezadoTipoPago.
     * @example
     * // Delete one FacturaEncabezadoTipoPago
     * const FacturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.delete({
     *   where: {
     *     // ... filter to delete one FacturaEncabezadoTipoPago
     *   }
     * })
     * 
    **/
    delete<T extends FacturaEncabezadoTipoPagoDeleteArgs>(
      args: SelectSubset<T, FacturaEncabezadoTipoPagoDeleteArgs>
    ): CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago>, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T>>>

    /**
     * Update one FacturaEncabezadoTipoPago.
     * @param {FacturaEncabezadoTipoPagoUpdateArgs} args - Arguments to update one FacturaEncabezadoTipoPago.
     * @example
     * // Update one FacturaEncabezadoTipoPago
     * const facturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacturaEncabezadoTipoPagoUpdateArgs>(
      args: SelectSubset<T, FacturaEncabezadoTipoPagoUpdateArgs>
    ): CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago>, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T>>>

    /**
     * Delete zero or more FacturaEncabezadoTipoPagos.
     * @param {FacturaEncabezadoTipoPagoDeleteManyArgs} args - Arguments to filter FacturaEncabezadoTipoPagos to delete.
     * @example
     * // Delete a few FacturaEncabezadoTipoPagos
     * const { count } = await prisma.facturaEncabezadoTipoPago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacturaEncabezadoTipoPagoDeleteManyArgs>(
      args?: SelectSubset<T, FacturaEncabezadoTipoPagoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacturaEncabezadoTipoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaEncabezadoTipoPagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacturaEncabezadoTipoPagos
     * const facturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacturaEncabezadoTipoPagoUpdateManyArgs>(
      args: SelectSubset<T, FacturaEncabezadoTipoPagoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FacturaEncabezadoTipoPago.
     * @param {FacturaEncabezadoTipoPagoUpsertArgs} args - Arguments to update or create a FacturaEncabezadoTipoPago.
     * @example
     * // Update or create a FacturaEncabezadoTipoPago
     * const facturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.upsert({
     *   create: {
     *     // ... data to create a FacturaEncabezadoTipoPago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacturaEncabezadoTipoPago we want to update
     *   }
     * })
    **/
    upsert<T extends FacturaEncabezadoTipoPagoUpsertArgs>(
      args: SelectSubset<T, FacturaEncabezadoTipoPagoUpsertArgs>
    ): CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago>, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T>>>

    /**
     * Find one FacturaEncabezadoTipoPago that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {FacturaEncabezadoTipoPagoFindUniqueOrThrowArgs} args - Arguments to find a FacturaEncabezadoTipoPago
     * @example
     * // Get one FacturaEncabezadoTipoPago
     * const facturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacturaEncabezadoTipoPagoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacturaEncabezadoTipoPagoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago>, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T>>>

    /**
     * Find the first FacturaEncabezadoTipoPago that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaEncabezadoTipoPagoFindFirstOrThrowArgs} args - Arguments to find a FacturaEncabezadoTipoPago
     * @example
     * // Get one FacturaEncabezadoTipoPago
     * const facturaEncabezadoTipoPago = await prisma.facturaEncabezadoTipoPago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacturaEncabezadoTipoPagoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacturaEncabezadoTipoPagoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPago>, Prisma__FacturaEncabezadoTipoPagoClient<FacturaEncabezadoTipoPagoGetPayload<T>>>

    /**
     * Count the number of FacturaEncabezadoTipoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaEncabezadoTipoPagoCountArgs} args - Arguments to filter FacturaEncabezadoTipoPagos to count.
     * @example
     * // Count the number of FacturaEncabezadoTipoPagos
     * const count = await prisma.facturaEncabezadoTipoPago.count({
     *   where: {
     *     // ... the filter for the FacturaEncabezadoTipoPagos we want to count
     *   }
     * })
    **/
    count<T extends FacturaEncabezadoTipoPagoCountArgs>(
      args?: Subset<T, FacturaEncabezadoTipoPagoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacturaEncabezadoTipoPagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacturaEncabezadoTipoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaEncabezadoTipoPagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacturaEncabezadoTipoPagoAggregateArgs>(args: Subset<T, FacturaEncabezadoTipoPagoAggregateArgs>): PrismaPromise<GetFacturaEncabezadoTipoPagoAggregateType<T>>

    /**
     * Group by FacturaEncabezadoTipoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaEncabezadoTipoPagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacturaEncabezadoTipoPagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacturaEncabezadoTipoPagoGroupByArgs['orderBy'] }
        : { orderBy?: FacturaEncabezadoTipoPagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacturaEncabezadoTipoPagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacturaEncabezadoTipoPagoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacturaEncabezadoTipoPago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacturaEncabezadoTipoPagoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Factura_Encabezado<T extends Factura_EncabezadoArgs = {}>(args?: Subset<T, Factura_EncabezadoArgs>): CheckSelect<T, Prisma__Factura_EncabezadoClient<Factura_Encabezado | null >, Prisma__Factura_EncabezadoClient<Factura_EncabezadoGetPayload<T> | null >>;

    TipoPago<T extends TipoPagoArgs = {}>(args?: Subset<T, TipoPagoArgs>): CheckSelect<T, Prisma__TipoPagoClient<TipoPago | null >, Prisma__TipoPagoClient<TipoPagoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacturaEncabezadoTipoPago base type for findUnique actions
   */
  export type FacturaEncabezadoTipoPagoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacturaEncabezadoTipoPago
     * 
    **/
    select?: FacturaEncabezadoTipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacturaEncabezadoTipoPagoInclude | null
    /**
     * Filter, which FacturaEncabezadoTipoPago to fetch.
     * 
    **/
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
  }

  /**
   * FacturaEncabezadoTipoPago: findUnique
   */
  export interface FacturaEncabezadoTipoPagoFindUniqueArgs extends FacturaEncabezadoTipoPagoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacturaEncabezadoTipoPago base type for findFirst actions
   */
  export type FacturaEncabezadoTipoPagoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacturaEncabezadoTipoPago
     * 
    **/
    select?: FacturaEncabezadoTipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacturaEncabezadoTipoPagoInclude | null
    /**
     * Filter, which FacturaEncabezadoTipoPago to fetch.
     * 
    **/
    where?: FacturaEncabezadoTipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacturaEncabezadoTipoPagos to fetch.
     * 
    **/
    orderBy?: Enumerable<FacturaEncabezadoTipoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacturaEncabezadoTipoPagos.
     * 
    **/
    cursor?: FacturaEncabezadoTipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacturaEncabezadoTipoPagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacturaEncabezadoTipoPagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacturaEncabezadoTipoPagos.
     * 
    **/
    distinct?: Enumerable<FacturaEncabezadoTipoPagoScalarFieldEnum>
  }

  /**
   * FacturaEncabezadoTipoPago: findFirst
   */
  export interface FacturaEncabezadoTipoPagoFindFirstArgs extends FacturaEncabezadoTipoPagoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacturaEncabezadoTipoPago findMany
   */
  export type FacturaEncabezadoTipoPagoFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacturaEncabezadoTipoPago
     * 
    **/
    select?: FacturaEncabezadoTipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacturaEncabezadoTipoPagoInclude | null
    /**
     * Filter, which FacturaEncabezadoTipoPagos to fetch.
     * 
    **/
    where?: FacturaEncabezadoTipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacturaEncabezadoTipoPagos to fetch.
     * 
    **/
    orderBy?: Enumerable<FacturaEncabezadoTipoPagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacturaEncabezadoTipoPagos.
     * 
    **/
    cursor?: FacturaEncabezadoTipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacturaEncabezadoTipoPagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacturaEncabezadoTipoPagos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FacturaEncabezadoTipoPagoScalarFieldEnum>
  }


  /**
   * FacturaEncabezadoTipoPago create
   */
  export type FacturaEncabezadoTipoPagoCreateArgs = {
    /**
     * Select specific fields to fetch from the FacturaEncabezadoTipoPago
     * 
    **/
    select?: FacturaEncabezadoTipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacturaEncabezadoTipoPagoInclude | null
    /**
     * The data needed to create a FacturaEncabezadoTipoPago.
     * 
    **/
    data: XOR<FacturaEncabezadoTipoPagoCreateInput, FacturaEncabezadoTipoPagoUncheckedCreateInput>
  }


  /**
   * FacturaEncabezadoTipoPago createMany
   */
  export type FacturaEncabezadoTipoPagoCreateManyArgs = {
    /**
     * The data used to create many FacturaEncabezadoTipoPagos.
     * 
    **/
    data: Enumerable<FacturaEncabezadoTipoPagoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacturaEncabezadoTipoPago update
   */
  export type FacturaEncabezadoTipoPagoUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacturaEncabezadoTipoPago
     * 
    **/
    select?: FacturaEncabezadoTipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacturaEncabezadoTipoPagoInclude | null
    /**
     * The data needed to update a FacturaEncabezadoTipoPago.
     * 
    **/
    data: XOR<FacturaEncabezadoTipoPagoUpdateInput, FacturaEncabezadoTipoPagoUncheckedUpdateInput>
    /**
     * Choose, which FacturaEncabezadoTipoPago to update.
     * 
    **/
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
  }


  /**
   * FacturaEncabezadoTipoPago updateMany
   */
  export type FacturaEncabezadoTipoPagoUpdateManyArgs = {
    /**
     * The data used to update FacturaEncabezadoTipoPagos.
     * 
    **/
    data: XOR<FacturaEncabezadoTipoPagoUpdateManyMutationInput, FacturaEncabezadoTipoPagoUncheckedUpdateManyInput>
    /**
     * Filter which FacturaEncabezadoTipoPagos to update
     * 
    **/
    where?: FacturaEncabezadoTipoPagoWhereInput
  }


  /**
   * FacturaEncabezadoTipoPago upsert
   */
  export type FacturaEncabezadoTipoPagoUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacturaEncabezadoTipoPago
     * 
    **/
    select?: FacturaEncabezadoTipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacturaEncabezadoTipoPagoInclude | null
    /**
     * The filter to search for the FacturaEncabezadoTipoPago to update in case it exists.
     * 
    **/
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
    /**
     * In case the FacturaEncabezadoTipoPago found by the `where` argument doesn't exist, create a new FacturaEncabezadoTipoPago with this data.
     * 
    **/
    create: XOR<FacturaEncabezadoTipoPagoCreateInput, FacturaEncabezadoTipoPagoUncheckedCreateInput>
    /**
     * In case the FacturaEncabezadoTipoPago was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FacturaEncabezadoTipoPagoUpdateInput, FacturaEncabezadoTipoPagoUncheckedUpdateInput>
  }


  /**
   * FacturaEncabezadoTipoPago delete
   */
  export type FacturaEncabezadoTipoPagoDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacturaEncabezadoTipoPago
     * 
    **/
    select?: FacturaEncabezadoTipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacturaEncabezadoTipoPagoInclude | null
    /**
     * Filter which FacturaEncabezadoTipoPago to delete.
     * 
    **/
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
  }


  /**
   * FacturaEncabezadoTipoPago deleteMany
   */
  export type FacturaEncabezadoTipoPagoDeleteManyArgs = {
    /**
     * Filter which FacturaEncabezadoTipoPagos to delete
     * 
    **/
    where?: FacturaEncabezadoTipoPagoWhereInput
  }


  /**
   * FacturaEncabezadoTipoPago: findUniqueOrThrow
   */
  export type FacturaEncabezadoTipoPagoFindUniqueOrThrowArgs = FacturaEncabezadoTipoPagoFindUniqueArgsBase
      

  /**
   * FacturaEncabezadoTipoPago: findFirstOrThrow
   */
  export type FacturaEncabezadoTipoPagoFindFirstOrThrowArgs = FacturaEncabezadoTipoPagoFindFirstArgsBase
      

  /**
   * FacturaEncabezadoTipoPago without action
   */
  export type FacturaEncabezadoTipoPagoArgs = {
    /**
     * Select specific fields to fetch from the FacturaEncabezadoTipoPago
     * 
    **/
    select?: FacturaEncabezadoTipoPagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FacturaEncabezadoTipoPagoInclude | null
  }



  /**
   * Model EstadoPedido
   */


  export type AggregateEstadoPedido = {
    _count: EstadoPedidoCountAggregateOutputType | null
    _avg: EstadoPedidoAvgAggregateOutputType | null
    _sum: EstadoPedidoSumAggregateOutputType | null
    _min: EstadoPedidoMinAggregateOutputType | null
    _max: EstadoPedidoMaxAggregateOutputType | null
  }

  export type EstadoPedidoAvgAggregateOutputType = {
    id: number | null
  }

  export type EstadoPedidoSumAggregateOutputType = {
    id: number | null
  }

  export type EstadoPedidoMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type EstadoPedidoMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type EstadoPedidoCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type EstadoPedidoAvgAggregateInputType = {
    id?: true
  }

  export type EstadoPedidoSumAggregateInputType = {
    id?: true
  }

  export type EstadoPedidoMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type EstadoPedidoMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type EstadoPedidoCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type EstadoPedidoAggregateArgs = {
    /**
     * Filter which EstadoPedido to aggregate.
     * 
    **/
    where?: EstadoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoPedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoPedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EstadoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoPedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoPedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EstadoPedidos
    **/
    _count?: true | EstadoPedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoPedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoPedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoPedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoPedidoMaxAggregateInputType
  }

  export type GetEstadoPedidoAggregateType<T extends EstadoPedidoAggregateArgs> = {
        [P in keyof T & keyof AggregateEstadoPedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstadoPedido[P]>
      : GetScalarType<T[P], AggregateEstadoPedido[P]>
  }




  export type EstadoPedidoGroupByArgs = {
    where?: EstadoPedidoWhereInput
    orderBy?: Enumerable<EstadoPedidoOrderByWithAggregationInput>
    by: Array<EstadoPedidoScalarFieldEnum>
    having?: EstadoPedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoPedidoCountAggregateInputType | true
    _avg?: EstadoPedidoAvgAggregateInputType
    _sum?: EstadoPedidoSumAggregateInputType
    _min?: EstadoPedidoMinAggregateInputType
    _max?: EstadoPedidoMaxAggregateInputType
  }


  export type EstadoPedidoGroupByOutputType = {
    id: number
    descripcion: string
    _count: EstadoPedidoCountAggregateOutputType | null
    _avg: EstadoPedidoAvgAggregateOutputType | null
    _sum: EstadoPedidoSumAggregateOutputType | null
    _min: EstadoPedidoMinAggregateOutputType | null
    _max: EstadoPedidoMaxAggregateOutputType | null
  }

  type GetEstadoPedidoGroupByPayload<T extends EstadoPedidoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EstadoPedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoPedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoPedidoGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoPedidoGroupByOutputType[P]>
        }
      >
    >


  export type EstadoPedidoSelect = {
    id?: boolean
    descripcion?: boolean
    pedidos?: boolean | PedidoFindManyArgs
    _count?: boolean | EstadoPedidoCountOutputTypeArgs
  }

  export type EstadoPedidoInclude = {
    pedidos?: boolean | PedidoFindManyArgs
    _count?: boolean | EstadoPedidoCountOutputTypeArgs
  }

  export type EstadoPedidoGetPayload<
    S extends boolean | null | undefined | EstadoPedidoArgs,
    U = keyof S
      > = S extends true
        ? EstadoPedido
    : S extends undefined
    ? never
    : S extends EstadoPedidoArgs | EstadoPedidoFindManyArgs
    ?'include' extends U
    ? EstadoPedido  & {
    [P in TrueKeys<S['include']>]:
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? EstadoPedidoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? EstadoPedidoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof EstadoPedido ? EstadoPedido[P] : never
  } 
    : EstadoPedido
  : EstadoPedido


  type EstadoPedidoCountArgs = Merge<
    Omit<EstadoPedidoFindManyArgs, 'select' | 'include'> & {
      select?: EstadoPedidoCountAggregateInputType | true
    }
  >

  export interface EstadoPedidoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EstadoPedido that matches the filter.
     * @param {EstadoPedidoFindUniqueArgs} args - Arguments to find a EstadoPedido
     * @example
     * // Get one EstadoPedido
     * const estadoPedido = await prisma.estadoPedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EstadoPedidoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EstadoPedidoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EstadoPedido'> extends True ? CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido>, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T>>> : CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido | null >, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T> | null >>

    /**
     * Find the first EstadoPedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoPedidoFindFirstArgs} args - Arguments to find a EstadoPedido
     * @example
     * // Get one EstadoPedido
     * const estadoPedido = await prisma.estadoPedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EstadoPedidoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EstadoPedidoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EstadoPedido'> extends True ? CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido>, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T>>> : CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido | null >, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T> | null >>

    /**
     * Find zero or more EstadoPedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoPedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EstadoPedidos
     * const estadoPedidos = await prisma.estadoPedido.findMany()
     * 
     * // Get first 10 EstadoPedidos
     * const estadoPedidos = await prisma.estadoPedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estadoPedidoWithIdOnly = await prisma.estadoPedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EstadoPedidoFindManyArgs>(
      args?: SelectSubset<T, EstadoPedidoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EstadoPedido>>, PrismaPromise<Array<EstadoPedidoGetPayload<T>>>>

    /**
     * Create a EstadoPedido.
     * @param {EstadoPedidoCreateArgs} args - Arguments to create a EstadoPedido.
     * @example
     * // Create one EstadoPedido
     * const EstadoPedido = await prisma.estadoPedido.create({
     *   data: {
     *     // ... data to create a EstadoPedido
     *   }
     * })
     * 
    **/
    create<T extends EstadoPedidoCreateArgs>(
      args: SelectSubset<T, EstadoPedidoCreateArgs>
    ): CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido>, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T>>>

    /**
     * Create many EstadoPedidos.
     *     @param {EstadoPedidoCreateManyArgs} args - Arguments to create many EstadoPedidos.
     *     @example
     *     // Create many EstadoPedidos
     *     const estadoPedido = await prisma.estadoPedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EstadoPedidoCreateManyArgs>(
      args?: SelectSubset<T, EstadoPedidoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EstadoPedido.
     * @param {EstadoPedidoDeleteArgs} args - Arguments to delete one EstadoPedido.
     * @example
     * // Delete one EstadoPedido
     * const EstadoPedido = await prisma.estadoPedido.delete({
     *   where: {
     *     // ... filter to delete one EstadoPedido
     *   }
     * })
     * 
    **/
    delete<T extends EstadoPedidoDeleteArgs>(
      args: SelectSubset<T, EstadoPedidoDeleteArgs>
    ): CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido>, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T>>>

    /**
     * Update one EstadoPedido.
     * @param {EstadoPedidoUpdateArgs} args - Arguments to update one EstadoPedido.
     * @example
     * // Update one EstadoPedido
     * const estadoPedido = await prisma.estadoPedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EstadoPedidoUpdateArgs>(
      args: SelectSubset<T, EstadoPedidoUpdateArgs>
    ): CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido>, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T>>>

    /**
     * Delete zero or more EstadoPedidos.
     * @param {EstadoPedidoDeleteManyArgs} args - Arguments to filter EstadoPedidos to delete.
     * @example
     * // Delete a few EstadoPedidos
     * const { count } = await prisma.estadoPedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EstadoPedidoDeleteManyArgs>(
      args?: SelectSubset<T, EstadoPedidoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstadoPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoPedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EstadoPedidos
     * const estadoPedido = await prisma.estadoPedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EstadoPedidoUpdateManyArgs>(
      args: SelectSubset<T, EstadoPedidoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EstadoPedido.
     * @param {EstadoPedidoUpsertArgs} args - Arguments to update or create a EstadoPedido.
     * @example
     * // Update or create a EstadoPedido
     * const estadoPedido = await prisma.estadoPedido.upsert({
     *   create: {
     *     // ... data to create a EstadoPedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EstadoPedido we want to update
     *   }
     * })
    **/
    upsert<T extends EstadoPedidoUpsertArgs>(
      args: SelectSubset<T, EstadoPedidoUpsertArgs>
    ): CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido>, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T>>>

    /**
     * Find one EstadoPedido that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {EstadoPedidoFindUniqueOrThrowArgs} args - Arguments to find a EstadoPedido
     * @example
     * // Get one EstadoPedido
     * const estadoPedido = await prisma.estadoPedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EstadoPedidoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EstadoPedidoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido>, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T>>>

    /**
     * Find the first EstadoPedido that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoPedidoFindFirstOrThrowArgs} args - Arguments to find a EstadoPedido
     * @example
     * // Get one EstadoPedido
     * const estadoPedido = await prisma.estadoPedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EstadoPedidoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EstadoPedidoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido>, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T>>>

    /**
     * Count the number of EstadoPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoPedidoCountArgs} args - Arguments to filter EstadoPedidos to count.
     * @example
     * // Count the number of EstadoPedidos
     * const count = await prisma.estadoPedido.count({
     *   where: {
     *     // ... the filter for the EstadoPedidos we want to count
     *   }
     * })
    **/
    count<T extends EstadoPedidoCountArgs>(
      args?: Subset<T, EstadoPedidoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoPedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EstadoPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoPedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoPedidoAggregateArgs>(args: Subset<T, EstadoPedidoAggregateArgs>): PrismaPromise<GetEstadoPedidoAggregateType<T>>

    /**
     * Group by EstadoPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoPedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstadoPedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstadoPedidoGroupByArgs['orderBy'] }
        : { orderBy?: EstadoPedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstadoPedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoPedidoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EstadoPedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EstadoPedidoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pedidos<T extends PedidoFindManyArgs = {}>(args?: Subset<T, PedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EstadoPedido base type for findUnique actions
   */
  export type EstadoPedidoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EstadoPedido
     * 
    **/
    select?: EstadoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoPedidoInclude | null
    /**
     * Filter, which EstadoPedido to fetch.
     * 
    **/
    where: EstadoPedidoWhereUniqueInput
  }

  /**
   * EstadoPedido: findUnique
   */
  export interface EstadoPedidoFindUniqueArgs extends EstadoPedidoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EstadoPedido base type for findFirst actions
   */
  export type EstadoPedidoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EstadoPedido
     * 
    **/
    select?: EstadoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoPedidoInclude | null
    /**
     * Filter, which EstadoPedido to fetch.
     * 
    **/
    where?: EstadoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoPedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoPedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstadoPedidos.
     * 
    **/
    cursor?: EstadoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoPedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoPedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstadoPedidos.
     * 
    **/
    distinct?: Enumerable<EstadoPedidoScalarFieldEnum>
  }

  /**
   * EstadoPedido: findFirst
   */
  export interface EstadoPedidoFindFirstArgs extends EstadoPedidoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EstadoPedido findMany
   */
  export type EstadoPedidoFindManyArgs = {
    /**
     * Select specific fields to fetch from the EstadoPedido
     * 
    **/
    select?: EstadoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoPedidoInclude | null
    /**
     * Filter, which EstadoPedidos to fetch.
     * 
    **/
    where?: EstadoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoPedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoPedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EstadoPedidos.
     * 
    **/
    cursor?: EstadoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoPedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoPedidos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EstadoPedidoScalarFieldEnum>
  }


  /**
   * EstadoPedido create
   */
  export type EstadoPedidoCreateArgs = {
    /**
     * Select specific fields to fetch from the EstadoPedido
     * 
    **/
    select?: EstadoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoPedidoInclude | null
    /**
     * The data needed to create a EstadoPedido.
     * 
    **/
    data: XOR<EstadoPedidoCreateInput, EstadoPedidoUncheckedCreateInput>
  }


  /**
   * EstadoPedido createMany
   */
  export type EstadoPedidoCreateManyArgs = {
    /**
     * The data used to create many EstadoPedidos.
     * 
    **/
    data: Enumerable<EstadoPedidoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EstadoPedido update
   */
  export type EstadoPedidoUpdateArgs = {
    /**
     * Select specific fields to fetch from the EstadoPedido
     * 
    **/
    select?: EstadoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoPedidoInclude | null
    /**
     * The data needed to update a EstadoPedido.
     * 
    **/
    data: XOR<EstadoPedidoUpdateInput, EstadoPedidoUncheckedUpdateInput>
    /**
     * Choose, which EstadoPedido to update.
     * 
    **/
    where: EstadoPedidoWhereUniqueInput
  }


  /**
   * EstadoPedido updateMany
   */
  export type EstadoPedidoUpdateManyArgs = {
    /**
     * The data used to update EstadoPedidos.
     * 
    **/
    data: XOR<EstadoPedidoUpdateManyMutationInput, EstadoPedidoUncheckedUpdateManyInput>
    /**
     * Filter which EstadoPedidos to update
     * 
    **/
    where?: EstadoPedidoWhereInput
  }


  /**
   * EstadoPedido upsert
   */
  export type EstadoPedidoUpsertArgs = {
    /**
     * Select specific fields to fetch from the EstadoPedido
     * 
    **/
    select?: EstadoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoPedidoInclude | null
    /**
     * The filter to search for the EstadoPedido to update in case it exists.
     * 
    **/
    where: EstadoPedidoWhereUniqueInput
    /**
     * In case the EstadoPedido found by the `where` argument doesn't exist, create a new EstadoPedido with this data.
     * 
    **/
    create: XOR<EstadoPedidoCreateInput, EstadoPedidoUncheckedCreateInput>
    /**
     * In case the EstadoPedido was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EstadoPedidoUpdateInput, EstadoPedidoUncheckedUpdateInput>
  }


  /**
   * EstadoPedido delete
   */
  export type EstadoPedidoDeleteArgs = {
    /**
     * Select specific fields to fetch from the EstadoPedido
     * 
    **/
    select?: EstadoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoPedidoInclude | null
    /**
     * Filter which EstadoPedido to delete.
     * 
    **/
    where: EstadoPedidoWhereUniqueInput
  }


  /**
   * EstadoPedido deleteMany
   */
  export type EstadoPedidoDeleteManyArgs = {
    /**
     * Filter which EstadoPedidos to delete
     * 
    **/
    where?: EstadoPedidoWhereInput
  }


  /**
   * EstadoPedido: findUniqueOrThrow
   */
  export type EstadoPedidoFindUniqueOrThrowArgs = EstadoPedidoFindUniqueArgsBase
      

  /**
   * EstadoPedido: findFirstOrThrow
   */
  export type EstadoPedidoFindFirstOrThrowArgs = EstadoPedidoFindFirstArgsBase
      

  /**
   * EstadoPedido without action
   */
  export type EstadoPedidoArgs = {
    /**
     * Select specific fields to fetch from the EstadoPedido
     * 
    **/
    select?: EstadoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoPedidoInclude | null
  }



  /**
   * Model TipoPedido
   */


  export type AggregateTipoPedido = {
    _count: TipoPedidoCountAggregateOutputType | null
    _avg: TipoPedidoAvgAggregateOutputType | null
    _sum: TipoPedidoSumAggregateOutputType | null
    _min: TipoPedidoMinAggregateOutputType | null
    _max: TipoPedidoMaxAggregateOutputType | null
  }

  export type TipoPedidoAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoPedidoSumAggregateOutputType = {
    id: number | null
  }

  export type TipoPedidoMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type TipoPedidoMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
  }

  export type TipoPedidoCountAggregateOutputType = {
    id: number
    descripcion: number
    _all: number
  }


  export type TipoPedidoAvgAggregateInputType = {
    id?: true
  }

  export type TipoPedidoSumAggregateInputType = {
    id?: true
  }

  export type TipoPedidoMinAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type TipoPedidoMaxAggregateInputType = {
    id?: true
    descripcion?: true
  }

  export type TipoPedidoCountAggregateInputType = {
    id?: true
    descripcion?: true
    _all?: true
  }

  export type TipoPedidoAggregateArgs = {
    /**
     * Filter which TipoPedido to aggregate.
     * 
    **/
    where?: TipoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoPedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TipoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoPedidos
    **/
    _count?: true | TipoPedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoPedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoPedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoPedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoPedidoMaxAggregateInputType
  }

  export type GetTipoPedidoAggregateType<T extends TipoPedidoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoPedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoPedido[P]>
      : GetScalarType<T[P], AggregateTipoPedido[P]>
  }




  export type TipoPedidoGroupByArgs = {
    where?: TipoPedidoWhereInput
    orderBy?: Enumerable<TipoPedidoOrderByWithAggregationInput>
    by: Array<TipoPedidoScalarFieldEnum>
    having?: TipoPedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoPedidoCountAggregateInputType | true
    _avg?: TipoPedidoAvgAggregateInputType
    _sum?: TipoPedidoSumAggregateInputType
    _min?: TipoPedidoMinAggregateInputType
    _max?: TipoPedidoMaxAggregateInputType
  }


  export type TipoPedidoGroupByOutputType = {
    id: number
    descripcion: string
    _count: TipoPedidoCountAggregateOutputType | null
    _avg: TipoPedidoAvgAggregateOutputType | null
    _sum: TipoPedidoSumAggregateOutputType | null
    _min: TipoPedidoMinAggregateOutputType | null
    _max: TipoPedidoMaxAggregateOutputType | null
  }

  type GetTipoPedidoGroupByPayload<T extends TipoPedidoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TipoPedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoPedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoPedidoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoPedidoGroupByOutputType[P]>
        }
      >
    >


  export type TipoPedidoSelect = {
    id?: boolean
    descripcion?: boolean
    pedidos?: boolean | PedidoFindManyArgs
    _count?: boolean | TipoPedidoCountOutputTypeArgs
  }

  export type TipoPedidoInclude = {
    pedidos?: boolean | PedidoFindManyArgs
    _count?: boolean | TipoPedidoCountOutputTypeArgs
  }

  export type TipoPedidoGetPayload<
    S extends boolean | null | undefined | TipoPedidoArgs,
    U = keyof S
      > = S extends true
        ? TipoPedido
    : S extends undefined
    ? never
    : S extends TipoPedidoArgs | TipoPedidoFindManyArgs
    ?'include' extends U
    ? TipoPedido  & {
    [P in TrueKeys<S['include']>]:
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TipoPedidoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TipoPedidoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof TipoPedido ? TipoPedido[P] : never
  } 
    : TipoPedido
  : TipoPedido


  type TipoPedidoCountArgs = Merge<
    Omit<TipoPedidoFindManyArgs, 'select' | 'include'> & {
      select?: TipoPedidoCountAggregateInputType | true
    }
  >

  export interface TipoPedidoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TipoPedido that matches the filter.
     * @param {TipoPedidoFindUniqueArgs} args - Arguments to find a TipoPedido
     * @example
     * // Get one TipoPedido
     * const tipoPedido = await prisma.tipoPedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TipoPedidoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TipoPedidoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TipoPedido'> extends True ? CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido>, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T>>> : CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido | null >, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T> | null >>

    /**
     * Find the first TipoPedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPedidoFindFirstArgs} args - Arguments to find a TipoPedido
     * @example
     * // Get one TipoPedido
     * const tipoPedido = await prisma.tipoPedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TipoPedidoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TipoPedidoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TipoPedido'> extends True ? CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido>, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T>>> : CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido | null >, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T> | null >>

    /**
     * Find zero or more TipoPedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoPedidos
     * const tipoPedidos = await prisma.tipoPedido.findMany()
     * 
     * // Get first 10 TipoPedidos
     * const tipoPedidos = await prisma.tipoPedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoPedidoWithIdOnly = await prisma.tipoPedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TipoPedidoFindManyArgs>(
      args?: SelectSubset<T, TipoPedidoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TipoPedido>>, PrismaPromise<Array<TipoPedidoGetPayload<T>>>>

    /**
     * Create a TipoPedido.
     * @param {TipoPedidoCreateArgs} args - Arguments to create a TipoPedido.
     * @example
     * // Create one TipoPedido
     * const TipoPedido = await prisma.tipoPedido.create({
     *   data: {
     *     // ... data to create a TipoPedido
     *   }
     * })
     * 
    **/
    create<T extends TipoPedidoCreateArgs>(
      args: SelectSubset<T, TipoPedidoCreateArgs>
    ): CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido>, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T>>>

    /**
     * Create many TipoPedidos.
     *     @param {TipoPedidoCreateManyArgs} args - Arguments to create many TipoPedidos.
     *     @example
     *     // Create many TipoPedidos
     *     const tipoPedido = await prisma.tipoPedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TipoPedidoCreateManyArgs>(
      args?: SelectSubset<T, TipoPedidoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TipoPedido.
     * @param {TipoPedidoDeleteArgs} args - Arguments to delete one TipoPedido.
     * @example
     * // Delete one TipoPedido
     * const TipoPedido = await prisma.tipoPedido.delete({
     *   where: {
     *     // ... filter to delete one TipoPedido
     *   }
     * })
     * 
    **/
    delete<T extends TipoPedidoDeleteArgs>(
      args: SelectSubset<T, TipoPedidoDeleteArgs>
    ): CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido>, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T>>>

    /**
     * Update one TipoPedido.
     * @param {TipoPedidoUpdateArgs} args - Arguments to update one TipoPedido.
     * @example
     * // Update one TipoPedido
     * const tipoPedido = await prisma.tipoPedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TipoPedidoUpdateArgs>(
      args: SelectSubset<T, TipoPedidoUpdateArgs>
    ): CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido>, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T>>>

    /**
     * Delete zero or more TipoPedidos.
     * @param {TipoPedidoDeleteManyArgs} args - Arguments to filter TipoPedidos to delete.
     * @example
     * // Delete a few TipoPedidos
     * const { count } = await prisma.tipoPedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TipoPedidoDeleteManyArgs>(
      args?: SelectSubset<T, TipoPedidoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoPedidos
     * const tipoPedido = await prisma.tipoPedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TipoPedidoUpdateManyArgs>(
      args: SelectSubset<T, TipoPedidoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoPedido.
     * @param {TipoPedidoUpsertArgs} args - Arguments to update or create a TipoPedido.
     * @example
     * // Update or create a TipoPedido
     * const tipoPedido = await prisma.tipoPedido.upsert({
     *   create: {
     *     // ... data to create a TipoPedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoPedido we want to update
     *   }
     * })
    **/
    upsert<T extends TipoPedidoUpsertArgs>(
      args: SelectSubset<T, TipoPedidoUpsertArgs>
    ): CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido>, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T>>>

    /**
     * Find one TipoPedido that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TipoPedidoFindUniqueOrThrowArgs} args - Arguments to find a TipoPedido
     * @example
     * // Get one TipoPedido
     * const tipoPedido = await prisma.tipoPedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TipoPedidoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TipoPedidoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido>, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T>>>

    /**
     * Find the first TipoPedido that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPedidoFindFirstOrThrowArgs} args - Arguments to find a TipoPedido
     * @example
     * // Get one TipoPedido
     * const tipoPedido = await prisma.tipoPedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TipoPedidoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TipoPedidoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido>, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T>>>

    /**
     * Count the number of TipoPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPedidoCountArgs} args - Arguments to filter TipoPedidos to count.
     * @example
     * // Count the number of TipoPedidos
     * const count = await prisma.tipoPedido.count({
     *   where: {
     *     // ... the filter for the TipoPedidos we want to count
     *   }
     * })
    **/
    count<T extends TipoPedidoCountArgs>(
      args?: Subset<T, TipoPedidoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoPedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoPedidoAggregateArgs>(args: Subset<T, TipoPedidoAggregateArgs>): PrismaPromise<GetTipoPedidoAggregateType<T>>

    /**
     * Group by TipoPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoPedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoPedidoGroupByArgs['orderBy'] }
        : { orderBy?: TipoPedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoPedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoPedidoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoPedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TipoPedidoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pedidos<T extends PedidoFindManyArgs = {}>(args?: Subset<T, PedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TipoPedido base type for findUnique actions
   */
  export type TipoPedidoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TipoPedido
     * 
    **/
    select?: TipoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPedidoInclude | null
    /**
     * Filter, which TipoPedido to fetch.
     * 
    **/
    where: TipoPedidoWhereUniqueInput
  }

  /**
   * TipoPedido: findUnique
   */
  export interface TipoPedidoFindUniqueArgs extends TipoPedidoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoPedido base type for findFirst actions
   */
  export type TipoPedidoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TipoPedido
     * 
    **/
    select?: TipoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPedidoInclude | null
    /**
     * Filter, which TipoPedido to fetch.
     * 
    **/
    where?: TipoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoPedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoPedidos.
     * 
    **/
    cursor?: TipoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoPedidos.
     * 
    **/
    distinct?: Enumerable<TipoPedidoScalarFieldEnum>
  }

  /**
   * TipoPedido: findFirst
   */
  export interface TipoPedidoFindFirstArgs extends TipoPedidoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TipoPedido findMany
   */
  export type TipoPedidoFindManyArgs = {
    /**
     * Select specific fields to fetch from the TipoPedido
     * 
    **/
    select?: TipoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPedidoInclude | null
    /**
     * Filter, which TipoPedidos to fetch.
     * 
    **/
    where?: TipoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoPedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoPedidos.
     * 
    **/
    cursor?: TipoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPedidos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TipoPedidoScalarFieldEnum>
  }


  /**
   * TipoPedido create
   */
  export type TipoPedidoCreateArgs = {
    /**
     * Select specific fields to fetch from the TipoPedido
     * 
    **/
    select?: TipoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPedidoInclude | null
    /**
     * The data needed to create a TipoPedido.
     * 
    **/
    data: XOR<TipoPedidoCreateInput, TipoPedidoUncheckedCreateInput>
  }


  /**
   * TipoPedido createMany
   */
  export type TipoPedidoCreateManyArgs = {
    /**
     * The data used to create many TipoPedidos.
     * 
    **/
    data: Enumerable<TipoPedidoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TipoPedido update
   */
  export type TipoPedidoUpdateArgs = {
    /**
     * Select specific fields to fetch from the TipoPedido
     * 
    **/
    select?: TipoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPedidoInclude | null
    /**
     * The data needed to update a TipoPedido.
     * 
    **/
    data: XOR<TipoPedidoUpdateInput, TipoPedidoUncheckedUpdateInput>
    /**
     * Choose, which TipoPedido to update.
     * 
    **/
    where: TipoPedidoWhereUniqueInput
  }


  /**
   * TipoPedido updateMany
   */
  export type TipoPedidoUpdateManyArgs = {
    /**
     * The data used to update TipoPedidos.
     * 
    **/
    data: XOR<TipoPedidoUpdateManyMutationInput, TipoPedidoUncheckedUpdateManyInput>
    /**
     * Filter which TipoPedidos to update
     * 
    **/
    where?: TipoPedidoWhereInput
  }


  /**
   * TipoPedido upsert
   */
  export type TipoPedidoUpsertArgs = {
    /**
     * Select specific fields to fetch from the TipoPedido
     * 
    **/
    select?: TipoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPedidoInclude | null
    /**
     * The filter to search for the TipoPedido to update in case it exists.
     * 
    **/
    where: TipoPedidoWhereUniqueInput
    /**
     * In case the TipoPedido found by the `where` argument doesn't exist, create a new TipoPedido with this data.
     * 
    **/
    create: XOR<TipoPedidoCreateInput, TipoPedidoUncheckedCreateInput>
    /**
     * In case the TipoPedido was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TipoPedidoUpdateInput, TipoPedidoUncheckedUpdateInput>
  }


  /**
   * TipoPedido delete
   */
  export type TipoPedidoDeleteArgs = {
    /**
     * Select specific fields to fetch from the TipoPedido
     * 
    **/
    select?: TipoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPedidoInclude | null
    /**
     * Filter which TipoPedido to delete.
     * 
    **/
    where: TipoPedidoWhereUniqueInput
  }


  /**
   * TipoPedido deleteMany
   */
  export type TipoPedidoDeleteManyArgs = {
    /**
     * Filter which TipoPedidos to delete
     * 
    **/
    where?: TipoPedidoWhereInput
  }


  /**
   * TipoPedido: findUniqueOrThrow
   */
  export type TipoPedidoFindUniqueOrThrowArgs = TipoPedidoFindUniqueArgsBase
      

  /**
   * TipoPedido: findFirstOrThrow
   */
  export type TipoPedidoFindFirstOrThrowArgs = TipoPedidoFindFirstArgsBase
      

  /**
   * TipoPedido without action
   */
  export type TipoPedidoArgs = {
    /**
     * Select specific fields to fetch from the TipoPedido
     * 
    **/
    select?: TipoPedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoPedidoInclude | null
  }



  /**
   * Model Pedido
   */


  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id: number | null
    precio: Decimal | null
    idEstado: number | null
    idSucursal: number | null
    idMesa: number | null
    idTipoPedido: number | null
  }

  export type PedidoSumAggregateOutputType = {
    id: number | null
    precio: Decimal | null
    idEstado: number | null
    idSucursal: number | null
    idMesa: number | null
    idTipoPedido: number | null
  }

  export type PedidoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    precio: Decimal | null
    fecha: Date | null
    idEstado: number | null
    idCliente: string | null
    idMesero: string | null
    idSucursal: number | null
    idMesa: number | null
    idTipoPedido: number | null
  }

  export type PedidoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    precio: Decimal | null
    fecha: Date | null
    idEstado: number | null
    idCliente: string | null
    idMesero: string | null
    idSucursal: number | null
    idMesa: number | null
    idTipoPedido: number | null
  }

  export type PedidoCountAggregateOutputType = {
    id: number
    nombre: number
    precio: number
    fecha: number
    idEstado: number
    idCliente: number
    idMesero: number
    idSucursal: number
    idMesa: number
    idTipoPedido: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id?: true
    precio?: true
    idEstado?: true
    idSucursal?: true
    idMesa?: true
    idTipoPedido?: true
  }

  export type PedidoSumAggregateInputType = {
    id?: true
    precio?: true
    idEstado?: true
    idSucursal?: true
    idMesa?: true
    idTipoPedido?: true
  }

  export type PedidoMinAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    fecha?: true
    idEstado?: true
    idCliente?: true
    idMesero?: true
    idSucursal?: true
    idMesa?: true
    idTipoPedido?: true
  }

  export type PedidoMaxAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    fecha?: true
    idEstado?: true
    idCliente?: true
    idMesero?: true
    idSucursal?: true
    idMesa?: true
    idTipoPedido?: true
  }

  export type PedidoCountAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    fecha?: true
    idEstado?: true
    idCliente?: true
    idMesero?: true
    idSucursal?: true
    idMesa?: true
    idTipoPedido?: true
    _all?: true
  }

  export type PedidoAggregateArgs = {
    /**
     * Filter which Pedido to aggregate.
     * 
    **/
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs = {
    where?: PedidoWhereInput
    orderBy?: Enumerable<PedidoOrderByWithAggregationInput>
    by: Array<PedidoScalarFieldEnum>
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }


  export type PedidoGroupByOutputType = {
    id: number
    nombre: string | null
    precio: Decimal
    fecha: Date
    idEstado: number
    idCliente: string
    idMesero: string | null
    idSucursal: number
    idMesa: number | null
    idTipoPedido: number
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect = {
    id?: boolean
    nombre?: boolean
    precio?: boolean
    fecha?: boolean
    detalles?: boolean | Pedido_ProductoFindManyArgs
    EstadoPedido?: boolean | EstadoPedidoArgs
    idEstado?: boolean
    Cliente?: boolean | UsuarioArgs
    idCliente?: boolean
    Mesero?: boolean | UsuarioArgs
    idMesero?: boolean
    Sucursal?: boolean | SucursalArgs
    idSucursal?: boolean
    Mesa?: boolean | MesaArgs
    idMesa?: boolean
    TipoPedido?: boolean | TipoPedidoArgs
    idTipoPedido?: boolean
    _count?: boolean | PedidoCountOutputTypeArgs
  }

  export type PedidoInclude = {
    detalles?: boolean | Pedido_ProductoFindManyArgs
    EstadoPedido?: boolean | EstadoPedidoArgs
    Cliente?: boolean | UsuarioArgs
    Mesero?: boolean | UsuarioArgs
    Sucursal?: boolean | SucursalArgs
    Mesa?: boolean | MesaArgs
    TipoPedido?: boolean | TipoPedidoArgs
    _count?: boolean | PedidoCountOutputTypeArgs
  }

  export type PedidoGetPayload<
    S extends boolean | null | undefined | PedidoArgs,
    U = keyof S
      > = S extends true
        ? Pedido
    : S extends undefined
    ? never
    : S extends PedidoArgs | PedidoFindManyArgs
    ?'include' extends U
    ? Pedido  & {
    [P in TrueKeys<S['include']>]:
        P extends 'detalles' ? Array < Pedido_ProductoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'EstadoPedido' ? EstadoPedidoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Cliente' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Mesero' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Mesa' ? MesaGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'TipoPedido' ? TipoPedidoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? PedidoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'detalles' ? Array < Pedido_ProductoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'EstadoPedido' ? EstadoPedidoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Cliente' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Mesero' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Sucursal' ? SucursalGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Mesa' ? MesaGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'TipoPedido' ? TipoPedidoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? PedidoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Pedido ? Pedido[P] : never
  } 
    : Pedido
  : Pedido


  type PedidoCountArgs = Merge<
    Omit<PedidoFindManyArgs, 'select' | 'include'> & {
      select?: PedidoCountAggregateInputType | true
    }
  >

  export interface PedidoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PedidoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pedido'> extends True ? CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>> : CheckSelect<T, Prisma__PedidoClient<Pedido | null >, Prisma__PedidoClient<PedidoGetPayload<T> | null >>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PedidoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pedido'> extends True ? CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>> : CheckSelect<T, Prisma__PedidoClient<Pedido | null >, Prisma__PedidoClient<PedidoGetPayload<T> | null >>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoWithIdOnly = await prisma.pedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PedidoFindManyArgs>(
      args?: SelectSubset<T, PedidoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
    **/
    create<T extends PedidoCreateArgs>(
      args: SelectSubset<T, PedidoCreateArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Create many Pedidos.
     *     @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     *     @example
     *     // Create many Pedidos
     *     const pedido = await prisma.pedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoCreateManyArgs>(
      args?: SelectSubset<T, PedidoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
    **/
    delete<T extends PedidoDeleteArgs>(
      args: SelectSubset<T, PedidoDeleteArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoUpdateArgs>(
      args: SelectSubset<T, PedidoUpdateArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoDeleteManyArgs>(
      args?: SelectSubset<T, PedidoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoUpdateManyArgs>(
      args: SelectSubset<T, PedidoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoUpsertArgs>(
      args: SelectSubset<T, PedidoUpsertArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Find one Pedido that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PedidoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Find the first Pedido that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PedidoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PedidoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    detalles<T extends Pedido_ProductoFindManyArgs = {}>(args?: Subset<T, Pedido_ProductoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido_Producto>>, PrismaPromise<Array<Pedido_ProductoGetPayload<T>>>>;

    EstadoPedido<T extends EstadoPedidoArgs = {}>(args?: Subset<T, EstadoPedidoArgs>): CheckSelect<T, Prisma__EstadoPedidoClient<EstadoPedido | null >, Prisma__EstadoPedidoClient<EstadoPedidoGetPayload<T> | null >>;

    Cliente<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>;

    Mesero<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>;

    Sucursal<T extends SucursalArgs = {}>(args?: Subset<T, SucursalArgs>): CheckSelect<T, Prisma__SucursalClient<Sucursal | null >, Prisma__SucursalClient<SucursalGetPayload<T> | null >>;

    Mesa<T extends MesaArgs = {}>(args?: Subset<T, MesaArgs>): CheckSelect<T, Prisma__MesaClient<Mesa | null >, Prisma__MesaClient<MesaGetPayload<T> | null >>;

    TipoPedido<T extends TipoPedidoArgs = {}>(args?: Subset<T, TipoPedidoArgs>): CheckSelect<T, Prisma__TipoPedidoClient<TipoPedido | null >, Prisma__TipoPedidoClient<TipoPedidoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pedido base type for findUnique actions
   */
  export type PedidoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     * 
    **/
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido: findUnique
   */
  export interface PedidoFindUniqueArgs extends PedidoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido base type for findFirst actions
   */
  export type PedidoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     * 
    **/
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     * 
    **/
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     * 
    **/
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }

  /**
   * Pedido: findFirst
   */
  export interface PedidoFindFirstArgs extends PedidoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter, which Pedidos to fetch.
     * 
    **/
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     * 
    **/
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }


  /**
   * Pedido create
   */
  export type PedidoCreateArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * The data needed to create a Pedido.
     * 
    **/
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }


  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs = {
    /**
     * The data used to create many Pedidos.
     * 
    **/
    data: Enumerable<PedidoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pedido update
   */
  export type PedidoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * The data needed to update a Pedido.
     * 
    **/
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     * 
    **/
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs = {
    /**
     * The data used to update Pedidos.
     * 
    **/
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     * 
    **/
    where?: PedidoWhereInput
  }


  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     * 
    **/
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     * 
    **/
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }


  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter which Pedido to delete.
     * 
    **/
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs = {
    /**
     * Filter which Pedidos to delete
     * 
    **/
    where?: PedidoWhereInput
  }


  /**
   * Pedido: findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs = PedidoFindUniqueArgsBase
      

  /**
   * Pedido: findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs = PedidoFindFirstArgsBase
      

  /**
   * Pedido without action
   */
  export type PedidoArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
  }



  /**
   * Model Pedido_Producto
   */


  export type AggregatePedido_Producto = {
    _count: Pedido_ProductoCountAggregateOutputType | null
    _avg: Pedido_ProductoAvgAggregateOutputType | null
    _sum: Pedido_ProductoSumAggregateOutputType | null
    _min: Pedido_ProductoMinAggregateOutputType | null
    _max: Pedido_ProductoMaxAggregateOutputType | null
  }

  export type Pedido_ProductoAvgAggregateOutputType = {
    idPedido: number | null
    idProducto: number | null
    cantidad: number | null
  }

  export type Pedido_ProductoSumAggregateOutputType = {
    idPedido: number | null
    idProducto: number | null
    cantidad: number | null
  }

  export type Pedido_ProductoMinAggregateOutputType = {
    idPedido: number | null
    idProducto: number | null
    cantidad: number | null
    notas: string | null
  }

  export type Pedido_ProductoMaxAggregateOutputType = {
    idPedido: number | null
    idProducto: number | null
    cantidad: number | null
    notas: string | null
  }

  export type Pedido_ProductoCountAggregateOutputType = {
    idPedido: number
    idProducto: number
    cantidad: number
    notas: number
    _all: number
  }


  export type Pedido_ProductoAvgAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
  }

  export type Pedido_ProductoSumAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
  }

  export type Pedido_ProductoMinAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
    notas?: true
  }

  export type Pedido_ProductoMaxAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
    notas?: true
  }

  export type Pedido_ProductoCountAggregateInputType = {
    idPedido?: true
    idProducto?: true
    cantidad?: true
    notas?: true
    _all?: true
  }

  export type Pedido_ProductoAggregateArgs = {
    /**
     * Filter which Pedido_Producto to aggregate.
     * 
    **/
    where?: Pedido_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedido_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Pedido_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Pedido_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedido_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedido_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedido_Productos
    **/
    _count?: true | Pedido_ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pedido_ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pedido_ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pedido_ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pedido_ProductoMaxAggregateInputType
  }

  export type GetPedido_ProductoAggregateType<T extends Pedido_ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido_Producto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido_Producto[P]>
      : GetScalarType<T[P], AggregatePedido_Producto[P]>
  }




  export type Pedido_ProductoGroupByArgs = {
    where?: Pedido_ProductoWhereInput
    orderBy?: Enumerable<Pedido_ProductoOrderByWithAggregationInput>
    by: Array<Pedido_ProductoScalarFieldEnum>
    having?: Pedido_ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pedido_ProductoCountAggregateInputType | true
    _avg?: Pedido_ProductoAvgAggregateInputType
    _sum?: Pedido_ProductoSumAggregateInputType
    _min?: Pedido_ProductoMinAggregateInputType
    _max?: Pedido_ProductoMaxAggregateInputType
  }


  export type Pedido_ProductoGroupByOutputType = {
    idPedido: number
    idProducto: number
    cantidad: number
    notas: string
    _count: Pedido_ProductoCountAggregateOutputType | null
    _avg: Pedido_ProductoAvgAggregateOutputType | null
    _sum: Pedido_ProductoSumAggregateOutputType | null
    _min: Pedido_ProductoMinAggregateOutputType | null
    _max: Pedido_ProductoMaxAggregateOutputType | null
  }

  type GetPedido_ProductoGroupByPayload<T extends Pedido_ProductoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Pedido_ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pedido_ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pedido_ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], Pedido_ProductoGroupByOutputType[P]>
        }
      >
    >


  export type Pedido_ProductoSelect = {
    Pedido?: boolean | PedidoArgs
    idPedido?: boolean
    Producto?: boolean | ProductoArgs
    idProducto?: boolean
    cantidad?: boolean
    notas?: boolean
  }

  export type Pedido_ProductoInclude = {
    Pedido?: boolean | PedidoArgs
    Producto?: boolean | ProductoArgs
  }

  export type Pedido_ProductoGetPayload<
    S extends boolean | null | undefined | Pedido_ProductoArgs,
    U = keyof S
      > = S extends true
        ? Pedido_Producto
    : S extends undefined
    ? never
    : S extends Pedido_ProductoArgs | Pedido_ProductoFindManyArgs
    ?'include' extends U
    ? Pedido_Producto  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Pedido' ? PedidoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Pedido' ? PedidoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Producto' ? ProductoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Pedido_Producto ? Pedido_Producto[P] : never
  } 
    : Pedido_Producto
  : Pedido_Producto


  type Pedido_ProductoCountArgs = Merge<
    Omit<Pedido_ProductoFindManyArgs, 'select' | 'include'> & {
      select?: Pedido_ProductoCountAggregateInputType | true
    }
  >

  export interface Pedido_ProductoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pedido_Producto that matches the filter.
     * @param {Pedido_ProductoFindUniqueArgs} args - Arguments to find a Pedido_Producto
     * @example
     * // Get one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Pedido_ProductoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Pedido_ProductoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pedido_Producto'> extends True ? CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto | null >, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T> | null >>

    /**
     * Find the first Pedido_Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoFindFirstArgs} args - Arguments to find a Pedido_Producto
     * @example
     * // Get one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Pedido_ProductoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Pedido_ProductoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pedido_Producto'> extends True ? CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>> : CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto | null >, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T> | null >>

    /**
     * Find zero or more Pedido_Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedido_Productos
     * const pedido_Productos = await prisma.pedido_Producto.findMany()
     * 
     * // Get first 10 Pedido_Productos
     * const pedido_Productos = await prisma.pedido_Producto.findMany({ take: 10 })
     * 
     * // Only select the `idPedido`
     * const pedido_ProductoWithIdPedidoOnly = await prisma.pedido_Producto.findMany({ select: { idPedido: true } })
     * 
    **/
    findMany<T extends Pedido_ProductoFindManyArgs>(
      args?: SelectSubset<T, Pedido_ProductoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Pedido_Producto>>, PrismaPromise<Array<Pedido_ProductoGetPayload<T>>>>

    /**
     * Create a Pedido_Producto.
     * @param {Pedido_ProductoCreateArgs} args - Arguments to create a Pedido_Producto.
     * @example
     * // Create one Pedido_Producto
     * const Pedido_Producto = await prisma.pedido_Producto.create({
     *   data: {
     *     // ... data to create a Pedido_Producto
     *   }
     * })
     * 
    **/
    create<T extends Pedido_ProductoCreateArgs>(
      args: SelectSubset<T, Pedido_ProductoCreateArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Create many Pedido_Productos.
     *     @param {Pedido_ProductoCreateManyArgs} args - Arguments to create many Pedido_Productos.
     *     @example
     *     // Create many Pedido_Productos
     *     const pedido_Producto = await prisma.pedido_Producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Pedido_ProductoCreateManyArgs>(
      args?: SelectSubset<T, Pedido_ProductoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido_Producto.
     * @param {Pedido_ProductoDeleteArgs} args - Arguments to delete one Pedido_Producto.
     * @example
     * // Delete one Pedido_Producto
     * const Pedido_Producto = await prisma.pedido_Producto.delete({
     *   where: {
     *     // ... filter to delete one Pedido_Producto
     *   }
     * })
     * 
    **/
    delete<T extends Pedido_ProductoDeleteArgs>(
      args: SelectSubset<T, Pedido_ProductoDeleteArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Update one Pedido_Producto.
     * @param {Pedido_ProductoUpdateArgs} args - Arguments to update one Pedido_Producto.
     * @example
     * // Update one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Pedido_ProductoUpdateArgs>(
      args: SelectSubset<T, Pedido_ProductoUpdateArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Delete zero or more Pedido_Productos.
     * @param {Pedido_ProductoDeleteManyArgs} args - Arguments to filter Pedido_Productos to delete.
     * @example
     * // Delete a few Pedido_Productos
     * const { count } = await prisma.pedido_Producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Pedido_ProductoDeleteManyArgs>(
      args?: SelectSubset<T, Pedido_ProductoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedido_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedido_Productos
     * const pedido_Producto = await prisma.pedido_Producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Pedido_ProductoUpdateManyArgs>(
      args: SelectSubset<T, Pedido_ProductoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido_Producto.
     * @param {Pedido_ProductoUpsertArgs} args - Arguments to update or create a Pedido_Producto.
     * @example
     * // Update or create a Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.upsert({
     *   create: {
     *     // ... data to create a Pedido_Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido_Producto we want to update
     *   }
     * })
    **/
    upsert<T extends Pedido_ProductoUpsertArgs>(
      args: SelectSubset<T, Pedido_ProductoUpsertArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Find one Pedido_Producto that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Pedido_ProductoFindUniqueOrThrowArgs} args - Arguments to find a Pedido_Producto
     * @example
     * // Get one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Pedido_ProductoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Pedido_ProductoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Find the first Pedido_Producto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoFindFirstOrThrowArgs} args - Arguments to find a Pedido_Producto
     * @example
     * // Get one Pedido_Producto
     * const pedido_Producto = await prisma.pedido_Producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Pedido_ProductoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Pedido_ProductoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Pedido_ProductoClient<Pedido_Producto>, Prisma__Pedido_ProductoClient<Pedido_ProductoGetPayload<T>>>

    /**
     * Count the number of Pedido_Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoCountArgs} args - Arguments to filter Pedido_Productos to count.
     * @example
     * // Count the number of Pedido_Productos
     * const count = await prisma.pedido_Producto.count({
     *   where: {
     *     // ... the filter for the Pedido_Productos we want to count
     *   }
     * })
    **/
    count<T extends Pedido_ProductoCountArgs>(
      args?: Subset<T, Pedido_ProductoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pedido_ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pedido_ProductoAggregateArgs>(args: Subset<T, Pedido_ProductoAggregateArgs>): PrismaPromise<GetPedido_ProductoAggregateType<T>>

    /**
     * Group by Pedido_Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pedido_ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pedido_ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pedido_ProductoGroupByArgs['orderBy'] }
        : { orderBy?: Pedido_ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pedido_ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedido_ProductoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido_Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Pedido_ProductoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Pedido<T extends PedidoArgs = {}>(args?: Subset<T, PedidoArgs>): CheckSelect<T, Prisma__PedidoClient<Pedido | null >, Prisma__PedidoClient<PedidoGetPayload<T> | null >>;

    Producto<T extends ProductoArgs = {}>(args?: Subset<T, ProductoArgs>): CheckSelect<T, Prisma__ProductoClient<Producto | null >, Prisma__ProductoClient<ProductoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pedido_Producto base type for findUnique actions
   */
  export type Pedido_ProductoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * Filter, which Pedido_Producto to fetch.
     * 
    **/
    where: Pedido_ProductoWhereUniqueInput
  }

  /**
   * Pedido_Producto: findUnique
   */
  export interface Pedido_ProductoFindUniqueArgs extends Pedido_ProductoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido_Producto base type for findFirst actions
   */
  export type Pedido_ProductoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * Filter, which Pedido_Producto to fetch.
     * 
    **/
    where?: Pedido_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedido_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Pedido_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedido_Productos.
     * 
    **/
    cursor?: Pedido_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedido_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedido_Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedido_Productos.
     * 
    **/
    distinct?: Enumerable<Pedido_ProductoScalarFieldEnum>
  }

  /**
   * Pedido_Producto: findFirst
   */
  export interface Pedido_ProductoFindFirstArgs extends Pedido_ProductoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido_Producto findMany
   */
  export type Pedido_ProductoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * Filter, which Pedido_Productos to fetch.
     * 
    **/
    where?: Pedido_ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedido_Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<Pedido_ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedido_Productos.
     * 
    **/
    cursor?: Pedido_ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedido_Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedido_Productos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Pedido_ProductoScalarFieldEnum>
  }


  /**
   * Pedido_Producto create
   */
  export type Pedido_ProductoCreateArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * The data needed to create a Pedido_Producto.
     * 
    **/
    data: XOR<Pedido_ProductoCreateInput, Pedido_ProductoUncheckedCreateInput>
  }


  /**
   * Pedido_Producto createMany
   */
  export type Pedido_ProductoCreateManyArgs = {
    /**
     * The data used to create many Pedido_Productos.
     * 
    **/
    data: Enumerable<Pedido_ProductoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pedido_Producto update
   */
  export type Pedido_ProductoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * The data needed to update a Pedido_Producto.
     * 
    **/
    data: XOR<Pedido_ProductoUpdateInput, Pedido_ProductoUncheckedUpdateInput>
    /**
     * Choose, which Pedido_Producto to update.
     * 
    **/
    where: Pedido_ProductoWhereUniqueInput
  }


  /**
   * Pedido_Producto updateMany
   */
  export type Pedido_ProductoUpdateManyArgs = {
    /**
     * The data used to update Pedido_Productos.
     * 
    **/
    data: XOR<Pedido_ProductoUpdateManyMutationInput, Pedido_ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Pedido_Productos to update
     * 
    **/
    where?: Pedido_ProductoWhereInput
  }


  /**
   * Pedido_Producto upsert
   */
  export type Pedido_ProductoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * The filter to search for the Pedido_Producto to update in case it exists.
     * 
    **/
    where: Pedido_ProductoWhereUniqueInput
    /**
     * In case the Pedido_Producto found by the `where` argument doesn't exist, create a new Pedido_Producto with this data.
     * 
    **/
    create: XOR<Pedido_ProductoCreateInput, Pedido_ProductoUncheckedCreateInput>
    /**
     * In case the Pedido_Producto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Pedido_ProductoUpdateInput, Pedido_ProductoUncheckedUpdateInput>
  }


  /**
   * Pedido_Producto delete
   */
  export type Pedido_ProductoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
    /**
     * Filter which Pedido_Producto to delete.
     * 
    **/
    where: Pedido_ProductoWhereUniqueInput
  }


  /**
   * Pedido_Producto deleteMany
   */
  export type Pedido_ProductoDeleteManyArgs = {
    /**
     * Filter which Pedido_Productos to delete
     * 
    **/
    where?: Pedido_ProductoWhereInput
  }


  /**
   * Pedido_Producto: findUniqueOrThrow
   */
  export type Pedido_ProductoFindUniqueOrThrowArgs = Pedido_ProductoFindUniqueArgsBase
      

  /**
   * Pedido_Producto: findFirstOrThrow
   */
  export type Pedido_ProductoFindFirstOrThrowArgs = Pedido_ProductoFindFirstArgsBase
      

  /**
   * Pedido_Producto without action
   */
  export type Pedido_ProductoArgs = {
    /**
     * Select specific fields to fetch from the Pedido_Producto
     * 
    **/
    select?: Pedido_ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Pedido_ProductoInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Categoria_ProductoScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type Categoria_ProductoScalarFieldEnum = (typeof Categoria_ProductoScalarFieldEnum)[keyof typeof Categoria_ProductoScalarFieldEnum]


  export const DisponibilidadMesaScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type DisponibilidadMesaScalarFieldEnum = (typeof DisponibilidadMesaScalarFieldEnum)[keyof typeof DisponibilidadMesaScalarFieldEnum]


  export const EstadoPedidoScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type EstadoPedidoScalarFieldEnum = (typeof EstadoPedidoScalarFieldEnum)[keyof typeof EstadoPedidoScalarFieldEnum]


  export const FacturaEncabezadoTipoPagoScalarFieldEnum: {
    idFactura_Encabezado: 'idFactura_Encabezado',
    idTipoPago: 'idTipoPago',
    monto: 'monto'
  };

  export type FacturaEncabezadoTipoPagoScalarFieldEnum = (typeof FacturaEncabezadoTipoPagoScalarFieldEnum)[keyof typeof FacturaEncabezadoTipoPagoScalarFieldEnum]


  export const Factura_DetalleScalarFieldEnum: {
    id: 'id',
    cantidad: 'cantidad',
    precio: 'precio',
    impuesto: 'impuesto',
    total_detalle: 'total_detalle',
    idFactura_Encabezado: 'idFactura_Encabezado',
    idProducto: 'idProducto'
  };

  export type Factura_DetalleScalarFieldEnum = (typeof Factura_DetalleScalarFieldEnum)[keyof typeof Factura_DetalleScalarFieldEnum]


  export const Factura_EncabezadoScalarFieldEnum: {
    id: 'id',
    numero_tarjeta: 'numero_tarjeta',
    idTipoTarjeta: 'idTipoTarjeta',
    fecha: 'fecha',
    estado: 'estado',
    idUsuario: 'idUsuario'
  };

  export type Factura_EncabezadoScalarFieldEnum = (typeof Factura_EncabezadoScalarFieldEnum)[keyof typeof Factura_EncabezadoScalarFieldEnum]


  export const MesaScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    capacidad: 'capacidad',
    estado: 'estado',
    idSucursal: 'idSucursal',
    idDisponibilidad: 'idDisponibilidad'
  };

  export type MesaScalarFieldEnum = (typeof MesaScalarFieldEnum)[keyof typeof MesaScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    precio: 'precio',
    fecha: 'fecha',
    idEstado: 'idEstado',
    idCliente: 'idCliente',
    idMesero: 'idMesero',
    idSucursal: 'idSucursal',
    idMesa: 'idMesa',
    idTipoPedido: 'idTipoPedido'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const Pedido_ProductoScalarFieldEnum: {
    idPedido: 'idPedido',
    idProducto: 'idProducto',
    cantidad: 'cantidad',
    notas: 'notas'
  };

  export type Pedido_ProductoScalarFieldEnum = (typeof Pedido_ProductoScalarFieldEnum)[keyof typeof Pedido_ProductoScalarFieldEnum]


  export const PerfilScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type PerfilScalarFieldEnum = (typeof PerfilScalarFieldEnum)[keyof typeof PerfilScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    ingredientes: 'ingredientes',
    precio: 'precio',
    imagen: 'imagen',
    estado: 'estado',
    idCategoria: 'idCategoria'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const ReservacionScalarFieldEnum: {
    id: 'id',
    fecha_hora: 'fecha_hora',
    cantidad: 'cantidad',
    idSucursal: 'idSucursal',
    idUsuario: 'idUsuario'
  };

  export type ReservacionScalarFieldEnum = (typeof ReservacionScalarFieldEnum)[keyof typeof ReservacionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SucursalScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nombre: 'nombre',
    ubicacion: 'ubicacion',
    capacidad: 'capacidad'
  };

  export type SucursalScalarFieldEnum = (typeof SucursalScalarFieldEnum)[keyof typeof SucursalScalarFieldEnum]


  export const TipoPagoScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type TipoPagoScalarFieldEnum = (typeof TipoPagoScalarFieldEnum)[keyof typeof TipoPagoScalarFieldEnum]


  export const TipoPedidoScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type TipoPedidoScalarFieldEnum = (typeof TipoPedidoScalarFieldEnum)[keyof typeof TipoPedidoScalarFieldEnum]


  export const TipoTarjetaScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion'
  };

  export type TipoTarjetaScalarFieldEnum = (typeof TipoTarjetaScalarFieldEnum)[keyof typeof TipoTarjetaScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido1: 'apellido1',
    apellido2: 'apellido2',
    correo: 'correo',
    username: 'username',
    clave: 'clave',
    telefono: 'telefono',
    direccion: 'direccion',
    idPerfil: 'idPerfil'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type PerfilWhereInput = {
    AND?: Enumerable<PerfilWhereInput>
    OR?: Enumerable<PerfilWhereInput>
    NOT?: Enumerable<PerfilWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    usuarios?: UsuarioListRelationFilter
  }

  export type PerfilOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    usuarios?: UsuarioOrderByRelationAggregateInput
  }

  export type PerfilWhereUniqueInput = {
    id?: number
  }

  export type PerfilOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: PerfilCountOrderByAggregateInput
    _avg?: PerfilAvgOrderByAggregateInput
    _max?: PerfilMaxOrderByAggregateInput
    _min?: PerfilMinOrderByAggregateInput
    _sum?: PerfilSumOrderByAggregateInput
  }

  export type PerfilScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PerfilScalarWhereWithAggregatesInput>
    OR?: Enumerable<PerfilScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PerfilScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type UsuarioWhereInput = {
    AND?: Enumerable<UsuarioWhereInput>
    OR?: Enumerable<UsuarioWhereInput>
    NOT?: Enumerable<UsuarioWhereInput>
    id?: StringFilter | string
    nombre?: StringFilter | string
    apellido1?: StringFilter | string
    apellido2?: StringFilter | string
    correo?: StringFilter | string
    username?: StringFilter | string
    clave?: StringFilter | string
    telefono?: StringFilter | string
    direccion?: StringNullableFilter | string | null
    reservaciones?: ReservacionListRelationFilter
    facturas?: Factura_EncabezadoListRelationFilter
    pedidos?: PedidoListRelationFilter
    encargos?: PedidoListRelationFilter
    Perfil?: XOR<PerfilRelationFilter, PerfilWhereInput>
    idPerfil?: IntFilter | number
    sucursales?: SucursalListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    reservaciones?: ReservacionOrderByRelationAggregateInput
    facturas?: Factura_EncabezadoOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
    encargos?: PedidoOrderByRelationAggregateInput
    Perfil?: PerfilOrderByWithRelationInput
    idPerfil?: SortOrder
    sucursales?: SucursalOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = {
    id?: string
    correo_username_telefono?: UsuarioCorreoUsernameTelefonoCompoundUniqueInput
  }

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    idPerfil?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nombre?: StringWithAggregatesFilter | string
    apellido1?: StringWithAggregatesFilter | string
    apellido2?: StringWithAggregatesFilter | string
    correo?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    clave?: StringWithAggregatesFilter | string
    telefono?: StringWithAggregatesFilter | string
    direccion?: StringNullableWithAggregatesFilter | string | null
    idPerfil?: IntWithAggregatesFilter | number
  }

  export type SucursalWhereInput = {
    AND?: Enumerable<SucursalWhereInput>
    OR?: Enumerable<SucursalWhereInput>
    NOT?: Enumerable<SucursalWhereInput>
    id?: IntFilter | number
    codigo?: StringFilter | string
    nombre?: StringFilter | string
    ubicacion?: StringFilter | string
    capacidad?: IntFilter | number
    mesas?: MesaListRelationFilter
    reservaciones?: ReservacionListRelationFilter
    productos?: ProductoListRelationFilter
    meseros?: UsuarioListRelationFilter
    pedidos?: PedidoListRelationFilter
  }

  export type SucursalOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
    mesas?: MesaOrderByRelationAggregateInput
    reservaciones?: ReservacionOrderByRelationAggregateInput
    productos?: ProductoOrderByRelationAggregateInput
    meseros?: UsuarioOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
  }

  export type SucursalWhereUniqueInput = {
    id?: number
    codigo_nombre?: SucursalCodigoNombreCompoundUniqueInput
  }

  export type SucursalOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
    _count?: SucursalCountOrderByAggregateInput
    _avg?: SucursalAvgOrderByAggregateInput
    _max?: SucursalMaxOrderByAggregateInput
    _min?: SucursalMinOrderByAggregateInput
    _sum?: SucursalSumOrderByAggregateInput
  }

  export type SucursalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SucursalScalarWhereWithAggregatesInput>
    OR?: Enumerable<SucursalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SucursalScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    codigo?: StringWithAggregatesFilter | string
    nombre?: StringWithAggregatesFilter | string
    ubicacion?: StringWithAggregatesFilter | string
    capacidad?: IntWithAggregatesFilter | number
  }

  export type MesaWhereInput = {
    AND?: Enumerable<MesaWhereInput>
    OR?: Enumerable<MesaWhereInput>
    NOT?: Enumerable<MesaWhereInput>
    id?: IntFilter | number
    codigo?: StringFilter | string
    capacidad?: IntFilter | number
    estado?: BoolFilter | boolean
    reservaciones?: ReservacionListRelationFilter
    pedidos?: PedidoListRelationFilter
    Sucursal?: XOR<SucursalRelationFilter, SucursalWhereInput>
    idSucursal?: IntFilter | number
    EstadoMesa?: XOR<DisponibilidadMesaRelationFilter, DisponibilidadMesaWhereInput>
    idDisponibilidad?: IntFilter | number
  }

  export type MesaOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    reservaciones?: ReservacionOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
    Sucursal?: SucursalOrderByWithRelationInput
    idSucursal?: SortOrder
    EstadoMesa?: DisponibilidadMesaOrderByWithRelationInput
    idDisponibilidad?: SortOrder
  }

  export type MesaWhereUniqueInput = {
    id?: number
    codigo?: string
  }

  export type MesaOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    idSucursal?: SortOrder
    idDisponibilidad?: SortOrder
    _count?: MesaCountOrderByAggregateInput
    _avg?: MesaAvgOrderByAggregateInput
    _max?: MesaMaxOrderByAggregateInput
    _min?: MesaMinOrderByAggregateInput
    _sum?: MesaSumOrderByAggregateInput
  }

  export type MesaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MesaScalarWhereWithAggregatesInput>
    OR?: Enumerable<MesaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MesaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    codigo?: StringWithAggregatesFilter | string
    capacidad?: IntWithAggregatesFilter | number
    estado?: BoolWithAggregatesFilter | boolean
    idSucursal?: IntWithAggregatesFilter | number
    idDisponibilidad?: IntWithAggregatesFilter | number
  }

  export type DisponibilidadMesaWhereInput = {
    AND?: Enumerable<DisponibilidadMesaWhereInput>
    OR?: Enumerable<DisponibilidadMesaWhereInput>
    NOT?: Enumerable<DisponibilidadMesaWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    mesas?: MesaListRelationFilter
  }

  export type DisponibilidadMesaOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    mesas?: MesaOrderByRelationAggregateInput
  }

  export type DisponibilidadMesaWhereUniqueInput = {
    id?: number
  }

  export type DisponibilidadMesaOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: DisponibilidadMesaCountOrderByAggregateInput
    _avg?: DisponibilidadMesaAvgOrderByAggregateInput
    _max?: DisponibilidadMesaMaxOrderByAggregateInput
    _min?: DisponibilidadMesaMinOrderByAggregateInput
    _sum?: DisponibilidadMesaSumOrderByAggregateInput
  }

  export type DisponibilidadMesaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DisponibilidadMesaScalarWhereWithAggregatesInput>
    OR?: Enumerable<DisponibilidadMesaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DisponibilidadMesaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type ReservacionWhereInput = {
    AND?: Enumerable<ReservacionWhereInput>
    OR?: Enumerable<ReservacionWhereInput>
    NOT?: Enumerable<ReservacionWhereInput>
    id?: IntFilter | number
    fecha_hora?: DateTimeFilter | Date | string
    cantidad?: IntFilter | number
    mesas?: MesaListRelationFilter
    Sucursal?: XOR<SucursalRelationFilter, SucursalWhereInput>
    idSucursal?: IntFilter | number
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    idUsuario?: StringFilter | string
  }

  export type ReservacionOrderByWithRelationInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    cantidad?: SortOrder
    mesas?: MesaOrderByRelationAggregateInput
    Sucursal?: SucursalOrderByWithRelationInput
    idSucursal?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
    idUsuario?: SortOrder
  }

  export type ReservacionWhereUniqueInput = {
    id?: number
  }

  export type ReservacionOrderByWithAggregationInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    cantidad?: SortOrder
    idSucursal?: SortOrder
    idUsuario?: SortOrder
    _count?: ReservacionCountOrderByAggregateInput
    _avg?: ReservacionAvgOrderByAggregateInput
    _max?: ReservacionMaxOrderByAggregateInput
    _min?: ReservacionMinOrderByAggregateInput
    _sum?: ReservacionSumOrderByAggregateInput
  }

  export type ReservacionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReservacionScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReservacionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReservacionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fecha_hora?: DateTimeWithAggregatesFilter | Date | string
    cantidad?: IntWithAggregatesFilter | number
    idSucursal?: IntWithAggregatesFilter | number
    idUsuario?: StringWithAggregatesFilter | string
  }

  export type Categoria_ProductoWhereInput = {
    AND?: Enumerable<Categoria_ProductoWhereInput>
    OR?: Enumerable<Categoria_ProductoWhereInput>
    NOT?: Enumerable<Categoria_ProductoWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    productos?: ProductoListRelationFilter
  }

  export type Categoria_ProductoOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    productos?: ProductoOrderByRelationAggregateInput
  }

  export type Categoria_ProductoWhereUniqueInput = {
    id?: number
    descripcion?: string
  }

  export type Categoria_ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: Categoria_ProductoCountOrderByAggregateInput
    _avg?: Categoria_ProductoAvgOrderByAggregateInput
    _max?: Categoria_ProductoMaxOrderByAggregateInput
    _min?: Categoria_ProductoMinOrderByAggregateInput
    _sum?: Categoria_ProductoSumOrderByAggregateInput
  }

  export type Categoria_ProductoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Categoria_ProductoScalarWhereWithAggregatesInput>
    OR?: Enumerable<Categoria_ProductoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Categoria_ProductoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type ProductoWhereInput = {
    AND?: Enumerable<ProductoWhereInput>
    OR?: Enumerable<ProductoWhereInput>
    NOT?: Enumerable<ProductoWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    descripcion?: StringFilter | string
    ingredientes?: StringNullableFilter | string | null
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    imagen?: StringFilter | string
    estado?: BoolFilter | boolean
    Categoria_Producto?: XOR<Categoria_ProductoRelationFilter, Categoria_ProductoWhereInput>
    idCategoria?: IntFilter | number
    detalles?: Factura_DetalleListRelationFilter
    pedidos?: Pedido_ProductoListRelationFilter
    sucursales?: SucursalListRelationFilter
  }

  export type ProductoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    Categoria_Producto?: Categoria_ProductoOrderByWithRelationInput
    idCategoria?: SortOrder
    detalles?: Factura_DetalleOrderByRelationAggregateInput
    pedidos?: Pedido_ProductoOrderByRelationAggregateInput
    sucursales?: SucursalOrderByRelationAggregateInput
  }

  export type ProductoWhereUniqueInput = {
    id?: number
  }

  export type ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
    _count?: ProductoCountOrderByAggregateInput
    _avg?: ProductoAvgOrderByAggregateInput
    _max?: ProductoMaxOrderByAggregateInput
    _min?: ProductoMinOrderByAggregateInput
    _sum?: ProductoSumOrderByAggregateInput
  }

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductoScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
    ingredientes?: StringNullableWithAggregatesFilter | string | null
    precio?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    imagen?: StringWithAggregatesFilter | string
    estado?: BoolWithAggregatesFilter | boolean
    idCategoria?: IntWithAggregatesFilter | number
  }

  export type TipoPagoWhereInput = {
    AND?: Enumerable<TipoPagoWhereInput>
    OR?: Enumerable<TipoPagoWhereInput>
    NOT?: Enumerable<TipoPagoWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    facturasEncabezado?: FacturaEncabezadoTipoPagoListRelationFilter
  }

  export type TipoPagoOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    facturasEncabezado?: FacturaEncabezadoTipoPagoOrderByRelationAggregateInput
  }

  export type TipoPagoWhereUniqueInput = {
    id?: number
  }

  export type TipoPagoOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: TipoPagoCountOrderByAggregateInput
    _avg?: TipoPagoAvgOrderByAggregateInput
    _max?: TipoPagoMaxOrderByAggregateInput
    _min?: TipoPagoMinOrderByAggregateInput
    _sum?: TipoPagoSumOrderByAggregateInput
  }

  export type TipoPagoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TipoPagoScalarWhereWithAggregatesInput>
    OR?: Enumerable<TipoPagoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TipoPagoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type TipoTarjetaWhereInput = {
    AND?: Enumerable<TipoTarjetaWhereInput>
    OR?: Enumerable<TipoTarjetaWhereInput>
    NOT?: Enumerable<TipoTarjetaWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    facturas?: Factura_EncabezadoListRelationFilter
  }

  export type TipoTarjetaOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    facturas?: Factura_EncabezadoOrderByRelationAggregateInput
  }

  export type TipoTarjetaWhereUniqueInput = {
    id?: number
    descripcion?: string
  }

  export type TipoTarjetaOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: TipoTarjetaCountOrderByAggregateInput
    _avg?: TipoTarjetaAvgOrderByAggregateInput
    _max?: TipoTarjetaMaxOrderByAggregateInput
    _min?: TipoTarjetaMinOrderByAggregateInput
    _sum?: TipoTarjetaSumOrderByAggregateInput
  }

  export type TipoTarjetaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TipoTarjetaScalarWhereWithAggregatesInput>
    OR?: Enumerable<TipoTarjetaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TipoTarjetaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type Factura_EncabezadoWhereInput = {
    AND?: Enumerable<Factura_EncabezadoWhereInput>
    OR?: Enumerable<Factura_EncabezadoWhereInput>
    NOT?: Enumerable<Factura_EncabezadoWhereInput>
    id?: IntFilter | number
    numero_tarjeta?: StringNullableFilter | string | null
    TipoTarjeta?: XOR<TipoTarjetaRelationFilter, TipoTarjetaWhereInput> | null
    idTipoTarjeta?: IntNullableFilter | number | null
    fecha?: DateTimeFilter | Date | string
    estado?: BoolFilter | boolean
    detalles?: Factura_DetalleListRelationFilter
    tipoPagos?: FacturaEncabezadoTipoPagoListRelationFilter
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    idUsuario?: StringFilter | string
  }

  export type Factura_EncabezadoOrderByWithRelationInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    TipoTarjeta?: TipoTarjetaOrderByWithRelationInput
    idTipoTarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    detalles?: Factura_DetalleOrderByRelationAggregateInput
    tipoPagos?: FacturaEncabezadoTipoPagoOrderByRelationAggregateInput
    Usuario?: UsuarioOrderByWithRelationInput
    idUsuario?: SortOrder
  }

  export type Factura_EncabezadoWhereUniqueInput = {
    id?: number
  }

  export type Factura_EncabezadoOrderByWithAggregationInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    idTipoTarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    idUsuario?: SortOrder
    _count?: Factura_EncabezadoCountOrderByAggregateInput
    _avg?: Factura_EncabezadoAvgOrderByAggregateInput
    _max?: Factura_EncabezadoMaxOrderByAggregateInput
    _min?: Factura_EncabezadoMinOrderByAggregateInput
    _sum?: Factura_EncabezadoSumOrderByAggregateInput
  }

  export type Factura_EncabezadoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Factura_EncabezadoScalarWhereWithAggregatesInput>
    OR?: Enumerable<Factura_EncabezadoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Factura_EncabezadoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    numero_tarjeta?: StringNullableWithAggregatesFilter | string | null
    idTipoTarjeta?: IntNullableWithAggregatesFilter | number | null
    fecha?: DateTimeWithAggregatesFilter | Date | string
    estado?: BoolWithAggregatesFilter | boolean
    idUsuario?: StringWithAggregatesFilter | string
  }

  export type Factura_DetalleWhereInput = {
    AND?: Enumerable<Factura_DetalleWhereInput>
    OR?: Enumerable<Factura_DetalleWhereInput>
    NOT?: Enumerable<Factura_DetalleWhereInput>
    id?: IntFilter | number
    cantidad?: IntFilter | number
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFilter | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFilter | Decimal | DecimalJsLike | number | string
    Factura_Encabezado?: XOR<Factura_EncabezadoRelationFilter, Factura_EncabezadoWhereInput>
    idFactura_Encabezado?: IntFilter | number
    Producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    idProducto?: IntFilter | number
  }

  export type Factura_DetalleOrderByWithRelationInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    Factura_Encabezado?: Factura_EncabezadoOrderByWithRelationInput
    idFactura_Encabezado?: SortOrder
    Producto?: ProductoOrderByWithRelationInput
    idProducto?: SortOrder
  }

  export type Factura_DetalleWhereUniqueInput = {
    id_idFactura_Encabezado?: Factura_DetalleIdIdFactura_EncabezadoCompoundUniqueInput
  }

  export type Factura_DetalleOrderByWithAggregationInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
    _count?: Factura_DetalleCountOrderByAggregateInput
    _avg?: Factura_DetalleAvgOrderByAggregateInput
    _max?: Factura_DetalleMaxOrderByAggregateInput
    _min?: Factura_DetalleMinOrderByAggregateInput
    _sum?: Factura_DetalleSumOrderByAggregateInput
  }

  export type Factura_DetalleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Factura_DetalleScalarWhereWithAggregatesInput>
    OR?: Enumerable<Factura_DetalleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Factura_DetalleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    cantidad?: IntWithAggregatesFilter | number
    precio?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: IntWithAggregatesFilter | number
    idProducto?: IntWithAggregatesFilter | number
  }

  export type FacturaEncabezadoTipoPagoWhereInput = {
    AND?: Enumerable<FacturaEncabezadoTipoPagoWhereInput>
    OR?: Enumerable<FacturaEncabezadoTipoPagoWhereInput>
    NOT?: Enumerable<FacturaEncabezadoTipoPagoWhereInput>
    Factura_Encabezado?: XOR<Factura_EncabezadoRelationFilter, Factura_EncabezadoWhereInput>
    idFactura_Encabezado?: IntFilter | number
    TipoPago?: XOR<TipoPagoRelationFilter, TipoPagoWhereInput>
    idTipoPago?: IntFilter | number
    monto?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoOrderByWithRelationInput = {
    Factura_Encabezado?: Factura_EncabezadoOrderByWithRelationInput
    idFactura_Encabezado?: SortOrder
    TipoPago?: TipoPagoOrderByWithRelationInput
    idTipoPago?: SortOrder
    monto?: SortOrder
  }

  export type FacturaEncabezadoTipoPagoWhereUniqueInput = {
    idFactura_Encabezado_idTipoPago?: FacturaEncabezadoTipoPagoIdFactura_EncabezadoIdTipoPagoCompoundUniqueInput
  }

  export type FacturaEncabezadoTipoPagoOrderByWithAggregationInput = {
    idFactura_Encabezado?: SortOrder
    idTipoPago?: SortOrder
    monto?: SortOrder
    _count?: FacturaEncabezadoTipoPagoCountOrderByAggregateInput
    _avg?: FacturaEncabezadoTipoPagoAvgOrderByAggregateInput
    _max?: FacturaEncabezadoTipoPagoMaxOrderByAggregateInput
    _min?: FacturaEncabezadoTipoPagoMinOrderByAggregateInput
    _sum?: FacturaEncabezadoTipoPagoSumOrderByAggregateInput
  }

  export type FacturaEncabezadoTipoPagoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereWithAggregatesInput>
    idFactura_Encabezado?: IntWithAggregatesFilter | number
    idTipoPago?: IntWithAggregatesFilter | number
    monto?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type EstadoPedidoWhereInput = {
    AND?: Enumerable<EstadoPedidoWhereInput>
    OR?: Enumerable<EstadoPedidoWhereInput>
    NOT?: Enumerable<EstadoPedidoWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    pedidos?: PedidoListRelationFilter
  }

  export type EstadoPedidoOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    pedidos?: PedidoOrderByRelationAggregateInput
  }

  export type EstadoPedidoWhereUniqueInput = {
    id?: number
  }

  export type EstadoPedidoOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: EstadoPedidoCountOrderByAggregateInput
    _avg?: EstadoPedidoAvgOrderByAggregateInput
    _max?: EstadoPedidoMaxOrderByAggregateInput
    _min?: EstadoPedidoMinOrderByAggregateInput
    _sum?: EstadoPedidoSumOrderByAggregateInput
  }

  export type EstadoPedidoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EstadoPedidoScalarWhereWithAggregatesInput>
    OR?: Enumerable<EstadoPedidoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EstadoPedidoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type TipoPedidoWhereInput = {
    AND?: Enumerable<TipoPedidoWhereInput>
    OR?: Enumerable<TipoPedidoWhereInput>
    NOT?: Enumerable<TipoPedidoWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    pedidos?: PedidoListRelationFilter
  }

  export type TipoPedidoOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    pedidos?: PedidoOrderByRelationAggregateInput
  }

  export type TipoPedidoWhereUniqueInput = {
    id?: number
  }

  export type TipoPedidoOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    _count?: TipoPedidoCountOrderByAggregateInput
    _avg?: TipoPedidoAvgOrderByAggregateInput
    _max?: TipoPedidoMaxOrderByAggregateInput
    _min?: TipoPedidoMinOrderByAggregateInput
    _sum?: TipoPedidoSumOrderByAggregateInput
  }

  export type TipoPedidoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TipoPedidoScalarWhereWithAggregatesInput>
    OR?: Enumerable<TipoPedidoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TipoPedidoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
  }

  export type PedidoWhereInput = {
    AND?: Enumerable<PedidoWhereInput>
    OR?: Enumerable<PedidoWhereInput>
    NOT?: Enumerable<PedidoWhereInput>
    id?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter | Date | string
    detalles?: Pedido_ProductoListRelationFilter
    EstadoPedido?: XOR<EstadoPedidoRelationFilter, EstadoPedidoWhereInput>
    idEstado?: IntFilter | number
    Cliente?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    idCliente?: StringFilter | string
    Mesero?: XOR<UsuarioRelationFilter, UsuarioWhereInput> | null
    idMesero?: StringNullableFilter | string | null
    Sucursal?: XOR<SucursalRelationFilter, SucursalWhereInput>
    idSucursal?: IntFilter | number
    Mesa?: XOR<MesaRelationFilter, MesaWhereInput> | null
    idMesa?: IntNullableFilter | number | null
    TipoPedido?: XOR<TipoPedidoRelationFilter, TipoPedidoWhereInput>
    idTipoPedido?: IntFilter | number
  }

  export type PedidoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    fecha?: SortOrder
    detalles?: Pedido_ProductoOrderByRelationAggregateInput
    EstadoPedido?: EstadoPedidoOrderByWithRelationInput
    idEstado?: SortOrder
    Cliente?: UsuarioOrderByWithRelationInput
    idCliente?: SortOrder
    Mesero?: UsuarioOrderByWithRelationInput
    idMesero?: SortOrder
    Sucursal?: SucursalOrderByWithRelationInput
    idSucursal?: SortOrder
    Mesa?: MesaOrderByWithRelationInput
    idMesa?: SortOrder
    TipoPedido?: TipoPedidoOrderByWithRelationInput
    idTipoPedido?: SortOrder
  }

  export type PedidoWhereUniqueInput = {
    id?: number
    nombre?: string
  }

  export type PedidoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    fecha?: SortOrder
    idEstado?: SortOrder
    idCliente?: SortOrder
    idMesero?: SortOrder
    idSucursal?: SortOrder
    idMesa?: SortOrder
    idTipoPedido?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    precio?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeWithAggregatesFilter | Date | string
    idEstado?: IntWithAggregatesFilter | number
    idCliente?: StringWithAggregatesFilter | string
    idMesero?: StringNullableWithAggregatesFilter | string | null
    idSucursal?: IntWithAggregatesFilter | number
    idMesa?: IntNullableWithAggregatesFilter | number | null
    idTipoPedido?: IntWithAggregatesFilter | number
  }

  export type Pedido_ProductoWhereInput = {
    AND?: Enumerable<Pedido_ProductoWhereInput>
    OR?: Enumerable<Pedido_ProductoWhereInput>
    NOT?: Enumerable<Pedido_ProductoWhereInput>
    Pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    idPedido?: IntFilter | number
    Producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    idProducto?: IntFilter | number
    cantidad?: IntFilter | number
    notas?: StringFilter | string
  }

  export type Pedido_ProductoOrderByWithRelationInput = {
    Pedido?: PedidoOrderByWithRelationInput
    idPedido?: SortOrder
    Producto?: ProductoOrderByWithRelationInput
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
  }

  export type Pedido_ProductoWhereUniqueInput = {
    idPedido_idProducto?: Pedido_ProductoIdPedidoIdProductoCompoundUniqueInput
  }

  export type Pedido_ProductoOrderByWithAggregationInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
    _count?: Pedido_ProductoCountOrderByAggregateInput
    _avg?: Pedido_ProductoAvgOrderByAggregateInput
    _max?: Pedido_ProductoMaxOrderByAggregateInput
    _min?: Pedido_ProductoMinOrderByAggregateInput
    _sum?: Pedido_ProductoSumOrderByAggregateInput
  }

  export type Pedido_ProductoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Pedido_ProductoScalarWhereWithAggregatesInput>
    OR?: Enumerable<Pedido_ProductoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Pedido_ProductoScalarWhereWithAggregatesInput>
    idPedido?: IntWithAggregatesFilter | number
    idProducto?: IntWithAggregatesFilter | number
    cantidad?: IntWithAggregatesFilter | number
    notas?: StringWithAggregatesFilter | string
  }

  export type PerfilCreateInput = {
    id: number
    descripcion: string
    usuarios?: UsuarioCreateNestedManyWithoutPerfilInput
  }

  export type PerfilUncheckedCreateInput = {
    id: number
    descripcion: string
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutPerfilInput
  }

  export type PerfilUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarios?: UsuarioUpdateManyWithoutPerfilNestedInput
  }

  export type PerfilUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarios?: UsuarioUncheckedUpdateManyWithoutPerfilNestedInput
  }

  export type PerfilCreateManyInput = {
    id: number
    descripcion: string
  }

  export type PerfilUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PerfilUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
    encargos?: PedidoCreateNestedManyWithoutMeseroInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
    sucursales?: SucursalCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioUncheckedCreateInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
    encargos?: PedidoUncheckedCreateNestedManyWithoutMeseroInput
    idPerfil: number
    sucursales?: SucursalUncheckedCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUpdateManyWithoutMeseroNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
    sucursales?: SucursalUpdateManyWithoutMeserosNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUncheckedUpdateManyWithoutMeseroNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
    sucursales?: SucursalUncheckedUpdateManyWithoutMeserosNestedInput
  }

  export type UsuarioCreateManyInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    idPerfil: number
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    idPerfil?: IntFieldUpdateOperationsInput | number
  }

  export type SucursalCreateInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionCreateNestedManyWithoutSucursalInput
    productos?: ProductoCreateNestedManyWithoutSucursalesInput
    meseros?: UsuarioCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaUncheckedCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutSucursalInput
    productos?: ProductoUncheckedCreateNestedManyWithoutSucursalesInput
    meseros?: UsuarioUncheckedCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUpdateManyWithoutSucursalesNestedInput
    meseros?: UsuarioUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUncheckedUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUncheckedUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutSucursalesNestedInput
    meseros?: UsuarioUncheckedUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalCreateManyInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
  }

  export type SucursalUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
  }

  export type SucursalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
  }

  export type MesaCreateInput = {
    codigo: string
    capacidad: number
    estado?: boolean
    reservaciones?: ReservacionCreateNestedManyWithoutMesasInput
    pedidos?: PedidoCreateNestedManyWithoutMesaInput
    Sucursal: SucursalCreateNestedOneWithoutMesasInput
    EstadoMesa?: DisponibilidadMesaCreateNestedOneWithoutMesasInput
  }

  export type MesaUncheckedCreateInput = {
    id?: number
    codigo: string
    capacidad: number
    estado?: boolean
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutMesasInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutMesaInput
    idSucursal: number
    idDisponibilidad?: number
  }

  export type MesaUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: ReservacionUpdateManyWithoutMesasNestedInput
    pedidos?: PedidoUpdateManyWithoutMesaNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutMesasNestedInput
    EstadoMesa?: DisponibilidadMesaUpdateOneRequiredWithoutMesasNestedInput
  }

  export type MesaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: ReservacionUncheckedUpdateManyWithoutMesasNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutMesaNestedInput
    idSucursal?: IntFieldUpdateOperationsInput | number
    idDisponibilidad?: IntFieldUpdateOperationsInput | number
  }

  export type MesaCreateManyInput = {
    id?: number
    codigo: string
    capacidad: number
    estado?: boolean
    idSucursal: number
    idDisponibilidad?: number
  }

  export type MesaUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MesaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    idSucursal?: IntFieldUpdateOperationsInput | number
    idDisponibilidad?: IntFieldUpdateOperationsInput | number
  }

  export type DisponibilidadMesaCreateInput = {
    id: number
    descripcion: string
    mesas?: MesaCreateNestedManyWithoutEstadoMesaInput
  }

  export type DisponibilidadMesaUncheckedCreateInput = {
    id: number
    descripcion: string
    mesas?: MesaUncheckedCreateNestedManyWithoutEstadoMesaInput
  }

  export type DisponibilidadMesaUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    mesas?: MesaUpdateManyWithoutEstadoMesaNestedInput
  }

  export type DisponibilidadMesaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    mesas?: MesaUncheckedUpdateManyWithoutEstadoMesaNestedInput
  }

  export type DisponibilidadMesaCreateManyInput = {
    id: number
    descripcion: string
  }

  export type DisponibilidadMesaUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type DisponibilidadMesaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type ReservacionCreateInput = {
    fecha_hora?: Date | string
    cantidad: number
    mesas?: MesaCreateNestedManyWithoutReservacionesInput
    Sucursal: SucursalCreateNestedOneWithoutReservacionesInput
    Usuario: UsuarioCreateNestedOneWithoutReservacionesInput
  }

  export type ReservacionUncheckedCreateInput = {
    id?: number
    fecha_hora?: Date | string
    cantidad: number
    mesas?: MesaUncheckedCreateNestedManyWithoutReservacionesInput
    idSucursal: number
    idUsuario: string
  }

  export type ReservacionUpdateInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUpdateManyWithoutReservacionesNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutReservacionesNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReservacionesNestedInput
  }

  export type ReservacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUncheckedUpdateManyWithoutReservacionesNestedInput
    idSucursal?: IntFieldUpdateOperationsInput | number
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type ReservacionCreateManyInput = {
    id?: number
    fecha_hora?: Date | string
    cantidad: number
    idSucursal: number
    idUsuario: string
  }

  export type ReservacionUpdateManyMutationInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type ReservacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    idSucursal?: IntFieldUpdateOperationsInput | number
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type Categoria_ProductoCreateInput = {
    id: number
    descripcion: string
    productos?: ProductoCreateNestedManyWithoutCategoria_ProductoInput
  }

  export type Categoria_ProductoUncheckedCreateInput = {
    id: number
    descripcion: string
    productos?: ProductoUncheckedCreateNestedManyWithoutCategoria_ProductoInput
  }

  export type Categoria_ProductoUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUpdateManyWithoutCategoria_ProductoNestedInput
  }

  export type Categoria_ProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUncheckedUpdateManyWithoutCategoria_ProductoNestedInput
  }

  export type Categoria_ProductoCreateManyInput = {
    id: number
    descripcion: string
  }

  export type Categoria_ProductoUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Categoria_ProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoCreateInput = {
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    Categoria_Producto: Categoria_ProductoCreateNestedOneWithoutProductosInput
    detalles?: Factura_DetalleCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoCreateNestedManyWithoutProductoInput
    sucursales?: SucursalCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    idCategoria: number
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput
    sucursales?: SucursalUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Categoria_Producto?: Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput
    detalles?: Factura_DetalleUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUpdateManyWithoutProductoNestedInput
    sucursales?: SucursalUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput
    sucursales?: SucursalUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type ProductoCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    idCategoria: number
  }

  export type ProductoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
  }

  export type TipoPagoCreateInput = {
    id: number
    descripcion: string
    facturasEncabezado?: FacturaEncabezadoTipoPagoCreateNestedManyWithoutTipoPagoInput
  }

  export type TipoPagoUncheckedCreateInput = {
    id: number
    descripcion: string
    facturasEncabezado?: FacturaEncabezadoTipoPagoUncheckedCreateNestedManyWithoutTipoPagoInput
  }

  export type TipoPagoUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    facturasEncabezado?: FacturaEncabezadoTipoPagoUpdateManyWithoutTipoPagoNestedInput
  }

  export type TipoPagoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    facturasEncabezado?: FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutTipoPagoNestedInput
  }

  export type TipoPagoCreateManyInput = {
    id: number
    descripcion: string
  }

  export type TipoPagoUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoPagoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoTarjetaCreateInput = {
    id: number
    descripcion: string
    facturas?: Factura_EncabezadoCreateNestedManyWithoutTipoTarjetaInput
  }

  export type TipoTarjetaUncheckedCreateInput = {
    id: number
    descripcion: string
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutTipoTarjetaInput
  }

  export type TipoTarjetaUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    facturas?: Factura_EncabezadoUpdateManyWithoutTipoTarjetaNestedInput
  }

  export type TipoTarjetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutTipoTarjetaNestedInput
  }

  export type TipoTarjetaCreateManyInput = {
    id: number
    descripcion: string
  }

  export type TipoTarjetaUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoTarjetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_EncabezadoCreateInput = {
    numero_tarjeta?: string | null
    TipoTarjeta?: TipoTarjetaCreateNestedOneWithoutFacturasInput
    fecha?: Date | string
    estado?: boolean
    detalles?: Factura_DetalleCreateNestedManyWithoutFactura_EncabezadoInput
    tipoPagos?: FacturaEncabezadoTipoPagoCreateNestedManyWithoutFactura_EncabezadoInput
    Usuario: UsuarioCreateNestedOneWithoutFacturasInput
  }

  export type Factura_EncabezadoUncheckedCreateInput = {
    id?: number
    numero_tarjeta?: string | null
    idTipoTarjeta?: number | null
    fecha?: Date | string
    estado?: boolean
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    tipoPagos?: FacturaEncabezadoTipoPagoUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    idUsuario: string
  }

  export type Factura_EncabezadoUpdateInput = {
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    TipoTarjeta?: TipoTarjetaUpdateOneWithoutFacturasNestedInput
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUpdateManyWithoutFactura_EncabezadoNestedInput
    tipoPagos?: FacturaEncabezadoTipoPagoUpdateManyWithoutFactura_EncabezadoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    idTipoTarjeta?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    tipoPagos?: FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_EncabezadoCreateManyInput = {
    id?: number
    numero_tarjeta?: string | null
    idTipoTarjeta?: number | null
    fecha?: Date | string
    estado?: boolean
    idUsuario: string
  }

  export type Factura_EncabezadoUpdateManyMutationInput = {
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Factura_EncabezadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    idTipoTarjeta?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_DetalleCreateInput = {
    id?: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    Factura_Encabezado: Factura_EncabezadoCreateNestedOneWithoutDetallesInput
    Producto: ProductoCreateNestedOneWithoutDetallesInput
  }

  export type Factura_DetalleUncheckedCreateInput = {
    id?: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idFactura_Encabezado: number
    idProducto: number
  }

  export type Factura_DetalleUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Factura_Encabezado?: Factura_EncabezadoUpdateOneRequiredWithoutDetallesNestedInput
    Producto?: ProductoUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type Factura_DetalleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
  }

  export type Factura_DetalleCreateManyInput = {
    id?: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idFactura_Encabezado: number
    idProducto: number
  }

  export type Factura_DetalleUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type Factura_DetalleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
  }

  export type FacturaEncabezadoTipoPagoCreateInput = {
    Factura_Encabezado: Factura_EncabezadoCreateNestedOneWithoutTipoPagosInput
    TipoPago: TipoPagoCreateNestedOneWithoutFacturasEncabezadoInput
    monto: Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUncheckedCreateInput = {
    idFactura_Encabezado: number
    idTipoPago: number
    monto: Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUpdateInput = {
    Factura_Encabezado?: Factura_EncabezadoUpdateOneRequiredWithoutTipoPagosNestedInput
    TipoPago?: TipoPagoUpdateOneRequiredWithoutFacturasEncabezadoNestedInput
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUncheckedUpdateInput = {
    idFactura_Encabezado?: IntFieldUpdateOperationsInput | number
    idTipoPago?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoCreateManyInput = {
    idFactura_Encabezado: number
    idTipoPago: number
    monto: Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUpdateManyMutationInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUncheckedUpdateManyInput = {
    idFactura_Encabezado?: IntFieldUpdateOperationsInput | number
    idTipoPago?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type EstadoPedidoCreateInput = {
    id: number
    descripcion: string
    pedidos?: PedidoCreateNestedManyWithoutEstadoPedidoInput
  }

  export type EstadoPedidoUncheckedCreateInput = {
    id: number
    descripcion: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutEstadoPedidoInput
  }

  export type EstadoPedidoUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutEstadoPedidoNestedInput
  }

  export type EstadoPedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutEstadoPedidoNestedInput
  }

  export type EstadoPedidoCreateManyInput = {
    id: number
    descripcion: string
  }

  export type EstadoPedidoUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoPedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoPedidoCreateInput = {
    id: number
    descripcion: string
    pedidos?: PedidoCreateNestedManyWithoutTipoPedidoInput
  }

  export type TipoPedidoUncheckedCreateInput = {
    id: number
    descripcion: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutTipoPedidoInput
  }

  export type TipoPedidoUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutTipoPedidoNestedInput
  }

  export type TipoPedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutTipoPedidoNestedInput
  }

  export type TipoPedidoCreateManyInput = {
    id: number
    descripcion: string
  }

  export type TipoPedidoUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoPedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoCreateInput = {
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoCreateNestedManyWithoutPedidoInput
    EstadoPedido: EstadoPedidoCreateNestedOneWithoutPedidosInput
    Cliente: UsuarioCreateNestedOneWithoutPedidosInput
    Mesero?: UsuarioCreateNestedOneWithoutEncargosInput
    Sucursal: SucursalCreateNestedOneWithoutPedidosInput
    Mesa?: MesaCreateNestedOneWithoutPedidosInput
    TipoPedido: TipoPedidoCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput
    idEstado: number
    idCliente: string
    idMesero?: string | null
    idSucursal: number
    idMesa?: number | null
    idTipoPedido: number
  }

  export type PedidoUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUpdateManyWithoutPedidoNestedInput
    EstadoPedido?: EstadoPedidoUpdateOneRequiredWithoutPedidosNestedInput
    Cliente?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    Mesero?: UsuarioUpdateOneWithoutEncargosNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutPedidosNestedInput
    Mesa?: MesaUpdateOneWithoutPedidosNestedInput
    TipoPedido?: TipoPedidoUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput
    idEstado?: IntFieldUpdateOperationsInput | number
    idCliente?: StringFieldUpdateOperationsInput | string
    idMesero?: NullableStringFieldUpdateOperationsInput | string | null
    idSucursal?: IntFieldUpdateOperationsInput | number
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoCreateManyInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    idEstado: number
    idCliente: string
    idMesero?: string | null
    idSucursal: number
    idMesa?: number | null
    idTipoPedido: number
  }

  export type PedidoUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    idCliente?: StringFieldUpdateOperationsInput | string
    idMesero?: NullableStringFieldUpdateOperationsInput | string | null
    idSucursal?: IntFieldUpdateOperationsInput | number
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type Pedido_ProductoCreateInput = {
    Pedido: PedidoCreateNestedOneWithoutDetallesInput
    Producto: ProductoCreateNestedOneWithoutPedidosInput
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUncheckedCreateInput = {
    idPedido: number
    idProducto: number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUpdateInput = {
    Pedido?: PedidoUpdateOneRequiredWithoutDetallesNestedInput
    Producto?: ProductoUpdateOneRequiredWithoutPedidosNestedInput
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateInput = {
    idPedido?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoCreateManyInput = {
    idPedido: number
    idProducto: number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateManyInput = {
    idPedido?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerfilCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type PerfilAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PerfilMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type PerfilMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type PerfilSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type ReservacionListRelationFilter = {
    every?: ReservacionWhereInput
    some?: ReservacionWhereInput
    none?: ReservacionWhereInput
  }

  export type Factura_EncabezadoListRelationFilter = {
    every?: Factura_EncabezadoWhereInput
    some?: Factura_EncabezadoWhereInput
    none?: Factura_EncabezadoWhereInput
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type PerfilRelationFilter = {
    is?: PerfilWhereInput
    isNot?: PerfilWhereInput
  }

  export type SucursalListRelationFilter = {
    every?: SucursalWhereInput
    some?: SucursalWhereInput
    none?: SucursalWhereInput
  }

  export type ReservacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Factura_EncabezadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SucursalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCorreoUsernameTelefonoCompoundUniqueInput = {
    correo: string
    username: string
    telefono: string
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    idPerfil?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    idPerfil?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    idPerfil?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido1?: SortOrder
    apellido2?: SortOrder
    correo?: SortOrder
    username?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    idPerfil?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    idPerfil?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type MesaListRelationFilter = {
    every?: MesaWhereInput
    some?: MesaWhereInput
    none?: MesaWhereInput
  }

  export type ProductoListRelationFilter = {
    every?: ProductoWhereInput
    some?: ProductoWhereInput
    none?: ProductoWhereInput
  }

  export type MesaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SucursalCodigoNombreCompoundUniqueInput = {
    codigo: string
    nombre: string
  }

  export type SucursalCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
  }

  export type SucursalAvgOrderByAggregateInput = {
    id?: SortOrder
    capacidad?: SortOrder
  }

  export type SucursalMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
  }

  export type SucursalMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    capacidad?: SortOrder
  }

  export type SucursalSumOrderByAggregateInput = {
    id?: SortOrder
    capacidad?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type SucursalRelationFilter = {
    is?: SucursalWhereInput
    isNot?: SucursalWhereInput
  }

  export type DisponibilidadMesaRelationFilter = {
    is?: DisponibilidadMesaWhereInput
    isNot?: DisponibilidadMesaWhereInput
  }

  export type MesaCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    idSucursal?: SortOrder
    idDisponibilidad?: SortOrder
  }

  export type MesaAvgOrderByAggregateInput = {
    id?: SortOrder
    capacidad?: SortOrder
    idSucursal?: SortOrder
    idDisponibilidad?: SortOrder
  }

  export type MesaMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    idSucursal?: SortOrder
    idDisponibilidad?: SortOrder
  }

  export type MesaMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    idSucursal?: SortOrder
    idDisponibilidad?: SortOrder
  }

  export type MesaSumOrderByAggregateInput = {
    id?: SortOrder
    capacidad?: SortOrder
    idSucursal?: SortOrder
    idDisponibilidad?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DisponibilidadMesaCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type DisponibilidadMesaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DisponibilidadMesaMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type DisponibilidadMesaMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type DisponibilidadMesaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type ReservacionCountOrderByAggregateInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    cantidad?: SortOrder
    idSucursal?: SortOrder
    idUsuario?: SortOrder
  }

  export type ReservacionAvgOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    idSucursal?: SortOrder
  }

  export type ReservacionMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    cantidad?: SortOrder
    idSucursal?: SortOrder
    idUsuario?: SortOrder
  }

  export type ReservacionMinOrderByAggregateInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    cantidad?: SortOrder
    idSucursal?: SortOrder
    idUsuario?: SortOrder
  }

  export type ReservacionSumOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    idSucursal?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type Categoria_ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type Categoria_ProductoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Categoria_ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type Categoria_ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type Categoria_ProductoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type Categoria_ProductoRelationFilter = {
    is?: Categoria_ProductoWhereInput
    isNot?: Categoria_ProductoWhereInput
  }

  export type Factura_DetalleListRelationFilter = {
    every?: Factura_DetalleWhereInput
    some?: Factura_DetalleWhereInput
    none?: Factura_DetalleWhereInput
  }

  export type Pedido_ProductoListRelationFilter = {
    every?: Pedido_ProductoWhereInput
    some?: Pedido_ProductoWhereInput
    none?: Pedido_ProductoWhereInput
  }

  export type Factura_DetalleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Pedido_ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
  }

  export type ProductoAvgOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    idCategoria?: SortOrder
  }

  export type ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
  }

  export type ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    ingredientes?: SortOrder
    precio?: SortOrder
    imagen?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
  }

  export type ProductoSumOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    idCategoria?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type FacturaEncabezadoTipoPagoListRelationFilter = {
    every?: FacturaEncabezadoTipoPagoWhereInput
    some?: FacturaEncabezadoTipoPagoWhereInput
    none?: FacturaEncabezadoTipoPagoWhereInput
  }

  export type FacturaEncabezadoTipoPagoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoPagoCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoPagoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoPagoMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoPagoMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoPagoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoTarjetaCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoTarjetaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoTarjetaMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoTarjetaMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoTarjetaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoTarjetaRelationFilter = {
    is?: TipoTarjetaWhereInput | null
    isNot?: TipoTarjetaWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type Factura_EncabezadoCountOrderByAggregateInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    idTipoTarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    idUsuario?: SortOrder
  }

  export type Factura_EncabezadoAvgOrderByAggregateInput = {
    id?: SortOrder
    idTipoTarjeta?: SortOrder
  }

  export type Factura_EncabezadoMaxOrderByAggregateInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    idTipoTarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    idUsuario?: SortOrder
  }

  export type Factura_EncabezadoMinOrderByAggregateInput = {
    id?: SortOrder
    numero_tarjeta?: SortOrder
    idTipoTarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    idUsuario?: SortOrder
  }

  export type Factura_EncabezadoSumOrderByAggregateInput = {
    id?: SortOrder
    idTipoTarjeta?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type Factura_EncabezadoRelationFilter = {
    is?: Factura_EncabezadoWhereInput
    isNot?: Factura_EncabezadoWhereInput
  }

  export type ProductoRelationFilter = {
    is?: ProductoWhereInput
    isNot?: ProductoWhereInput
  }

  export type Factura_DetalleIdIdFactura_EncabezadoCompoundUniqueInput = {
    id: number
    idFactura_Encabezado: number
  }

  export type Factura_DetalleCountOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type Factura_DetalleAvgOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type Factura_DetalleMaxOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type Factura_DetalleMinOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type Factura_DetalleSumOrderByAggregateInput = {
    id?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    impuesto?: SortOrder
    total_detalle?: SortOrder
    idFactura_Encabezado?: SortOrder
    idProducto?: SortOrder
  }

  export type TipoPagoRelationFilter = {
    is?: TipoPagoWhereInput
    isNot?: TipoPagoWhereInput
  }

  export type FacturaEncabezadoTipoPagoIdFactura_EncabezadoIdTipoPagoCompoundUniqueInput = {
    idFactura_Encabezado: number
    idTipoPago: number
  }

  export type FacturaEncabezadoTipoPagoCountOrderByAggregateInput = {
    idFactura_Encabezado?: SortOrder
    idTipoPago?: SortOrder
    monto?: SortOrder
  }

  export type FacturaEncabezadoTipoPagoAvgOrderByAggregateInput = {
    idFactura_Encabezado?: SortOrder
    idTipoPago?: SortOrder
    monto?: SortOrder
  }

  export type FacturaEncabezadoTipoPagoMaxOrderByAggregateInput = {
    idFactura_Encabezado?: SortOrder
    idTipoPago?: SortOrder
    monto?: SortOrder
  }

  export type FacturaEncabezadoTipoPagoMinOrderByAggregateInput = {
    idFactura_Encabezado?: SortOrder
    idTipoPago?: SortOrder
    monto?: SortOrder
  }

  export type FacturaEncabezadoTipoPagoSumOrderByAggregateInput = {
    idFactura_Encabezado?: SortOrder
    idTipoPago?: SortOrder
    monto?: SortOrder
  }

  export type EstadoPedidoCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type EstadoPedidoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EstadoPedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type EstadoPedidoMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type EstadoPedidoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoPedidoCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoPedidoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoPedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoPedidoMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoPedidoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EstadoPedidoRelationFilter = {
    is?: EstadoPedidoWhereInput
    isNot?: EstadoPedidoWhereInput
  }

  export type MesaRelationFilter = {
    is?: MesaWhereInput | null
    isNot?: MesaWhereInput | null
  }

  export type TipoPedidoRelationFilter = {
    is?: TipoPedidoWhereInput
    isNot?: TipoPedidoWhereInput
  }

  export type PedidoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    fecha?: SortOrder
    idEstado?: SortOrder
    idCliente?: SortOrder
    idMesero?: SortOrder
    idSucursal?: SortOrder
    idMesa?: SortOrder
    idTipoPedido?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    idEstado?: SortOrder
    idSucursal?: SortOrder
    idMesa?: SortOrder
    idTipoPedido?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    fecha?: SortOrder
    idEstado?: SortOrder
    idCliente?: SortOrder
    idMesero?: SortOrder
    idSucursal?: SortOrder
    idMesa?: SortOrder
    idTipoPedido?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    fecha?: SortOrder
    idEstado?: SortOrder
    idCliente?: SortOrder
    idMesero?: SortOrder
    idSucursal?: SortOrder
    idMesa?: SortOrder
    idTipoPedido?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    idEstado?: SortOrder
    idSucursal?: SortOrder
    idMesa?: SortOrder
    idTipoPedido?: SortOrder
  }

  export type PedidoRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type Pedido_ProductoIdPedidoIdProductoCompoundUniqueInput = {
    idPedido: number
    idProducto: number
  }

  export type Pedido_ProductoCountOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
  }

  export type Pedido_ProductoAvgOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
  }

  export type Pedido_ProductoMaxOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
  }

  export type Pedido_ProductoMinOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
    notas?: SortOrder
  }

  export type Pedido_ProductoSumOrderByAggregateInput = {
    idPedido?: SortOrder
    idProducto?: SortOrder
    cantidad?: SortOrder
  }

  export type UsuarioCreateNestedManyWithoutPerfilInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutPerfilInput>, Enumerable<UsuarioUncheckedCreateWithoutPerfilInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutPerfilInput>
    createMany?: UsuarioCreateManyPerfilInputEnvelope
    connect?: Enumerable<UsuarioWhereUniqueInput>
  }

  export type UsuarioUncheckedCreateNestedManyWithoutPerfilInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutPerfilInput>, Enumerable<UsuarioUncheckedCreateWithoutPerfilInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutPerfilInput>
    createMany?: UsuarioCreateManyPerfilInputEnvelope
    connect?: Enumerable<UsuarioWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UsuarioUpdateManyWithoutPerfilNestedInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutPerfilInput>, Enumerable<UsuarioUncheckedCreateWithoutPerfilInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutPerfilInput>
    upsert?: Enumerable<UsuarioUpsertWithWhereUniqueWithoutPerfilInput>
    createMany?: UsuarioCreateManyPerfilInputEnvelope
    set?: Enumerable<UsuarioWhereUniqueInput>
    disconnect?: Enumerable<UsuarioWhereUniqueInput>
    delete?: Enumerable<UsuarioWhereUniqueInput>
    connect?: Enumerable<UsuarioWhereUniqueInput>
    update?: Enumerable<UsuarioUpdateWithWhereUniqueWithoutPerfilInput>
    updateMany?: Enumerable<UsuarioUpdateManyWithWhereWithoutPerfilInput>
    deleteMany?: Enumerable<UsuarioScalarWhereInput>
  }

  export type UsuarioUncheckedUpdateManyWithoutPerfilNestedInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutPerfilInput>, Enumerable<UsuarioUncheckedCreateWithoutPerfilInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutPerfilInput>
    upsert?: Enumerable<UsuarioUpsertWithWhereUniqueWithoutPerfilInput>
    createMany?: UsuarioCreateManyPerfilInputEnvelope
    set?: Enumerable<UsuarioWhereUniqueInput>
    disconnect?: Enumerable<UsuarioWhereUniqueInput>
    delete?: Enumerable<UsuarioWhereUniqueInput>
    connect?: Enumerable<UsuarioWhereUniqueInput>
    update?: Enumerable<UsuarioUpdateWithWhereUniqueWithoutPerfilInput>
    updateMany?: Enumerable<UsuarioUpdateManyWithWhereWithoutPerfilInput>
    deleteMany?: Enumerable<UsuarioScalarWhereInput>
  }

  export type ReservacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutUsuarioInput>, Enumerable<ReservacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutUsuarioInput>
    createMany?: ReservacionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type Factura_EncabezadoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutUsuarioInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutUsuarioInput>
    createMany?: Factura_EncabezadoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
  }

  export type PedidoCreateNestedManyWithoutClienteInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutClienteInput>, Enumerable<PedidoUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutClienteInput>
    createMany?: PedidoCreateManyClienteInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PedidoCreateNestedManyWithoutMeseroInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMeseroInput>, Enumerable<PedidoUncheckedCreateWithoutMeseroInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMeseroInput>
    createMany?: PedidoCreateManyMeseroInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PerfilCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<PerfilCreateWithoutUsuariosInput, PerfilUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: PerfilCreateOrConnectWithoutUsuariosInput
    connect?: PerfilWhereUniqueInput
  }

  export type SucursalCreateNestedManyWithoutMeserosInput = {
    create?: XOR<Enumerable<SucursalCreateWithoutMeserosInput>, Enumerable<SucursalUncheckedCreateWithoutMeserosInput>>
    connectOrCreate?: Enumerable<SucursalCreateOrConnectWithoutMeserosInput>
    connect?: Enumerable<SucursalWhereUniqueInput>
  }

  export type ReservacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutUsuarioInput>, Enumerable<ReservacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutUsuarioInput>
    createMany?: ReservacionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutUsuarioInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutUsuarioInput>
    createMany?: Factura_EncabezadoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutClienteInput>, Enumerable<PedidoUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutClienteInput>
    createMany?: PedidoCreateManyClienteInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutMeseroInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMeseroInput>, Enumerable<PedidoUncheckedCreateWithoutMeseroInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMeseroInput>
    createMany?: PedidoCreateManyMeseroInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type SucursalUncheckedCreateNestedManyWithoutMeserosInput = {
    create?: XOR<Enumerable<SucursalCreateWithoutMeserosInput>, Enumerable<SucursalUncheckedCreateWithoutMeserosInput>>
    connectOrCreate?: Enumerable<SucursalCreateOrConnectWithoutMeserosInput>
    connect?: Enumerable<SucursalWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ReservacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutUsuarioInput>, Enumerable<ReservacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: ReservacionCreateManyUsuarioInputEnvelope
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutUsuarioInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<Factura_EncabezadoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: Factura_EncabezadoCreateManyUsuarioInputEnvelope
    set?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    disconnect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    delete?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    update?: Enumerable<Factura_EncabezadoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<Factura_EncabezadoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<Factura_EncabezadoScalarWhereInput>
  }

  export type PedidoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutClienteInput>, Enumerable<PedidoUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutClienteInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutClienteInput>
    createMany?: PedidoCreateManyClienteInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutClienteInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutClienteInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type PedidoUpdateManyWithoutMeseroNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMeseroInput>, Enumerable<PedidoUncheckedCreateWithoutMeseroInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMeseroInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutMeseroInput>
    createMany?: PedidoCreateManyMeseroInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutMeseroInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutMeseroInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type PerfilUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<PerfilCreateWithoutUsuariosInput, PerfilUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: PerfilCreateOrConnectWithoutUsuariosInput
    upsert?: PerfilUpsertWithoutUsuariosInput
    connect?: PerfilWhereUniqueInput
    update?: XOR<PerfilUpdateWithoutUsuariosInput, PerfilUncheckedUpdateWithoutUsuariosInput>
  }

  export type SucursalUpdateManyWithoutMeserosNestedInput = {
    create?: XOR<Enumerable<SucursalCreateWithoutMeserosInput>, Enumerable<SucursalUncheckedCreateWithoutMeserosInput>>
    connectOrCreate?: Enumerable<SucursalCreateOrConnectWithoutMeserosInput>
    upsert?: Enumerable<SucursalUpsertWithWhereUniqueWithoutMeserosInput>
    set?: Enumerable<SucursalWhereUniqueInput>
    disconnect?: Enumerable<SucursalWhereUniqueInput>
    delete?: Enumerable<SucursalWhereUniqueInput>
    connect?: Enumerable<SucursalWhereUniqueInput>
    update?: Enumerable<SucursalUpdateWithWhereUniqueWithoutMeserosInput>
    updateMany?: Enumerable<SucursalUpdateManyWithWhereWithoutMeserosInput>
    deleteMany?: Enumerable<SucursalScalarWhereInput>
  }

  export type ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutUsuarioInput>, Enumerable<ReservacionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: ReservacionCreateManyUsuarioInputEnvelope
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutUsuarioInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<Factura_EncabezadoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: Factura_EncabezadoCreateManyUsuarioInputEnvelope
    set?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    disconnect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    delete?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    update?: Enumerable<Factura_EncabezadoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<Factura_EncabezadoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<Factura_EncabezadoScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutClienteInput>, Enumerable<PedidoUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutClienteInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutClienteInput>
    createMany?: PedidoCreateManyClienteInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutClienteInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutClienteInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutMeseroNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMeseroInput>, Enumerable<PedidoUncheckedCreateWithoutMeseroInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMeseroInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutMeseroInput>
    createMany?: PedidoCreateManyMeseroInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutMeseroInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutMeseroInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type SucursalUncheckedUpdateManyWithoutMeserosNestedInput = {
    create?: XOR<Enumerable<SucursalCreateWithoutMeserosInput>, Enumerable<SucursalUncheckedCreateWithoutMeserosInput>>
    connectOrCreate?: Enumerable<SucursalCreateOrConnectWithoutMeserosInput>
    upsert?: Enumerable<SucursalUpsertWithWhereUniqueWithoutMeserosInput>
    set?: Enumerable<SucursalWhereUniqueInput>
    disconnect?: Enumerable<SucursalWhereUniqueInput>
    delete?: Enumerable<SucursalWhereUniqueInput>
    connect?: Enumerable<SucursalWhereUniqueInput>
    update?: Enumerable<SucursalUpdateWithWhereUniqueWithoutMeserosInput>
    updateMany?: Enumerable<SucursalUpdateManyWithWhereWithoutMeserosInput>
    deleteMany?: Enumerable<SucursalScalarWhereInput>
  }

  export type MesaCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<MesaCreateWithoutSucursalInput>, Enumerable<MesaUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutSucursalInput>
    createMany?: MesaCreateManySucursalInputEnvelope
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type ReservacionCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutSucursalInput>, Enumerable<ReservacionUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutSucursalInput>
    createMany?: ReservacionCreateManySucursalInputEnvelope
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type ProductoCreateNestedManyWithoutSucursalesInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutSucursalesInput>, Enumerable<ProductoUncheckedCreateWithoutSucursalesInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutSucursalesInput>
    connect?: Enumerable<ProductoWhereUniqueInput>
  }

  export type UsuarioCreateNestedManyWithoutSucursalesInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutSucursalesInput>, Enumerable<UsuarioUncheckedCreateWithoutSucursalesInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutSucursalesInput>
    connect?: Enumerable<UsuarioWhereUniqueInput>
  }

  export type PedidoCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutSucursalInput>, Enumerable<PedidoUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutSucursalInput>
    createMany?: PedidoCreateManySucursalInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type MesaUncheckedCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<MesaCreateWithoutSucursalInput>, Enumerable<MesaUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutSucursalInput>
    createMany?: MesaCreateManySucursalInputEnvelope
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type ReservacionUncheckedCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutSucursalInput>, Enumerable<ReservacionUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutSucursalInput>
    createMany?: ReservacionCreateManySucursalInputEnvelope
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type ProductoUncheckedCreateNestedManyWithoutSucursalesInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutSucursalesInput>, Enumerable<ProductoUncheckedCreateWithoutSucursalesInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutSucursalesInput>
    connect?: Enumerable<ProductoWhereUniqueInput>
  }

  export type UsuarioUncheckedCreateNestedManyWithoutSucursalesInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutSucursalesInput>, Enumerable<UsuarioUncheckedCreateWithoutSucursalesInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutSucursalesInput>
    connect?: Enumerable<UsuarioWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutSucursalInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutSucursalInput>, Enumerable<PedidoUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutSucursalInput>
    createMany?: PedidoCreateManySucursalInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type MesaUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutSucursalInput>, Enumerable<MesaUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: MesaCreateManySucursalInputEnvelope
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type ReservacionUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutSucursalInput>, Enumerable<ReservacionUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: ReservacionCreateManySucursalInputEnvelope
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type ProductoUpdateManyWithoutSucursalesNestedInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutSucursalesInput>, Enumerable<ProductoUncheckedCreateWithoutSucursalesInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutSucursalesInput>
    upsert?: Enumerable<ProductoUpsertWithWhereUniqueWithoutSucursalesInput>
    set?: Enumerable<ProductoWhereUniqueInput>
    disconnect?: Enumerable<ProductoWhereUniqueInput>
    delete?: Enumerable<ProductoWhereUniqueInput>
    connect?: Enumerable<ProductoWhereUniqueInput>
    update?: Enumerable<ProductoUpdateWithWhereUniqueWithoutSucursalesInput>
    updateMany?: Enumerable<ProductoUpdateManyWithWhereWithoutSucursalesInput>
    deleteMany?: Enumerable<ProductoScalarWhereInput>
  }

  export type UsuarioUpdateManyWithoutSucursalesNestedInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutSucursalesInput>, Enumerable<UsuarioUncheckedCreateWithoutSucursalesInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutSucursalesInput>
    upsert?: Enumerable<UsuarioUpsertWithWhereUniqueWithoutSucursalesInput>
    set?: Enumerable<UsuarioWhereUniqueInput>
    disconnect?: Enumerable<UsuarioWhereUniqueInput>
    delete?: Enumerable<UsuarioWhereUniqueInput>
    connect?: Enumerable<UsuarioWhereUniqueInput>
    update?: Enumerable<UsuarioUpdateWithWhereUniqueWithoutSucursalesInput>
    updateMany?: Enumerable<UsuarioUpdateManyWithWhereWithoutSucursalesInput>
    deleteMany?: Enumerable<UsuarioScalarWhereInput>
  }

  export type PedidoUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutSucursalInput>, Enumerable<PedidoUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: PedidoCreateManySucursalInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type MesaUncheckedUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutSucursalInput>, Enumerable<MesaUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: MesaCreateManySucursalInputEnvelope
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type ReservacionUncheckedUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutSucursalInput>, Enumerable<ReservacionUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: ReservacionCreateManySucursalInputEnvelope
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type ProductoUncheckedUpdateManyWithoutSucursalesNestedInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutSucursalesInput>, Enumerable<ProductoUncheckedCreateWithoutSucursalesInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutSucursalesInput>
    upsert?: Enumerable<ProductoUpsertWithWhereUniqueWithoutSucursalesInput>
    set?: Enumerable<ProductoWhereUniqueInput>
    disconnect?: Enumerable<ProductoWhereUniqueInput>
    delete?: Enumerable<ProductoWhereUniqueInput>
    connect?: Enumerable<ProductoWhereUniqueInput>
    update?: Enumerable<ProductoUpdateWithWhereUniqueWithoutSucursalesInput>
    updateMany?: Enumerable<ProductoUpdateManyWithWhereWithoutSucursalesInput>
    deleteMany?: Enumerable<ProductoScalarWhereInput>
  }

  export type UsuarioUncheckedUpdateManyWithoutSucursalesNestedInput = {
    create?: XOR<Enumerable<UsuarioCreateWithoutSucursalesInput>, Enumerable<UsuarioUncheckedCreateWithoutSucursalesInput>>
    connectOrCreate?: Enumerable<UsuarioCreateOrConnectWithoutSucursalesInput>
    upsert?: Enumerable<UsuarioUpsertWithWhereUniqueWithoutSucursalesInput>
    set?: Enumerable<UsuarioWhereUniqueInput>
    disconnect?: Enumerable<UsuarioWhereUniqueInput>
    delete?: Enumerable<UsuarioWhereUniqueInput>
    connect?: Enumerable<UsuarioWhereUniqueInput>
    update?: Enumerable<UsuarioUpdateWithWhereUniqueWithoutSucursalesInput>
    updateMany?: Enumerable<UsuarioUpdateManyWithWhereWithoutSucursalesInput>
    deleteMany?: Enumerable<UsuarioScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutSucursalInput>, Enumerable<PedidoUncheckedCreateWithoutSucursalInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutSucursalInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutSucursalInput>
    createMany?: PedidoCreateManySucursalInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutSucursalInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutSucursalInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type ReservacionCreateNestedManyWithoutMesasInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutMesasInput>, Enumerable<ReservacionUncheckedCreateWithoutMesasInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutMesasInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type PedidoCreateNestedManyWithoutMesaInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMesaInput>, Enumerable<PedidoUncheckedCreateWithoutMesaInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMesaInput>
    createMany?: PedidoCreateManyMesaInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type SucursalCreateNestedOneWithoutMesasInput = {
    create?: XOR<SucursalCreateWithoutMesasInput, SucursalUncheckedCreateWithoutMesasInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutMesasInput
    connect?: SucursalWhereUniqueInput
  }

  export type DisponibilidadMesaCreateNestedOneWithoutMesasInput = {
    create?: XOR<DisponibilidadMesaCreateWithoutMesasInput, DisponibilidadMesaUncheckedCreateWithoutMesasInput>
    connectOrCreate?: DisponibilidadMesaCreateOrConnectWithoutMesasInput
    connect?: DisponibilidadMesaWhereUniqueInput
  }

  export type ReservacionUncheckedCreateNestedManyWithoutMesasInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutMesasInput>, Enumerable<ReservacionUncheckedCreateWithoutMesasInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutMesasInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutMesaInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMesaInput>, Enumerable<PedidoUncheckedCreateWithoutMesaInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMesaInput>
    createMany?: PedidoCreateManyMesaInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ReservacionUpdateManyWithoutMesasNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutMesasInput>, Enumerable<ReservacionUncheckedCreateWithoutMesasInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutMesasInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutMesasInput>
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutMesasInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutMesasInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type PedidoUpdateManyWithoutMesaNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMesaInput>, Enumerable<PedidoUncheckedCreateWithoutMesaInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMesaInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutMesaInput>
    createMany?: PedidoCreateManyMesaInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutMesaInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutMesaInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type SucursalUpdateOneRequiredWithoutMesasNestedInput = {
    create?: XOR<SucursalCreateWithoutMesasInput, SucursalUncheckedCreateWithoutMesasInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutMesasInput
    upsert?: SucursalUpsertWithoutMesasInput
    connect?: SucursalWhereUniqueInput
    update?: XOR<SucursalUpdateWithoutMesasInput, SucursalUncheckedUpdateWithoutMesasInput>
  }

  export type DisponibilidadMesaUpdateOneRequiredWithoutMesasNestedInput = {
    create?: XOR<DisponibilidadMesaCreateWithoutMesasInput, DisponibilidadMesaUncheckedCreateWithoutMesasInput>
    connectOrCreate?: DisponibilidadMesaCreateOrConnectWithoutMesasInput
    upsert?: DisponibilidadMesaUpsertWithoutMesasInput
    connect?: DisponibilidadMesaWhereUniqueInput
    update?: XOR<DisponibilidadMesaUpdateWithoutMesasInput, DisponibilidadMesaUncheckedUpdateWithoutMesasInput>
  }

  export type ReservacionUncheckedUpdateManyWithoutMesasNestedInput = {
    create?: XOR<Enumerable<ReservacionCreateWithoutMesasInput>, Enumerable<ReservacionUncheckedCreateWithoutMesasInput>>
    connectOrCreate?: Enumerable<ReservacionCreateOrConnectWithoutMesasInput>
    upsert?: Enumerable<ReservacionUpsertWithWhereUniqueWithoutMesasInput>
    set?: Enumerable<ReservacionWhereUniqueInput>
    disconnect?: Enumerable<ReservacionWhereUniqueInput>
    delete?: Enumerable<ReservacionWhereUniqueInput>
    connect?: Enumerable<ReservacionWhereUniqueInput>
    update?: Enumerable<ReservacionUpdateWithWhereUniqueWithoutMesasInput>
    updateMany?: Enumerable<ReservacionUpdateManyWithWhereWithoutMesasInput>
    deleteMany?: Enumerable<ReservacionScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutMesaNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutMesaInput>, Enumerable<PedidoUncheckedCreateWithoutMesaInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutMesaInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutMesaInput>
    createMany?: PedidoCreateManyMesaInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutMesaInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutMesaInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type MesaCreateNestedManyWithoutEstadoMesaInput = {
    create?: XOR<Enumerable<MesaCreateWithoutEstadoMesaInput>, Enumerable<MesaUncheckedCreateWithoutEstadoMesaInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutEstadoMesaInput>
    createMany?: MesaCreateManyEstadoMesaInputEnvelope
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type MesaUncheckedCreateNestedManyWithoutEstadoMesaInput = {
    create?: XOR<Enumerable<MesaCreateWithoutEstadoMesaInput>, Enumerable<MesaUncheckedCreateWithoutEstadoMesaInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutEstadoMesaInput>
    createMany?: MesaCreateManyEstadoMesaInputEnvelope
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type MesaUpdateManyWithoutEstadoMesaNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutEstadoMesaInput>, Enumerable<MesaUncheckedCreateWithoutEstadoMesaInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutEstadoMesaInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutEstadoMesaInput>
    createMany?: MesaCreateManyEstadoMesaInputEnvelope
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutEstadoMesaInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutEstadoMesaInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type MesaUncheckedUpdateManyWithoutEstadoMesaNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutEstadoMesaInput>, Enumerable<MesaUncheckedCreateWithoutEstadoMesaInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutEstadoMesaInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutEstadoMesaInput>
    createMany?: MesaCreateManyEstadoMesaInputEnvelope
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutEstadoMesaInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutEstadoMesaInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type MesaCreateNestedManyWithoutReservacionesInput = {
    create?: XOR<Enumerable<MesaCreateWithoutReservacionesInput>, Enumerable<MesaUncheckedCreateWithoutReservacionesInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutReservacionesInput>
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type SucursalCreateNestedOneWithoutReservacionesInput = {
    create?: XOR<SucursalCreateWithoutReservacionesInput, SucursalUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutReservacionesInput
    connect?: SucursalWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutReservacionesInput = {
    create?: XOR<UsuarioCreateWithoutReservacionesInput, UsuarioUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutReservacionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type MesaUncheckedCreateNestedManyWithoutReservacionesInput = {
    create?: XOR<Enumerable<MesaCreateWithoutReservacionesInput>, Enumerable<MesaUncheckedCreateWithoutReservacionesInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutReservacionesInput>
    connect?: Enumerable<MesaWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MesaUpdateManyWithoutReservacionesNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutReservacionesInput>, Enumerable<MesaUncheckedCreateWithoutReservacionesInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutReservacionesInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutReservacionesInput>
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutReservacionesInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutReservacionesInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type SucursalUpdateOneRequiredWithoutReservacionesNestedInput = {
    create?: XOR<SucursalCreateWithoutReservacionesInput, SucursalUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutReservacionesInput
    upsert?: SucursalUpsertWithoutReservacionesInput
    connect?: SucursalWhereUniqueInput
    update?: XOR<SucursalUpdateWithoutReservacionesInput, SucursalUncheckedUpdateWithoutReservacionesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutReservacionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutReservacionesInput, UsuarioUncheckedCreateWithoutReservacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutReservacionesInput
    upsert?: UsuarioUpsertWithoutReservacionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutReservacionesInput, UsuarioUncheckedUpdateWithoutReservacionesInput>
  }

  export type MesaUncheckedUpdateManyWithoutReservacionesNestedInput = {
    create?: XOR<Enumerable<MesaCreateWithoutReservacionesInput>, Enumerable<MesaUncheckedCreateWithoutReservacionesInput>>
    connectOrCreate?: Enumerable<MesaCreateOrConnectWithoutReservacionesInput>
    upsert?: Enumerable<MesaUpsertWithWhereUniqueWithoutReservacionesInput>
    set?: Enumerable<MesaWhereUniqueInput>
    disconnect?: Enumerable<MesaWhereUniqueInput>
    delete?: Enumerable<MesaWhereUniqueInput>
    connect?: Enumerable<MesaWhereUniqueInput>
    update?: Enumerable<MesaUpdateWithWhereUniqueWithoutReservacionesInput>
    updateMany?: Enumerable<MesaUpdateManyWithWhereWithoutReservacionesInput>
    deleteMany?: Enumerable<MesaScalarWhereInput>
  }

  export type ProductoCreateNestedManyWithoutCategoria_ProductoInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutCategoria_ProductoInput>, Enumerable<ProductoUncheckedCreateWithoutCategoria_ProductoInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutCategoria_ProductoInput>
    createMany?: ProductoCreateManyCategoria_ProductoInputEnvelope
    connect?: Enumerable<ProductoWhereUniqueInput>
  }

  export type ProductoUncheckedCreateNestedManyWithoutCategoria_ProductoInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutCategoria_ProductoInput>, Enumerable<ProductoUncheckedCreateWithoutCategoria_ProductoInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutCategoria_ProductoInput>
    createMany?: ProductoCreateManyCategoria_ProductoInputEnvelope
    connect?: Enumerable<ProductoWhereUniqueInput>
  }

  export type ProductoUpdateManyWithoutCategoria_ProductoNestedInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutCategoria_ProductoInput>, Enumerable<ProductoUncheckedCreateWithoutCategoria_ProductoInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutCategoria_ProductoInput>
    upsert?: Enumerable<ProductoUpsertWithWhereUniqueWithoutCategoria_ProductoInput>
    createMany?: ProductoCreateManyCategoria_ProductoInputEnvelope
    set?: Enumerable<ProductoWhereUniqueInput>
    disconnect?: Enumerable<ProductoWhereUniqueInput>
    delete?: Enumerable<ProductoWhereUniqueInput>
    connect?: Enumerable<ProductoWhereUniqueInput>
    update?: Enumerable<ProductoUpdateWithWhereUniqueWithoutCategoria_ProductoInput>
    updateMany?: Enumerable<ProductoUpdateManyWithWhereWithoutCategoria_ProductoInput>
    deleteMany?: Enumerable<ProductoScalarWhereInput>
  }

  export type ProductoUncheckedUpdateManyWithoutCategoria_ProductoNestedInput = {
    create?: XOR<Enumerable<ProductoCreateWithoutCategoria_ProductoInput>, Enumerable<ProductoUncheckedCreateWithoutCategoria_ProductoInput>>
    connectOrCreate?: Enumerable<ProductoCreateOrConnectWithoutCategoria_ProductoInput>
    upsert?: Enumerable<ProductoUpsertWithWhereUniqueWithoutCategoria_ProductoInput>
    createMany?: ProductoCreateManyCategoria_ProductoInputEnvelope
    set?: Enumerable<ProductoWhereUniqueInput>
    disconnect?: Enumerable<ProductoWhereUniqueInput>
    delete?: Enumerable<ProductoWhereUniqueInput>
    connect?: Enumerable<ProductoWhereUniqueInput>
    update?: Enumerable<ProductoUpdateWithWhereUniqueWithoutCategoria_ProductoInput>
    updateMany?: Enumerable<ProductoUpdateManyWithWhereWithoutCategoria_ProductoInput>
    deleteMany?: Enumerable<ProductoScalarWhereInput>
  }

  export type Categoria_ProductoCreateNestedOneWithoutProductosInput = {
    create?: XOR<Categoria_ProductoCreateWithoutProductosInput, Categoria_ProductoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: Categoria_ProductoCreateOrConnectWithoutProductosInput
    connect?: Categoria_ProductoWhereUniqueInput
  }

  export type Factura_DetalleCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutProductoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutProductoInput>
    createMany?: Factura_DetalleCreateManyProductoInputEnvelope
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
  }

  export type Pedido_ProductoCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutProductoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutProductoInput>
    createMany?: Pedido_ProductoCreateManyProductoInputEnvelope
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
  }

  export type SucursalCreateNestedManyWithoutProductosInput = {
    create?: XOR<Enumerable<SucursalCreateWithoutProductosInput>, Enumerable<SucursalUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<SucursalCreateOrConnectWithoutProductosInput>
    connect?: Enumerable<SucursalWhereUniqueInput>
  }

  export type Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutProductoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutProductoInput>
    createMany?: Factura_DetalleCreateManyProductoInputEnvelope
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
  }

  export type Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutProductoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutProductoInput>
    createMany?: Pedido_ProductoCreateManyProductoInputEnvelope
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
  }

  export type SucursalUncheckedCreateNestedManyWithoutProductosInput = {
    create?: XOR<Enumerable<SucursalCreateWithoutProductosInput>, Enumerable<SucursalUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<SucursalCreateOrConnectWithoutProductosInput>
    connect?: Enumerable<SucursalWhereUniqueInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<Categoria_ProductoCreateWithoutProductosInput, Categoria_ProductoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: Categoria_ProductoCreateOrConnectWithoutProductosInput
    upsert?: Categoria_ProductoUpsertWithoutProductosInput
    connect?: Categoria_ProductoWhereUniqueInput
    update?: XOR<Categoria_ProductoUpdateWithoutProductosInput, Categoria_ProductoUncheckedUpdateWithoutProductosInput>
  }

  export type Factura_DetalleUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutProductoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Factura_DetalleUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Factura_DetalleCreateManyProductoInputEnvelope
    set?: Enumerable<Factura_DetalleWhereUniqueInput>
    disconnect?: Enumerable<Factura_DetalleWhereUniqueInput>
    delete?: Enumerable<Factura_DetalleWhereUniqueInput>
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
    update?: Enumerable<Factura_DetalleUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Factura_DetalleUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Factura_DetalleScalarWhereInput>
  }

  export type Pedido_ProductoUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutProductoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Pedido_ProductoUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Pedido_ProductoCreateManyProductoInputEnvelope
    set?: Enumerable<Pedido_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    delete?: Enumerable<Pedido_ProductoWhereUniqueInput>
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    update?: Enumerable<Pedido_ProductoUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Pedido_ProductoUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Pedido_ProductoScalarWhereInput>
  }

  export type SucursalUpdateManyWithoutProductosNestedInput = {
    create?: XOR<Enumerable<SucursalCreateWithoutProductosInput>, Enumerable<SucursalUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<SucursalCreateOrConnectWithoutProductosInput>
    upsert?: Enumerable<SucursalUpsertWithWhereUniqueWithoutProductosInput>
    set?: Enumerable<SucursalWhereUniqueInput>
    disconnect?: Enumerable<SucursalWhereUniqueInput>
    delete?: Enumerable<SucursalWhereUniqueInput>
    connect?: Enumerable<SucursalWhereUniqueInput>
    update?: Enumerable<SucursalUpdateWithWhereUniqueWithoutProductosInput>
    updateMany?: Enumerable<SucursalUpdateManyWithWhereWithoutProductosInput>
    deleteMany?: Enumerable<SucursalScalarWhereInput>
  }

  export type Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutProductoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Factura_DetalleUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Factura_DetalleCreateManyProductoInputEnvelope
    set?: Enumerable<Factura_DetalleWhereUniqueInput>
    disconnect?: Enumerable<Factura_DetalleWhereUniqueInput>
    delete?: Enumerable<Factura_DetalleWhereUniqueInput>
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
    update?: Enumerable<Factura_DetalleUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Factura_DetalleUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Factura_DetalleScalarWhereInput>
  }

  export type Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutProductoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<Pedido_ProductoUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: Pedido_ProductoCreateManyProductoInputEnvelope
    set?: Enumerable<Pedido_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    delete?: Enumerable<Pedido_ProductoWhereUniqueInput>
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    update?: Enumerable<Pedido_ProductoUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<Pedido_ProductoUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<Pedido_ProductoScalarWhereInput>
  }

  export type SucursalUncheckedUpdateManyWithoutProductosNestedInput = {
    create?: XOR<Enumerable<SucursalCreateWithoutProductosInput>, Enumerable<SucursalUncheckedCreateWithoutProductosInput>>
    connectOrCreate?: Enumerable<SucursalCreateOrConnectWithoutProductosInput>
    upsert?: Enumerable<SucursalUpsertWithWhereUniqueWithoutProductosInput>
    set?: Enumerable<SucursalWhereUniqueInput>
    disconnect?: Enumerable<SucursalWhereUniqueInput>
    delete?: Enumerable<SucursalWhereUniqueInput>
    connect?: Enumerable<SucursalWhereUniqueInput>
    update?: Enumerable<SucursalUpdateWithWhereUniqueWithoutProductosInput>
    updateMany?: Enumerable<SucursalUpdateManyWithWhereWithoutProductosInput>
    deleteMany?: Enumerable<SucursalScalarWhereInput>
  }

  export type FacturaEncabezadoTipoPagoCreateNestedManyWithoutTipoPagoInput = {
    create?: XOR<Enumerable<FacturaEncabezadoTipoPagoCreateWithoutTipoPagoInput>, Enumerable<FacturaEncabezadoTipoPagoUncheckedCreateWithoutTipoPagoInput>>
    connectOrCreate?: Enumerable<FacturaEncabezadoTipoPagoCreateOrConnectWithoutTipoPagoInput>
    createMany?: FacturaEncabezadoTipoPagoCreateManyTipoPagoInputEnvelope
    connect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
  }

  export type FacturaEncabezadoTipoPagoUncheckedCreateNestedManyWithoutTipoPagoInput = {
    create?: XOR<Enumerable<FacturaEncabezadoTipoPagoCreateWithoutTipoPagoInput>, Enumerable<FacturaEncabezadoTipoPagoUncheckedCreateWithoutTipoPagoInput>>
    connectOrCreate?: Enumerable<FacturaEncabezadoTipoPagoCreateOrConnectWithoutTipoPagoInput>
    createMany?: FacturaEncabezadoTipoPagoCreateManyTipoPagoInputEnvelope
    connect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
  }

  export type FacturaEncabezadoTipoPagoUpdateManyWithoutTipoPagoNestedInput = {
    create?: XOR<Enumerable<FacturaEncabezadoTipoPagoCreateWithoutTipoPagoInput>, Enumerable<FacturaEncabezadoTipoPagoUncheckedCreateWithoutTipoPagoInput>>
    connectOrCreate?: Enumerable<FacturaEncabezadoTipoPagoCreateOrConnectWithoutTipoPagoInput>
    upsert?: Enumerable<FacturaEncabezadoTipoPagoUpsertWithWhereUniqueWithoutTipoPagoInput>
    createMany?: FacturaEncabezadoTipoPagoCreateManyTipoPagoInputEnvelope
    set?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    disconnect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    delete?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    connect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    update?: Enumerable<FacturaEncabezadoTipoPagoUpdateWithWhereUniqueWithoutTipoPagoInput>
    updateMany?: Enumerable<FacturaEncabezadoTipoPagoUpdateManyWithWhereWithoutTipoPagoInput>
    deleteMany?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereInput>
  }

  export type FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutTipoPagoNestedInput = {
    create?: XOR<Enumerable<FacturaEncabezadoTipoPagoCreateWithoutTipoPagoInput>, Enumerable<FacturaEncabezadoTipoPagoUncheckedCreateWithoutTipoPagoInput>>
    connectOrCreate?: Enumerable<FacturaEncabezadoTipoPagoCreateOrConnectWithoutTipoPagoInput>
    upsert?: Enumerable<FacturaEncabezadoTipoPagoUpsertWithWhereUniqueWithoutTipoPagoInput>
    createMany?: FacturaEncabezadoTipoPagoCreateManyTipoPagoInputEnvelope
    set?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    disconnect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    delete?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    connect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    update?: Enumerable<FacturaEncabezadoTipoPagoUpdateWithWhereUniqueWithoutTipoPagoInput>
    updateMany?: Enumerable<FacturaEncabezadoTipoPagoUpdateManyWithWhereWithoutTipoPagoInput>
    deleteMany?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereInput>
  }

  export type Factura_EncabezadoCreateNestedManyWithoutTipoTarjetaInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutTipoTarjetaInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutTipoTarjetaInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutTipoTarjetaInput>
    createMany?: Factura_EncabezadoCreateManyTipoTarjetaInputEnvelope
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
  }

  export type Factura_EncabezadoUncheckedCreateNestedManyWithoutTipoTarjetaInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutTipoTarjetaInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutTipoTarjetaInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutTipoTarjetaInput>
    createMany?: Factura_EncabezadoCreateManyTipoTarjetaInputEnvelope
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
  }

  export type Factura_EncabezadoUpdateManyWithoutTipoTarjetaNestedInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutTipoTarjetaInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutTipoTarjetaInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutTipoTarjetaInput>
    upsert?: Enumerable<Factura_EncabezadoUpsertWithWhereUniqueWithoutTipoTarjetaInput>
    createMany?: Factura_EncabezadoCreateManyTipoTarjetaInputEnvelope
    set?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    disconnect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    delete?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    update?: Enumerable<Factura_EncabezadoUpdateWithWhereUniqueWithoutTipoTarjetaInput>
    updateMany?: Enumerable<Factura_EncabezadoUpdateManyWithWhereWithoutTipoTarjetaInput>
    deleteMany?: Enumerable<Factura_EncabezadoScalarWhereInput>
  }

  export type Factura_EncabezadoUncheckedUpdateManyWithoutTipoTarjetaNestedInput = {
    create?: XOR<Enumerable<Factura_EncabezadoCreateWithoutTipoTarjetaInput>, Enumerable<Factura_EncabezadoUncheckedCreateWithoutTipoTarjetaInput>>
    connectOrCreate?: Enumerable<Factura_EncabezadoCreateOrConnectWithoutTipoTarjetaInput>
    upsert?: Enumerable<Factura_EncabezadoUpsertWithWhereUniqueWithoutTipoTarjetaInput>
    createMany?: Factura_EncabezadoCreateManyTipoTarjetaInputEnvelope
    set?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    disconnect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    delete?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    connect?: Enumerable<Factura_EncabezadoWhereUniqueInput>
    update?: Enumerable<Factura_EncabezadoUpdateWithWhereUniqueWithoutTipoTarjetaInput>
    updateMany?: Enumerable<Factura_EncabezadoUpdateManyWithWhereWithoutTipoTarjetaInput>
    deleteMany?: Enumerable<Factura_EncabezadoScalarWhereInput>
  }

  export type TipoTarjetaCreateNestedOneWithoutFacturasInput = {
    create?: XOR<TipoTarjetaCreateWithoutFacturasInput, TipoTarjetaUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: TipoTarjetaCreateOrConnectWithoutFacturasInput
    connect?: TipoTarjetaWhereUniqueInput
  }

  export type Factura_DetalleCreateNestedManyWithoutFactura_EncabezadoInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutFactura_EncabezadoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput>
    createMany?: Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
  }

  export type FacturaEncabezadoTipoPagoCreateNestedManyWithoutFactura_EncabezadoInput = {
    create?: XOR<Enumerable<FacturaEncabezadoTipoPagoCreateWithoutFactura_EncabezadoInput>, Enumerable<FacturaEncabezadoTipoPagoUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<FacturaEncabezadoTipoPagoCreateOrConnectWithoutFactura_EncabezadoInput>
    createMany?: FacturaEncabezadoTipoPagoCreateManyFactura_EncabezadoInputEnvelope
    connect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
  }

  export type UsuarioCreateNestedOneWithoutFacturasInput = {
    create?: XOR<UsuarioCreateWithoutFacturasInput, UsuarioUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFacturasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type Factura_DetalleUncheckedCreateNestedManyWithoutFactura_EncabezadoInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutFactura_EncabezadoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput>
    createMany?: Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
  }

  export type FacturaEncabezadoTipoPagoUncheckedCreateNestedManyWithoutFactura_EncabezadoInput = {
    create?: XOR<Enumerable<FacturaEncabezadoTipoPagoCreateWithoutFactura_EncabezadoInput>, Enumerable<FacturaEncabezadoTipoPagoUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<FacturaEncabezadoTipoPagoCreateOrConnectWithoutFactura_EncabezadoInput>
    createMany?: FacturaEncabezadoTipoPagoCreateManyFactura_EncabezadoInputEnvelope
    connect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
  }

  export type TipoTarjetaUpdateOneWithoutFacturasNestedInput = {
    create?: XOR<TipoTarjetaCreateWithoutFacturasInput, TipoTarjetaUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: TipoTarjetaCreateOrConnectWithoutFacturasInput
    upsert?: TipoTarjetaUpsertWithoutFacturasInput
    disconnect?: boolean
    delete?: boolean
    connect?: TipoTarjetaWhereUniqueInput
    update?: XOR<TipoTarjetaUpdateWithoutFacturasInput, TipoTarjetaUncheckedUpdateWithoutFacturasInput>
  }

  export type Factura_DetalleUpdateManyWithoutFactura_EncabezadoNestedInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutFactura_EncabezadoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput>
    upsert?: Enumerable<Factura_DetalleUpsertWithWhereUniqueWithoutFactura_EncabezadoInput>
    createMany?: Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope
    set?: Enumerable<Factura_DetalleWhereUniqueInput>
    disconnect?: Enumerable<Factura_DetalleWhereUniqueInput>
    delete?: Enumerable<Factura_DetalleWhereUniqueInput>
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
    update?: Enumerable<Factura_DetalleUpdateWithWhereUniqueWithoutFactura_EncabezadoInput>
    updateMany?: Enumerable<Factura_DetalleUpdateManyWithWhereWithoutFactura_EncabezadoInput>
    deleteMany?: Enumerable<Factura_DetalleScalarWhereInput>
  }

  export type FacturaEncabezadoTipoPagoUpdateManyWithoutFactura_EncabezadoNestedInput = {
    create?: XOR<Enumerable<FacturaEncabezadoTipoPagoCreateWithoutFactura_EncabezadoInput>, Enumerable<FacturaEncabezadoTipoPagoUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<FacturaEncabezadoTipoPagoCreateOrConnectWithoutFactura_EncabezadoInput>
    upsert?: Enumerable<FacturaEncabezadoTipoPagoUpsertWithWhereUniqueWithoutFactura_EncabezadoInput>
    createMany?: FacturaEncabezadoTipoPagoCreateManyFactura_EncabezadoInputEnvelope
    set?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    disconnect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    delete?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    connect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    update?: Enumerable<FacturaEncabezadoTipoPagoUpdateWithWhereUniqueWithoutFactura_EncabezadoInput>
    updateMany?: Enumerable<FacturaEncabezadoTipoPagoUpdateManyWithWhereWithoutFactura_EncabezadoInput>
    deleteMany?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereInput>
  }

  export type UsuarioUpdateOneRequiredWithoutFacturasNestedInput = {
    create?: XOR<UsuarioCreateWithoutFacturasInput, UsuarioUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFacturasInput
    upsert?: UsuarioUpsertWithoutFacturasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutFacturasInput, UsuarioUncheckedUpdateWithoutFacturasInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Factura_DetalleUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput = {
    create?: XOR<Enumerable<Factura_DetalleCreateWithoutFactura_EncabezadoInput>, Enumerable<Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput>
    upsert?: Enumerable<Factura_DetalleUpsertWithWhereUniqueWithoutFactura_EncabezadoInput>
    createMany?: Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope
    set?: Enumerable<Factura_DetalleWhereUniqueInput>
    disconnect?: Enumerable<Factura_DetalleWhereUniqueInput>
    delete?: Enumerable<Factura_DetalleWhereUniqueInput>
    connect?: Enumerable<Factura_DetalleWhereUniqueInput>
    update?: Enumerable<Factura_DetalleUpdateWithWhereUniqueWithoutFactura_EncabezadoInput>
    updateMany?: Enumerable<Factura_DetalleUpdateManyWithWhereWithoutFactura_EncabezadoInput>
    deleteMany?: Enumerable<Factura_DetalleScalarWhereInput>
  }

  export type FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput = {
    create?: XOR<Enumerable<FacturaEncabezadoTipoPagoCreateWithoutFactura_EncabezadoInput>, Enumerable<FacturaEncabezadoTipoPagoUncheckedCreateWithoutFactura_EncabezadoInput>>
    connectOrCreate?: Enumerable<FacturaEncabezadoTipoPagoCreateOrConnectWithoutFactura_EncabezadoInput>
    upsert?: Enumerable<FacturaEncabezadoTipoPagoUpsertWithWhereUniqueWithoutFactura_EncabezadoInput>
    createMany?: FacturaEncabezadoTipoPagoCreateManyFactura_EncabezadoInputEnvelope
    set?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    disconnect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    delete?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    connect?: Enumerable<FacturaEncabezadoTipoPagoWhereUniqueInput>
    update?: Enumerable<FacturaEncabezadoTipoPagoUpdateWithWhereUniqueWithoutFactura_EncabezadoInput>
    updateMany?: Enumerable<FacturaEncabezadoTipoPagoUpdateManyWithWhereWithoutFactura_EncabezadoInput>
    deleteMany?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereInput>
  }

  export type Factura_EncabezadoCreateNestedOneWithoutDetallesInput = {
    create?: XOR<Factura_EncabezadoCreateWithoutDetallesInput, Factura_EncabezadoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: Factura_EncabezadoCreateOrConnectWithoutDetallesInput
    connect?: Factura_EncabezadoWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutDetallesInput = {
    create?: XOR<ProductoCreateWithoutDetallesInput, ProductoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetallesInput
    connect?: ProductoWhereUniqueInput
  }

  export type Factura_EncabezadoUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<Factura_EncabezadoCreateWithoutDetallesInput, Factura_EncabezadoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: Factura_EncabezadoCreateOrConnectWithoutDetallesInput
    upsert?: Factura_EncabezadoUpsertWithoutDetallesInput
    connect?: Factura_EncabezadoWhereUniqueInput
    update?: XOR<Factura_EncabezadoUpdateWithoutDetallesInput, Factura_EncabezadoUncheckedUpdateWithoutDetallesInput>
  }

  export type ProductoUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<ProductoCreateWithoutDetallesInput, ProductoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetallesInput
    upsert?: ProductoUpsertWithoutDetallesInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<ProductoUpdateWithoutDetallesInput, ProductoUncheckedUpdateWithoutDetallesInput>
  }

  export type Factura_EncabezadoCreateNestedOneWithoutTipoPagosInput = {
    create?: XOR<Factura_EncabezadoCreateWithoutTipoPagosInput, Factura_EncabezadoUncheckedCreateWithoutTipoPagosInput>
    connectOrCreate?: Factura_EncabezadoCreateOrConnectWithoutTipoPagosInput
    connect?: Factura_EncabezadoWhereUniqueInput
  }

  export type TipoPagoCreateNestedOneWithoutFacturasEncabezadoInput = {
    create?: XOR<TipoPagoCreateWithoutFacturasEncabezadoInput, TipoPagoUncheckedCreateWithoutFacturasEncabezadoInput>
    connectOrCreate?: TipoPagoCreateOrConnectWithoutFacturasEncabezadoInput
    connect?: TipoPagoWhereUniqueInput
  }

  export type Factura_EncabezadoUpdateOneRequiredWithoutTipoPagosNestedInput = {
    create?: XOR<Factura_EncabezadoCreateWithoutTipoPagosInput, Factura_EncabezadoUncheckedCreateWithoutTipoPagosInput>
    connectOrCreate?: Factura_EncabezadoCreateOrConnectWithoutTipoPagosInput
    upsert?: Factura_EncabezadoUpsertWithoutTipoPagosInput
    connect?: Factura_EncabezadoWhereUniqueInput
    update?: XOR<Factura_EncabezadoUpdateWithoutTipoPagosInput, Factura_EncabezadoUncheckedUpdateWithoutTipoPagosInput>
  }

  export type TipoPagoUpdateOneRequiredWithoutFacturasEncabezadoNestedInput = {
    create?: XOR<TipoPagoCreateWithoutFacturasEncabezadoInput, TipoPagoUncheckedCreateWithoutFacturasEncabezadoInput>
    connectOrCreate?: TipoPagoCreateOrConnectWithoutFacturasEncabezadoInput
    upsert?: TipoPagoUpsertWithoutFacturasEncabezadoInput
    connect?: TipoPagoWhereUniqueInput
    update?: XOR<TipoPagoUpdateWithoutFacturasEncabezadoInput, TipoPagoUncheckedUpdateWithoutFacturasEncabezadoInput>
  }

  export type PedidoCreateNestedManyWithoutEstadoPedidoInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutEstadoPedidoInput>, Enumerable<PedidoUncheckedCreateWithoutEstadoPedidoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutEstadoPedidoInput>
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutEstadoPedidoInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutEstadoPedidoInput>, Enumerable<PedidoUncheckedCreateWithoutEstadoPedidoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutEstadoPedidoInput>
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PedidoUpdateManyWithoutEstadoPedidoNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutEstadoPedidoInput>, Enumerable<PedidoUncheckedCreateWithoutEstadoPedidoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutEstadoPedidoInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput>
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutEstadoPedidoInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutEstadoPedidoNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutEstadoPedidoInput>, Enumerable<PedidoUncheckedCreateWithoutEstadoPedidoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutEstadoPedidoInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput>
    createMany?: PedidoCreateManyEstadoPedidoInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutEstadoPedidoInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type PedidoCreateNestedManyWithoutTipoPedidoInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutTipoPedidoInput>, Enumerable<PedidoUncheckedCreateWithoutTipoPedidoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutTipoPedidoInput>
    createMany?: PedidoCreateManyTipoPedidoInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutTipoPedidoInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutTipoPedidoInput>, Enumerable<PedidoUncheckedCreateWithoutTipoPedidoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutTipoPedidoInput>
    createMany?: PedidoCreateManyTipoPedidoInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type PedidoUpdateManyWithoutTipoPedidoNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutTipoPedidoInput>, Enumerable<PedidoUncheckedCreateWithoutTipoPedidoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutTipoPedidoInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutTipoPedidoInput>
    createMany?: PedidoCreateManyTipoPedidoInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutTipoPedidoInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutTipoPedidoInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutTipoPedidoNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutTipoPedidoInput>, Enumerable<PedidoUncheckedCreateWithoutTipoPedidoInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutTipoPedidoInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutTipoPedidoInput>
    createMany?: PedidoCreateManyTipoPedidoInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutTipoPedidoInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutTipoPedidoInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type Pedido_ProductoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutPedidoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutPedidoInput>
    createMany?: Pedido_ProductoCreateManyPedidoInputEnvelope
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
  }

  export type EstadoPedidoCreateNestedOneWithoutPedidosInput = {
    create?: XOR<EstadoPedidoCreateWithoutPedidosInput, EstadoPedidoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: EstadoPedidoCreateOrConnectWithoutPedidosInput
    connect?: EstadoPedidoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutPedidosInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutEncargosInput = {
    create?: XOR<UsuarioCreateWithoutEncargosInput, UsuarioUncheckedCreateWithoutEncargosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEncargosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type SucursalCreateNestedOneWithoutPedidosInput = {
    create?: XOR<SucursalCreateWithoutPedidosInput, SucursalUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutPedidosInput
    connect?: SucursalWhereUniqueInput
  }

  export type MesaCreateNestedOneWithoutPedidosInput = {
    create?: XOR<MesaCreateWithoutPedidosInput, MesaUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: MesaCreateOrConnectWithoutPedidosInput
    connect?: MesaWhereUniqueInput
  }

  export type TipoPedidoCreateNestedOneWithoutPedidosInput = {
    create?: XOR<TipoPedidoCreateWithoutPedidosInput, TipoPedidoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: TipoPedidoCreateOrConnectWithoutPedidosInput
    connect?: TipoPedidoWhereUniqueInput
  }

  export type Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutPedidoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutPedidoInput>
    createMany?: Pedido_ProductoCreateManyPedidoInputEnvelope
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
  }

  export type Pedido_ProductoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutPedidoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<Pedido_ProductoUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: Pedido_ProductoCreateManyPedidoInputEnvelope
    set?: Enumerable<Pedido_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    delete?: Enumerable<Pedido_ProductoWhereUniqueInput>
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    update?: Enumerable<Pedido_ProductoUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<Pedido_ProductoUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<Pedido_ProductoScalarWhereInput>
  }

  export type EstadoPedidoUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<EstadoPedidoCreateWithoutPedidosInput, EstadoPedidoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: EstadoPedidoCreateOrConnectWithoutPedidosInput
    upsert?: EstadoPedidoUpsertWithoutPedidosInput
    connect?: EstadoPedidoWhereUniqueInput
    update?: XOR<EstadoPedidoUpdateWithoutPedidosInput, EstadoPedidoUncheckedUpdateWithoutPedidosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    upsert?: UsuarioUpsertWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
  }

  export type UsuarioUpdateOneWithoutEncargosNestedInput = {
    create?: XOR<UsuarioCreateWithoutEncargosInput, UsuarioUncheckedCreateWithoutEncargosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEncargosInput
    upsert?: UsuarioUpsertWithoutEncargosInput
    disconnect?: boolean
    delete?: boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutEncargosInput, UsuarioUncheckedUpdateWithoutEncargosInput>
  }

  export type SucursalUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<SucursalCreateWithoutPedidosInput, SucursalUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: SucursalCreateOrConnectWithoutPedidosInput
    upsert?: SucursalUpsertWithoutPedidosInput
    connect?: SucursalWhereUniqueInput
    update?: XOR<SucursalUpdateWithoutPedidosInput, SucursalUncheckedUpdateWithoutPedidosInput>
  }

  export type MesaUpdateOneWithoutPedidosNestedInput = {
    create?: XOR<MesaCreateWithoutPedidosInput, MesaUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: MesaCreateOrConnectWithoutPedidosInput
    upsert?: MesaUpsertWithoutPedidosInput
    disconnect?: boolean
    delete?: boolean
    connect?: MesaWhereUniqueInput
    update?: XOR<MesaUpdateWithoutPedidosInput, MesaUncheckedUpdateWithoutPedidosInput>
  }

  export type TipoPedidoUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<TipoPedidoCreateWithoutPedidosInput, TipoPedidoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: TipoPedidoCreateOrConnectWithoutPedidosInput
    upsert?: TipoPedidoUpsertWithoutPedidosInput
    connect?: TipoPedidoWhereUniqueInput
    update?: XOR<TipoPedidoUpdateWithoutPedidosInput, TipoPedidoUncheckedUpdateWithoutPedidosInput>
  }

  export type Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<Pedido_ProductoCreateWithoutPedidoInput>, Enumerable<Pedido_ProductoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<Pedido_ProductoCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<Pedido_ProductoUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: Pedido_ProductoCreateManyPedidoInputEnvelope
    set?: Enumerable<Pedido_ProductoWhereUniqueInput>
    disconnect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    delete?: Enumerable<Pedido_ProductoWhereUniqueInput>
    connect?: Enumerable<Pedido_ProductoWhereUniqueInput>
    update?: Enumerable<Pedido_ProductoUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<Pedido_ProductoUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<Pedido_ProductoScalarWhereInput>
  }

  export type PedidoCreateNestedOneWithoutDetallesInput = {
    create?: XOR<PedidoCreateWithoutDetallesInput, PedidoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutDetallesInput
    connect?: PedidoWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutPedidosInput = {
    create?: XOR<ProductoCreateWithoutPedidosInput, ProductoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPedidosInput
    connect?: ProductoWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<PedidoCreateWithoutDetallesInput, PedidoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutDetallesInput
    upsert?: PedidoUpsertWithoutDetallesInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<PedidoUpdateWithoutDetallesInput, PedidoUncheckedUpdateWithoutDetallesInput>
  }

  export type ProductoUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<ProductoCreateWithoutPedidosInput, ProductoUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPedidosInput
    upsert?: ProductoUpsertWithoutPedidosInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<ProductoUpdateWithoutPedidosInput, ProductoUncheckedUpdateWithoutPedidosInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type UsuarioCreateWithoutPerfilInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
    encargos?: PedidoCreateNestedManyWithoutMeseroInput
    sucursales?: SucursalCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioUncheckedCreateWithoutPerfilInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
    encargos?: PedidoUncheckedCreateNestedManyWithoutMeseroInput
    sucursales?: SucursalUncheckedCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioCreateOrConnectWithoutPerfilInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPerfilInput, UsuarioUncheckedCreateWithoutPerfilInput>
  }

  export type UsuarioCreateManyPerfilInputEnvelope = {
    data: Enumerable<UsuarioCreateManyPerfilInput>
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithWhereUniqueWithoutPerfilInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutPerfilInput, UsuarioUncheckedUpdateWithoutPerfilInput>
    create: XOR<UsuarioCreateWithoutPerfilInput, UsuarioUncheckedCreateWithoutPerfilInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutPerfilInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutPerfilInput, UsuarioUncheckedUpdateWithoutPerfilInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutPerfilInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: Enumerable<UsuarioScalarWhereInput>
    OR?: Enumerable<UsuarioScalarWhereInput>
    NOT?: Enumerable<UsuarioScalarWhereInput>
    id?: StringFilter | string
    nombre?: StringFilter | string
    apellido1?: StringFilter | string
    apellido2?: StringFilter | string
    correo?: StringFilter | string
    username?: StringFilter | string
    clave?: StringFilter | string
    telefono?: StringFilter | string
    direccion?: StringNullableFilter | string | null
    idPerfil?: IntFilter | number
  }

  export type ReservacionCreateWithoutUsuarioInput = {
    fecha_hora?: Date | string
    cantidad: number
    mesas?: MesaCreateNestedManyWithoutReservacionesInput
    Sucursal: SucursalCreateNestedOneWithoutReservacionesInput
  }

  export type ReservacionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    fecha_hora?: Date | string
    cantidad: number
    mesas?: MesaUncheckedCreateNestedManyWithoutReservacionesInput
    idSucursal: number
  }

  export type ReservacionCreateOrConnectWithoutUsuarioInput = {
    where: ReservacionWhereUniqueInput
    create: XOR<ReservacionCreateWithoutUsuarioInput, ReservacionUncheckedCreateWithoutUsuarioInput>
  }

  export type ReservacionCreateManyUsuarioInputEnvelope = {
    data: Enumerable<ReservacionCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type Factura_EncabezadoCreateWithoutUsuarioInput = {
    numero_tarjeta?: string | null
    TipoTarjeta?: TipoTarjetaCreateNestedOneWithoutFacturasInput
    fecha?: Date | string
    estado?: boolean
    detalles?: Factura_DetalleCreateNestedManyWithoutFactura_EncabezadoInput
    tipoPagos?: FacturaEncabezadoTipoPagoCreateNestedManyWithoutFactura_EncabezadoInput
  }

  export type Factura_EncabezadoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    numero_tarjeta?: string | null
    idTipoTarjeta?: number | null
    fecha?: Date | string
    estado?: boolean
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    tipoPagos?: FacturaEncabezadoTipoPagoUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
  }

  export type Factura_EncabezadoCreateOrConnectWithoutUsuarioInput = {
    where: Factura_EncabezadoWhereUniqueInput
    create: XOR<Factura_EncabezadoCreateWithoutUsuarioInput, Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>
  }

  export type Factura_EncabezadoCreateManyUsuarioInputEnvelope = {
    data: Enumerable<Factura_EncabezadoCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutClienteInput = {
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoCreateNestedManyWithoutPedidoInput
    EstadoPedido: EstadoPedidoCreateNestedOneWithoutPedidosInput
    Mesero?: UsuarioCreateNestedOneWithoutEncargosInput
    Sucursal: SucursalCreateNestedOneWithoutPedidosInput
    Mesa?: MesaCreateNestedOneWithoutPedidosInput
    TipoPedido: TipoPedidoCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutClienteInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput
    idEstado: number
    idMesero?: string | null
    idSucursal: number
    idMesa?: number | null
    idTipoPedido: number
  }

  export type PedidoCreateOrConnectWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput>
  }

  export type PedidoCreateManyClienteInputEnvelope = {
    data: Enumerable<PedidoCreateManyClienteInput>
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutMeseroInput = {
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoCreateNestedManyWithoutPedidoInput
    EstadoPedido: EstadoPedidoCreateNestedOneWithoutPedidosInput
    Cliente: UsuarioCreateNestedOneWithoutPedidosInput
    Sucursal: SucursalCreateNestedOneWithoutPedidosInput
    Mesa?: MesaCreateNestedOneWithoutPedidosInput
    TipoPedido: TipoPedidoCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutMeseroInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput
    idEstado: number
    idCliente: string
    idSucursal: number
    idMesa?: number | null
    idTipoPedido: number
  }

  export type PedidoCreateOrConnectWithoutMeseroInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutMeseroInput, PedidoUncheckedCreateWithoutMeseroInput>
  }

  export type PedidoCreateManyMeseroInputEnvelope = {
    data: Enumerable<PedidoCreateManyMeseroInput>
    skipDuplicates?: boolean
  }

  export type PerfilCreateWithoutUsuariosInput = {
    id: number
    descripcion: string
  }

  export type PerfilUncheckedCreateWithoutUsuariosInput = {
    id: number
    descripcion: string
  }

  export type PerfilCreateOrConnectWithoutUsuariosInput = {
    where: PerfilWhereUniqueInput
    create: XOR<PerfilCreateWithoutUsuariosInput, PerfilUncheckedCreateWithoutUsuariosInput>
  }

  export type SucursalCreateWithoutMeserosInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionCreateNestedManyWithoutSucursalInput
    productos?: ProductoCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateWithoutMeserosInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaUncheckedCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutSucursalInput
    productos?: ProductoUncheckedCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalCreateOrConnectWithoutMeserosInput = {
    where: SucursalWhereUniqueInput
    create: XOR<SucursalCreateWithoutMeserosInput, SucursalUncheckedCreateWithoutMeserosInput>
  }

  export type ReservacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ReservacionWhereUniqueInput
    update: XOR<ReservacionUpdateWithoutUsuarioInput, ReservacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ReservacionCreateWithoutUsuarioInput, ReservacionUncheckedCreateWithoutUsuarioInput>
  }

  export type ReservacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ReservacionWhereUniqueInput
    data: XOR<ReservacionUpdateWithoutUsuarioInput, ReservacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type ReservacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: ReservacionScalarWhereInput
    data: XOR<ReservacionUpdateManyMutationInput, ReservacionUncheckedUpdateManyWithoutReservacionesInput>
  }

  export type ReservacionScalarWhereInput = {
    AND?: Enumerable<ReservacionScalarWhereInput>
    OR?: Enumerable<ReservacionScalarWhereInput>
    NOT?: Enumerable<ReservacionScalarWhereInput>
    id?: IntFilter | number
    fecha_hora?: DateTimeFilter | Date | string
    cantidad?: IntFilter | number
    idSucursal?: IntFilter | number
    idUsuario?: StringFilter | string
  }

  export type Factura_EncabezadoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: Factura_EncabezadoWhereUniqueInput
    update: XOR<Factura_EncabezadoUpdateWithoutUsuarioInput, Factura_EncabezadoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<Factura_EncabezadoCreateWithoutUsuarioInput, Factura_EncabezadoUncheckedCreateWithoutUsuarioInput>
  }

  export type Factura_EncabezadoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: Factura_EncabezadoWhereUniqueInput
    data: XOR<Factura_EncabezadoUpdateWithoutUsuarioInput, Factura_EncabezadoUncheckedUpdateWithoutUsuarioInput>
  }

  export type Factura_EncabezadoUpdateManyWithWhereWithoutUsuarioInput = {
    where: Factura_EncabezadoScalarWhereInput
    data: XOR<Factura_EncabezadoUpdateManyMutationInput, Factura_EncabezadoUncheckedUpdateManyWithoutFacturasInput>
  }

  export type Factura_EncabezadoScalarWhereInput = {
    AND?: Enumerable<Factura_EncabezadoScalarWhereInput>
    OR?: Enumerable<Factura_EncabezadoScalarWhereInput>
    NOT?: Enumerable<Factura_EncabezadoScalarWhereInput>
    id?: IntFilter | number
    numero_tarjeta?: StringNullableFilter | string | null
    idTipoTarjeta?: IntNullableFilter | number | null
    fecha?: DateTimeFilter | Date | string
    estado?: BoolFilter | boolean
    idUsuario?: StringFilter | string
  }

  export type PedidoUpsertWithWhereUniqueWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutClienteInput, PedidoUncheckedUpdateWithoutClienteInput>
    create: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutClienteInput, PedidoUncheckedUpdateWithoutClienteInput>
  }

  export type PedidoUpdateManyWithWhereWithoutClienteInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: Enumerable<PedidoScalarWhereInput>
    OR?: Enumerable<PedidoScalarWhereInput>
    NOT?: Enumerable<PedidoScalarWhereInput>
    id?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter | Date | string
    idEstado?: IntFilter | number
    idCliente?: StringFilter | string
    idMesero?: StringNullableFilter | string | null
    idSucursal?: IntFilter | number
    idMesa?: IntNullableFilter | number | null
    idTipoPedido?: IntFilter | number
  }

  export type PedidoUpsertWithWhereUniqueWithoutMeseroInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutMeseroInput, PedidoUncheckedUpdateWithoutMeseroInput>
    create: XOR<PedidoCreateWithoutMeseroInput, PedidoUncheckedCreateWithoutMeseroInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutMeseroInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutMeseroInput, PedidoUncheckedUpdateWithoutMeseroInput>
  }

  export type PedidoUpdateManyWithWhereWithoutMeseroInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutEncargosInput>
  }

  export type PerfilUpsertWithoutUsuariosInput = {
    update: XOR<PerfilUpdateWithoutUsuariosInput, PerfilUncheckedUpdateWithoutUsuariosInput>
    create: XOR<PerfilCreateWithoutUsuariosInput, PerfilUncheckedCreateWithoutUsuariosInput>
  }

  export type PerfilUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PerfilUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type SucursalUpsertWithWhereUniqueWithoutMeserosInput = {
    where: SucursalWhereUniqueInput
    update: XOR<SucursalUpdateWithoutMeserosInput, SucursalUncheckedUpdateWithoutMeserosInput>
    create: XOR<SucursalCreateWithoutMeserosInput, SucursalUncheckedCreateWithoutMeserosInput>
  }

  export type SucursalUpdateWithWhereUniqueWithoutMeserosInput = {
    where: SucursalWhereUniqueInput
    data: XOR<SucursalUpdateWithoutMeserosInput, SucursalUncheckedUpdateWithoutMeserosInput>
  }

  export type SucursalUpdateManyWithWhereWithoutMeserosInput = {
    where: SucursalScalarWhereInput
    data: XOR<SucursalUpdateManyMutationInput, SucursalUncheckedUpdateManyWithoutSucursalesInput>
  }

  export type SucursalScalarWhereInput = {
    AND?: Enumerable<SucursalScalarWhereInput>
    OR?: Enumerable<SucursalScalarWhereInput>
    NOT?: Enumerable<SucursalScalarWhereInput>
    id?: IntFilter | number
    codigo?: StringFilter | string
    nombre?: StringFilter | string
    ubicacion?: StringFilter | string
    capacidad?: IntFilter | number
  }

  export type MesaCreateWithoutSucursalInput = {
    codigo: string
    capacidad: number
    estado?: boolean
    reservaciones?: ReservacionCreateNestedManyWithoutMesasInput
    pedidos?: PedidoCreateNestedManyWithoutMesaInput
    EstadoMesa?: DisponibilidadMesaCreateNestedOneWithoutMesasInput
  }

  export type MesaUncheckedCreateWithoutSucursalInput = {
    id?: number
    codigo: string
    capacidad: number
    estado?: boolean
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutMesasInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutMesaInput
    idDisponibilidad?: number
  }

  export type MesaCreateOrConnectWithoutSucursalInput = {
    where: MesaWhereUniqueInput
    create: XOR<MesaCreateWithoutSucursalInput, MesaUncheckedCreateWithoutSucursalInput>
  }

  export type MesaCreateManySucursalInputEnvelope = {
    data: Enumerable<MesaCreateManySucursalInput>
    skipDuplicates?: boolean
  }

  export type ReservacionCreateWithoutSucursalInput = {
    fecha_hora?: Date | string
    cantidad: number
    mesas?: MesaCreateNestedManyWithoutReservacionesInput
    Usuario: UsuarioCreateNestedOneWithoutReservacionesInput
  }

  export type ReservacionUncheckedCreateWithoutSucursalInput = {
    id?: number
    fecha_hora?: Date | string
    cantidad: number
    mesas?: MesaUncheckedCreateNestedManyWithoutReservacionesInput
    idUsuario: string
  }

  export type ReservacionCreateOrConnectWithoutSucursalInput = {
    where: ReservacionWhereUniqueInput
    create: XOR<ReservacionCreateWithoutSucursalInput, ReservacionUncheckedCreateWithoutSucursalInput>
  }

  export type ReservacionCreateManySucursalInputEnvelope = {
    data: Enumerable<ReservacionCreateManySucursalInput>
    skipDuplicates?: boolean
  }

  export type ProductoCreateWithoutSucursalesInput = {
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    Categoria_Producto: Categoria_ProductoCreateNestedOneWithoutProductosInput
    detalles?: Factura_DetalleCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutSucursalesInput = {
    id?: number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    idCategoria: number
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutSucursalesInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutSucursalesInput, ProductoUncheckedCreateWithoutSucursalesInput>
  }

  export type UsuarioCreateWithoutSucursalesInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
    encargos?: PedidoCreateNestedManyWithoutMeseroInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioUncheckedCreateWithoutSucursalesInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
    encargos?: PedidoUncheckedCreateNestedManyWithoutMeseroInput
    idPerfil: number
  }

  export type UsuarioCreateOrConnectWithoutSucursalesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutSucursalesInput, UsuarioUncheckedCreateWithoutSucursalesInput>
  }

  export type PedidoCreateWithoutSucursalInput = {
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoCreateNestedManyWithoutPedidoInput
    EstadoPedido: EstadoPedidoCreateNestedOneWithoutPedidosInput
    Cliente: UsuarioCreateNestedOneWithoutPedidosInput
    Mesero?: UsuarioCreateNestedOneWithoutEncargosInput
    Mesa?: MesaCreateNestedOneWithoutPedidosInput
    TipoPedido: TipoPedidoCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutSucursalInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput
    idEstado: number
    idCliente: string
    idMesero?: string | null
    idMesa?: number | null
    idTipoPedido: number
  }

  export type PedidoCreateOrConnectWithoutSucursalInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutSucursalInput, PedidoUncheckedCreateWithoutSucursalInput>
  }

  export type PedidoCreateManySucursalInputEnvelope = {
    data: Enumerable<PedidoCreateManySucursalInput>
    skipDuplicates?: boolean
  }

  export type MesaUpsertWithWhereUniqueWithoutSucursalInput = {
    where: MesaWhereUniqueInput
    update: XOR<MesaUpdateWithoutSucursalInput, MesaUncheckedUpdateWithoutSucursalInput>
    create: XOR<MesaCreateWithoutSucursalInput, MesaUncheckedCreateWithoutSucursalInput>
  }

  export type MesaUpdateWithWhereUniqueWithoutSucursalInput = {
    where: MesaWhereUniqueInput
    data: XOR<MesaUpdateWithoutSucursalInput, MesaUncheckedUpdateWithoutSucursalInput>
  }

  export type MesaUpdateManyWithWhereWithoutSucursalInput = {
    where: MesaScalarWhereInput
    data: XOR<MesaUpdateManyMutationInput, MesaUncheckedUpdateManyWithoutMesasInput>
  }

  export type MesaScalarWhereInput = {
    AND?: Enumerable<MesaScalarWhereInput>
    OR?: Enumerable<MesaScalarWhereInput>
    NOT?: Enumerable<MesaScalarWhereInput>
    id?: IntFilter | number
    codigo?: StringFilter | string
    capacidad?: IntFilter | number
    estado?: BoolFilter | boolean
    idSucursal?: IntFilter | number
    idDisponibilidad?: IntFilter | number
  }

  export type ReservacionUpsertWithWhereUniqueWithoutSucursalInput = {
    where: ReservacionWhereUniqueInput
    update: XOR<ReservacionUpdateWithoutSucursalInput, ReservacionUncheckedUpdateWithoutSucursalInput>
    create: XOR<ReservacionCreateWithoutSucursalInput, ReservacionUncheckedCreateWithoutSucursalInput>
  }

  export type ReservacionUpdateWithWhereUniqueWithoutSucursalInput = {
    where: ReservacionWhereUniqueInput
    data: XOR<ReservacionUpdateWithoutSucursalInput, ReservacionUncheckedUpdateWithoutSucursalInput>
  }

  export type ReservacionUpdateManyWithWhereWithoutSucursalInput = {
    where: ReservacionScalarWhereInput
    data: XOR<ReservacionUpdateManyMutationInput, ReservacionUncheckedUpdateManyWithoutReservacionesInput>
  }

  export type ProductoUpsertWithWhereUniqueWithoutSucursalesInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutSucursalesInput, ProductoUncheckedUpdateWithoutSucursalesInput>
    create: XOR<ProductoCreateWithoutSucursalesInput, ProductoUncheckedCreateWithoutSucursalesInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutSucursalesInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutSucursalesInput, ProductoUncheckedUpdateWithoutSucursalesInput>
  }

  export type ProductoUpdateManyWithWhereWithoutSucursalesInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutProductosInput>
  }

  export type ProductoScalarWhereInput = {
    AND?: Enumerable<ProductoScalarWhereInput>
    OR?: Enumerable<ProductoScalarWhereInput>
    NOT?: Enumerable<ProductoScalarWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    descripcion?: StringFilter | string
    ingredientes?: StringNullableFilter | string | null
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    imagen?: StringFilter | string
    estado?: BoolFilter | boolean
    idCategoria?: IntFilter | number
  }

  export type UsuarioUpsertWithWhereUniqueWithoutSucursalesInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutSucursalesInput, UsuarioUncheckedUpdateWithoutSucursalesInput>
    create: XOR<UsuarioCreateWithoutSucursalesInput, UsuarioUncheckedCreateWithoutSucursalesInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutSucursalesInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutSucursalesInput, UsuarioUncheckedUpdateWithoutSucursalesInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutSucursalesInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutMeserosInput>
  }

  export type PedidoUpsertWithWhereUniqueWithoutSucursalInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutSucursalInput, PedidoUncheckedUpdateWithoutSucursalInput>
    create: XOR<PedidoCreateWithoutSucursalInput, PedidoUncheckedCreateWithoutSucursalInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutSucursalInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutSucursalInput, PedidoUncheckedUpdateWithoutSucursalInput>
  }

  export type PedidoUpdateManyWithWhereWithoutSucursalInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type ReservacionCreateWithoutMesasInput = {
    fecha_hora?: Date | string
    cantidad: number
    Sucursal: SucursalCreateNestedOneWithoutReservacionesInput
    Usuario: UsuarioCreateNestedOneWithoutReservacionesInput
  }

  export type ReservacionUncheckedCreateWithoutMesasInput = {
    id?: number
    fecha_hora?: Date | string
    cantidad: number
    idSucursal: number
    idUsuario: string
  }

  export type ReservacionCreateOrConnectWithoutMesasInput = {
    where: ReservacionWhereUniqueInput
    create: XOR<ReservacionCreateWithoutMesasInput, ReservacionUncheckedCreateWithoutMesasInput>
  }

  export type PedidoCreateWithoutMesaInput = {
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoCreateNestedManyWithoutPedidoInput
    EstadoPedido: EstadoPedidoCreateNestedOneWithoutPedidosInput
    Cliente: UsuarioCreateNestedOneWithoutPedidosInput
    Mesero?: UsuarioCreateNestedOneWithoutEncargosInput
    Sucursal: SucursalCreateNestedOneWithoutPedidosInput
    TipoPedido: TipoPedidoCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutMesaInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput
    idEstado: number
    idCliente: string
    idMesero?: string | null
    idSucursal: number
    idTipoPedido: number
  }

  export type PedidoCreateOrConnectWithoutMesaInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutMesaInput, PedidoUncheckedCreateWithoutMesaInput>
  }

  export type PedidoCreateManyMesaInputEnvelope = {
    data: Enumerable<PedidoCreateManyMesaInput>
    skipDuplicates?: boolean
  }

  export type SucursalCreateWithoutMesasInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    reservaciones?: ReservacionCreateNestedManyWithoutSucursalInput
    productos?: ProductoCreateNestedManyWithoutSucursalesInput
    meseros?: UsuarioCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateWithoutMesasInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutSucursalInput
    productos?: ProductoUncheckedCreateNestedManyWithoutSucursalesInput
    meseros?: UsuarioUncheckedCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalCreateOrConnectWithoutMesasInput = {
    where: SucursalWhereUniqueInput
    create: XOR<SucursalCreateWithoutMesasInput, SucursalUncheckedCreateWithoutMesasInput>
  }

  export type DisponibilidadMesaCreateWithoutMesasInput = {
    id: number
    descripcion: string
  }

  export type DisponibilidadMesaUncheckedCreateWithoutMesasInput = {
    id: number
    descripcion: string
  }

  export type DisponibilidadMesaCreateOrConnectWithoutMesasInput = {
    where: DisponibilidadMesaWhereUniqueInput
    create: XOR<DisponibilidadMesaCreateWithoutMesasInput, DisponibilidadMesaUncheckedCreateWithoutMesasInput>
  }

  export type ReservacionUpsertWithWhereUniqueWithoutMesasInput = {
    where: ReservacionWhereUniqueInput
    update: XOR<ReservacionUpdateWithoutMesasInput, ReservacionUncheckedUpdateWithoutMesasInput>
    create: XOR<ReservacionCreateWithoutMesasInput, ReservacionUncheckedCreateWithoutMesasInput>
  }

  export type ReservacionUpdateWithWhereUniqueWithoutMesasInput = {
    where: ReservacionWhereUniqueInput
    data: XOR<ReservacionUpdateWithoutMesasInput, ReservacionUncheckedUpdateWithoutMesasInput>
  }

  export type ReservacionUpdateManyWithWhereWithoutMesasInput = {
    where: ReservacionScalarWhereInput
    data: XOR<ReservacionUpdateManyMutationInput, ReservacionUncheckedUpdateManyWithoutReservacionesInput>
  }

  export type PedidoUpsertWithWhereUniqueWithoutMesaInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutMesaInput, PedidoUncheckedUpdateWithoutMesaInput>
    create: XOR<PedidoCreateWithoutMesaInput, PedidoUncheckedCreateWithoutMesaInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutMesaInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutMesaInput, PedidoUncheckedUpdateWithoutMesaInput>
  }

  export type PedidoUpdateManyWithWhereWithoutMesaInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type SucursalUpsertWithoutMesasInput = {
    update: XOR<SucursalUpdateWithoutMesasInput, SucursalUncheckedUpdateWithoutMesasInput>
    create: XOR<SucursalCreateWithoutMesasInput, SucursalUncheckedCreateWithoutMesasInput>
  }

  export type SucursalUpdateWithoutMesasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    reservaciones?: ReservacionUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUpdateManyWithoutSucursalesNestedInput
    meseros?: UsuarioUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateWithoutMesasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    reservaciones?: ReservacionUncheckedUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutSucursalesNestedInput
    meseros?: UsuarioUncheckedUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type DisponibilidadMesaUpsertWithoutMesasInput = {
    update: XOR<DisponibilidadMesaUpdateWithoutMesasInput, DisponibilidadMesaUncheckedUpdateWithoutMesasInput>
    create: XOR<DisponibilidadMesaCreateWithoutMesasInput, DisponibilidadMesaUncheckedCreateWithoutMesasInput>
  }

  export type DisponibilidadMesaUpdateWithoutMesasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type DisponibilidadMesaUncheckedUpdateWithoutMesasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type MesaCreateWithoutEstadoMesaInput = {
    codigo: string
    capacidad: number
    estado?: boolean
    reservaciones?: ReservacionCreateNestedManyWithoutMesasInput
    pedidos?: PedidoCreateNestedManyWithoutMesaInput
    Sucursal: SucursalCreateNestedOneWithoutMesasInput
  }

  export type MesaUncheckedCreateWithoutEstadoMesaInput = {
    id?: number
    codigo: string
    capacidad: number
    estado?: boolean
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutMesasInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutMesaInput
    idSucursal: number
  }

  export type MesaCreateOrConnectWithoutEstadoMesaInput = {
    where: MesaWhereUniqueInput
    create: XOR<MesaCreateWithoutEstadoMesaInput, MesaUncheckedCreateWithoutEstadoMesaInput>
  }

  export type MesaCreateManyEstadoMesaInputEnvelope = {
    data: Enumerable<MesaCreateManyEstadoMesaInput>
    skipDuplicates?: boolean
  }

  export type MesaUpsertWithWhereUniqueWithoutEstadoMesaInput = {
    where: MesaWhereUniqueInput
    update: XOR<MesaUpdateWithoutEstadoMesaInput, MesaUncheckedUpdateWithoutEstadoMesaInput>
    create: XOR<MesaCreateWithoutEstadoMesaInput, MesaUncheckedCreateWithoutEstadoMesaInput>
  }

  export type MesaUpdateWithWhereUniqueWithoutEstadoMesaInput = {
    where: MesaWhereUniqueInput
    data: XOR<MesaUpdateWithoutEstadoMesaInput, MesaUncheckedUpdateWithoutEstadoMesaInput>
  }

  export type MesaUpdateManyWithWhereWithoutEstadoMesaInput = {
    where: MesaScalarWhereInput
    data: XOR<MesaUpdateManyMutationInput, MesaUncheckedUpdateManyWithoutMesasInput>
  }

  export type MesaCreateWithoutReservacionesInput = {
    codigo: string
    capacidad: number
    estado?: boolean
    pedidos?: PedidoCreateNestedManyWithoutMesaInput
    Sucursal: SucursalCreateNestedOneWithoutMesasInput
    EstadoMesa?: DisponibilidadMesaCreateNestedOneWithoutMesasInput
  }

  export type MesaUncheckedCreateWithoutReservacionesInput = {
    id?: number
    codigo: string
    capacidad: number
    estado?: boolean
    pedidos?: PedidoUncheckedCreateNestedManyWithoutMesaInput
    idSucursal: number
    idDisponibilidad?: number
  }

  export type MesaCreateOrConnectWithoutReservacionesInput = {
    where: MesaWhereUniqueInput
    create: XOR<MesaCreateWithoutReservacionesInput, MesaUncheckedCreateWithoutReservacionesInput>
  }

  export type SucursalCreateWithoutReservacionesInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaCreateNestedManyWithoutSucursalInput
    productos?: ProductoCreateNestedManyWithoutSucursalesInput
    meseros?: UsuarioCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateWithoutReservacionesInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaUncheckedCreateNestedManyWithoutSucursalInput
    productos?: ProductoUncheckedCreateNestedManyWithoutSucursalesInput
    meseros?: UsuarioUncheckedCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalCreateOrConnectWithoutReservacionesInput = {
    where: SucursalWhereUniqueInput
    create: XOR<SucursalCreateWithoutReservacionesInput, SucursalUncheckedCreateWithoutReservacionesInput>
  }

  export type UsuarioCreateWithoutReservacionesInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
    encargos?: PedidoCreateNestedManyWithoutMeseroInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
    sucursales?: SucursalCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioUncheckedCreateWithoutReservacionesInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
    encargos?: PedidoUncheckedCreateNestedManyWithoutMeseroInput
    idPerfil: number
    sucursales?: SucursalUncheckedCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioCreateOrConnectWithoutReservacionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutReservacionesInput, UsuarioUncheckedCreateWithoutReservacionesInput>
  }

  export type MesaUpsertWithWhereUniqueWithoutReservacionesInput = {
    where: MesaWhereUniqueInput
    update: XOR<MesaUpdateWithoutReservacionesInput, MesaUncheckedUpdateWithoutReservacionesInput>
    create: XOR<MesaCreateWithoutReservacionesInput, MesaUncheckedCreateWithoutReservacionesInput>
  }

  export type MesaUpdateWithWhereUniqueWithoutReservacionesInput = {
    where: MesaWhereUniqueInput
    data: XOR<MesaUpdateWithoutReservacionesInput, MesaUncheckedUpdateWithoutReservacionesInput>
  }

  export type MesaUpdateManyWithWhereWithoutReservacionesInput = {
    where: MesaScalarWhereInput
    data: XOR<MesaUpdateManyMutationInput, MesaUncheckedUpdateManyWithoutMesasInput>
  }

  export type SucursalUpsertWithoutReservacionesInput = {
    update: XOR<SucursalUpdateWithoutReservacionesInput, SucursalUncheckedUpdateWithoutReservacionesInput>
    create: XOR<SucursalCreateWithoutReservacionesInput, SucursalUncheckedCreateWithoutReservacionesInput>
  }

  export type SucursalUpdateWithoutReservacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUpdateManyWithoutSucursalesNestedInput
    meseros?: UsuarioUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateWithoutReservacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUncheckedUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutSucursalesNestedInput
    meseros?: UsuarioUncheckedUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type UsuarioUpsertWithoutReservacionesInput = {
    update: XOR<UsuarioUpdateWithoutReservacionesInput, UsuarioUncheckedUpdateWithoutReservacionesInput>
    create: XOR<UsuarioCreateWithoutReservacionesInput, UsuarioUncheckedCreateWithoutReservacionesInput>
  }

  export type UsuarioUpdateWithoutReservacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUpdateManyWithoutMeseroNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
    sucursales?: SucursalUpdateManyWithoutMeserosNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutReservacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUncheckedUpdateManyWithoutMeseroNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
    sucursales?: SucursalUncheckedUpdateManyWithoutMeserosNestedInput
  }

  export type ProductoCreateWithoutCategoria_ProductoInput = {
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    detalles?: Factura_DetalleCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoCreateNestedManyWithoutProductoInput
    sucursales?: SucursalCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutCategoria_ProductoInput = {
    id?: number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput
    pedidos?: Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput
    sucursales?: SucursalUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoCreateOrConnectWithoutCategoria_ProductoInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutCategoria_ProductoInput, ProductoUncheckedCreateWithoutCategoria_ProductoInput>
  }

  export type ProductoCreateManyCategoria_ProductoInputEnvelope = {
    data: Enumerable<ProductoCreateManyCategoria_ProductoInput>
    skipDuplicates?: boolean
  }

  export type ProductoUpsertWithWhereUniqueWithoutCategoria_ProductoInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutCategoria_ProductoInput, ProductoUncheckedUpdateWithoutCategoria_ProductoInput>
    create: XOR<ProductoCreateWithoutCategoria_ProductoInput, ProductoUncheckedCreateWithoutCategoria_ProductoInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutCategoria_ProductoInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutCategoria_ProductoInput, ProductoUncheckedUpdateWithoutCategoria_ProductoInput>
  }

  export type ProductoUpdateManyWithWhereWithoutCategoria_ProductoInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutProductosInput>
  }

  export type Categoria_ProductoCreateWithoutProductosInput = {
    id: number
    descripcion: string
  }

  export type Categoria_ProductoUncheckedCreateWithoutProductosInput = {
    id: number
    descripcion: string
  }

  export type Categoria_ProductoCreateOrConnectWithoutProductosInput = {
    where: Categoria_ProductoWhereUniqueInput
    create: XOR<Categoria_ProductoCreateWithoutProductosInput, Categoria_ProductoUncheckedCreateWithoutProductosInput>
  }

  export type Factura_DetalleCreateWithoutProductoInput = {
    id?: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    Factura_Encabezado: Factura_EncabezadoCreateNestedOneWithoutDetallesInput
  }

  export type Factura_DetalleUncheckedCreateWithoutProductoInput = {
    id?: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idFactura_Encabezado: number
  }

  export type Factura_DetalleCreateOrConnectWithoutProductoInput = {
    where: Factura_DetalleWhereUniqueInput
    create: XOR<Factura_DetalleCreateWithoutProductoInput, Factura_DetalleUncheckedCreateWithoutProductoInput>
  }

  export type Factura_DetalleCreateManyProductoInputEnvelope = {
    data: Enumerable<Factura_DetalleCreateManyProductoInput>
    skipDuplicates?: boolean
  }

  export type Pedido_ProductoCreateWithoutProductoInput = {
    Pedido: PedidoCreateNestedOneWithoutDetallesInput
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUncheckedCreateWithoutProductoInput = {
    idPedido: number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoCreateOrConnectWithoutProductoInput = {
    where: Pedido_ProductoWhereUniqueInput
    create: XOR<Pedido_ProductoCreateWithoutProductoInput, Pedido_ProductoUncheckedCreateWithoutProductoInput>
  }

  export type Pedido_ProductoCreateManyProductoInputEnvelope = {
    data: Enumerable<Pedido_ProductoCreateManyProductoInput>
    skipDuplicates?: boolean
  }

  export type SucursalCreateWithoutProductosInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionCreateNestedManyWithoutSucursalInput
    meseros?: UsuarioCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoCreateNestedManyWithoutSucursalInput
  }

  export type SucursalUncheckedCreateWithoutProductosInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaUncheckedCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutSucursalInput
    meseros?: UsuarioUncheckedCreateNestedManyWithoutSucursalesInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type SucursalCreateOrConnectWithoutProductosInput = {
    where: SucursalWhereUniqueInput
    create: XOR<SucursalCreateWithoutProductosInput, SucursalUncheckedCreateWithoutProductosInput>
  }

  export type Categoria_ProductoUpsertWithoutProductosInput = {
    update: XOR<Categoria_ProductoUpdateWithoutProductosInput, Categoria_ProductoUncheckedUpdateWithoutProductosInput>
    create: XOR<Categoria_ProductoCreateWithoutProductosInput, Categoria_ProductoUncheckedCreateWithoutProductosInput>
  }

  export type Categoria_ProductoUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Categoria_ProductoUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_DetalleUpsertWithWhereUniqueWithoutProductoInput = {
    where: Factura_DetalleWhereUniqueInput
    update: XOR<Factura_DetalleUpdateWithoutProductoInput, Factura_DetalleUncheckedUpdateWithoutProductoInput>
    create: XOR<Factura_DetalleCreateWithoutProductoInput, Factura_DetalleUncheckedCreateWithoutProductoInput>
  }

  export type Factura_DetalleUpdateWithWhereUniqueWithoutProductoInput = {
    where: Factura_DetalleWhereUniqueInput
    data: XOR<Factura_DetalleUpdateWithoutProductoInput, Factura_DetalleUncheckedUpdateWithoutProductoInput>
  }

  export type Factura_DetalleUpdateManyWithWhereWithoutProductoInput = {
    where: Factura_DetalleScalarWhereInput
    data: XOR<Factura_DetalleUpdateManyMutationInput, Factura_DetalleUncheckedUpdateManyWithoutDetallesInput>
  }

  export type Factura_DetalleScalarWhereInput = {
    AND?: Enumerable<Factura_DetalleScalarWhereInput>
    OR?: Enumerable<Factura_DetalleScalarWhereInput>
    NOT?: Enumerable<Factura_DetalleScalarWhereInput>
    id?: IntFilter | number
    cantidad?: IntFilter | number
    precio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFilter | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFilter | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: IntFilter | number
    idProducto?: IntFilter | number
  }

  export type Pedido_ProductoUpsertWithWhereUniqueWithoutProductoInput = {
    where: Pedido_ProductoWhereUniqueInput
    update: XOR<Pedido_ProductoUpdateWithoutProductoInput, Pedido_ProductoUncheckedUpdateWithoutProductoInput>
    create: XOR<Pedido_ProductoCreateWithoutProductoInput, Pedido_ProductoUncheckedCreateWithoutProductoInput>
  }

  export type Pedido_ProductoUpdateWithWhereUniqueWithoutProductoInput = {
    where: Pedido_ProductoWhereUniqueInput
    data: XOR<Pedido_ProductoUpdateWithoutProductoInput, Pedido_ProductoUncheckedUpdateWithoutProductoInput>
  }

  export type Pedido_ProductoUpdateManyWithWhereWithoutProductoInput = {
    where: Pedido_ProductoScalarWhereInput
    data: XOR<Pedido_ProductoUpdateManyMutationInput, Pedido_ProductoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type Pedido_ProductoScalarWhereInput = {
    AND?: Enumerable<Pedido_ProductoScalarWhereInput>
    OR?: Enumerable<Pedido_ProductoScalarWhereInput>
    NOT?: Enumerable<Pedido_ProductoScalarWhereInput>
    idPedido?: IntFilter | number
    idProducto?: IntFilter | number
    cantidad?: IntFilter | number
    notas?: StringFilter | string
  }

  export type SucursalUpsertWithWhereUniqueWithoutProductosInput = {
    where: SucursalWhereUniqueInput
    update: XOR<SucursalUpdateWithoutProductosInput, SucursalUncheckedUpdateWithoutProductosInput>
    create: XOR<SucursalCreateWithoutProductosInput, SucursalUncheckedCreateWithoutProductosInput>
  }

  export type SucursalUpdateWithWhereUniqueWithoutProductosInput = {
    where: SucursalWhereUniqueInput
    data: XOR<SucursalUpdateWithoutProductosInput, SucursalUncheckedUpdateWithoutProductosInput>
  }

  export type SucursalUpdateManyWithWhereWithoutProductosInput = {
    where: SucursalScalarWhereInput
    data: XOR<SucursalUpdateManyMutationInput, SucursalUncheckedUpdateManyWithoutSucursalesInput>
  }

  export type FacturaEncabezadoTipoPagoCreateWithoutTipoPagoInput = {
    Factura_Encabezado: Factura_EncabezadoCreateNestedOneWithoutTipoPagosInput
    monto: Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUncheckedCreateWithoutTipoPagoInput = {
    idFactura_Encabezado: number
    monto: Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoCreateOrConnectWithoutTipoPagoInput = {
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
    create: XOR<FacturaEncabezadoTipoPagoCreateWithoutTipoPagoInput, FacturaEncabezadoTipoPagoUncheckedCreateWithoutTipoPagoInput>
  }

  export type FacturaEncabezadoTipoPagoCreateManyTipoPagoInputEnvelope = {
    data: Enumerable<FacturaEncabezadoTipoPagoCreateManyTipoPagoInput>
    skipDuplicates?: boolean
  }

  export type FacturaEncabezadoTipoPagoUpsertWithWhereUniqueWithoutTipoPagoInput = {
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
    update: XOR<FacturaEncabezadoTipoPagoUpdateWithoutTipoPagoInput, FacturaEncabezadoTipoPagoUncheckedUpdateWithoutTipoPagoInput>
    create: XOR<FacturaEncabezadoTipoPagoCreateWithoutTipoPagoInput, FacturaEncabezadoTipoPagoUncheckedCreateWithoutTipoPagoInput>
  }

  export type FacturaEncabezadoTipoPagoUpdateWithWhereUniqueWithoutTipoPagoInput = {
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
    data: XOR<FacturaEncabezadoTipoPagoUpdateWithoutTipoPagoInput, FacturaEncabezadoTipoPagoUncheckedUpdateWithoutTipoPagoInput>
  }

  export type FacturaEncabezadoTipoPagoUpdateManyWithWhereWithoutTipoPagoInput = {
    where: FacturaEncabezadoTipoPagoScalarWhereInput
    data: XOR<FacturaEncabezadoTipoPagoUpdateManyMutationInput, FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutFacturasEncabezadoInput>
  }

  export type FacturaEncabezadoTipoPagoScalarWhereInput = {
    AND?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereInput>
    OR?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereInput>
    NOT?: Enumerable<FacturaEncabezadoTipoPagoScalarWhereInput>
    idFactura_Encabezado?: IntFilter | number
    idTipoPago?: IntFilter | number
    monto?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type Factura_EncabezadoCreateWithoutTipoTarjetaInput = {
    numero_tarjeta?: string | null
    fecha?: Date | string
    estado?: boolean
    detalles?: Factura_DetalleCreateNestedManyWithoutFactura_EncabezadoInput
    tipoPagos?: FacturaEncabezadoTipoPagoCreateNestedManyWithoutFactura_EncabezadoInput
    Usuario: UsuarioCreateNestedOneWithoutFacturasInput
  }

  export type Factura_EncabezadoUncheckedCreateWithoutTipoTarjetaInput = {
    id?: number
    numero_tarjeta?: string | null
    fecha?: Date | string
    estado?: boolean
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    tipoPagos?: FacturaEncabezadoTipoPagoUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    idUsuario: string
  }

  export type Factura_EncabezadoCreateOrConnectWithoutTipoTarjetaInput = {
    where: Factura_EncabezadoWhereUniqueInput
    create: XOR<Factura_EncabezadoCreateWithoutTipoTarjetaInput, Factura_EncabezadoUncheckedCreateWithoutTipoTarjetaInput>
  }

  export type Factura_EncabezadoCreateManyTipoTarjetaInputEnvelope = {
    data: Enumerable<Factura_EncabezadoCreateManyTipoTarjetaInput>
    skipDuplicates?: boolean
  }

  export type Factura_EncabezadoUpsertWithWhereUniqueWithoutTipoTarjetaInput = {
    where: Factura_EncabezadoWhereUniqueInput
    update: XOR<Factura_EncabezadoUpdateWithoutTipoTarjetaInput, Factura_EncabezadoUncheckedUpdateWithoutTipoTarjetaInput>
    create: XOR<Factura_EncabezadoCreateWithoutTipoTarjetaInput, Factura_EncabezadoUncheckedCreateWithoutTipoTarjetaInput>
  }

  export type Factura_EncabezadoUpdateWithWhereUniqueWithoutTipoTarjetaInput = {
    where: Factura_EncabezadoWhereUniqueInput
    data: XOR<Factura_EncabezadoUpdateWithoutTipoTarjetaInput, Factura_EncabezadoUncheckedUpdateWithoutTipoTarjetaInput>
  }

  export type Factura_EncabezadoUpdateManyWithWhereWithoutTipoTarjetaInput = {
    where: Factura_EncabezadoScalarWhereInput
    data: XOR<Factura_EncabezadoUpdateManyMutationInput, Factura_EncabezadoUncheckedUpdateManyWithoutFacturasInput>
  }

  export type TipoTarjetaCreateWithoutFacturasInput = {
    id: number
    descripcion: string
  }

  export type TipoTarjetaUncheckedCreateWithoutFacturasInput = {
    id: number
    descripcion: string
  }

  export type TipoTarjetaCreateOrConnectWithoutFacturasInput = {
    where: TipoTarjetaWhereUniqueInput
    create: XOR<TipoTarjetaCreateWithoutFacturasInput, TipoTarjetaUncheckedCreateWithoutFacturasInput>
  }

  export type Factura_DetalleCreateWithoutFactura_EncabezadoInput = {
    id?: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    Producto: ProductoCreateNestedOneWithoutDetallesInput
  }

  export type Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput = {
    id?: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idProducto: number
  }

  export type Factura_DetalleCreateOrConnectWithoutFactura_EncabezadoInput = {
    where: Factura_DetalleWhereUniqueInput
    create: XOR<Factura_DetalleCreateWithoutFactura_EncabezadoInput, Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>
  }

  export type Factura_DetalleCreateManyFactura_EncabezadoInputEnvelope = {
    data: Enumerable<Factura_DetalleCreateManyFactura_EncabezadoInput>
    skipDuplicates?: boolean
  }

  export type FacturaEncabezadoTipoPagoCreateWithoutFactura_EncabezadoInput = {
    TipoPago: TipoPagoCreateNestedOneWithoutFacturasEncabezadoInput
    monto: Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUncheckedCreateWithoutFactura_EncabezadoInput = {
    idTipoPago: number
    monto: Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoCreateOrConnectWithoutFactura_EncabezadoInput = {
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
    create: XOR<FacturaEncabezadoTipoPagoCreateWithoutFactura_EncabezadoInput, FacturaEncabezadoTipoPagoUncheckedCreateWithoutFactura_EncabezadoInput>
  }

  export type FacturaEncabezadoTipoPagoCreateManyFactura_EncabezadoInputEnvelope = {
    data: Enumerable<FacturaEncabezadoTipoPagoCreateManyFactura_EncabezadoInput>
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutFacturasInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
    encargos?: PedidoCreateNestedManyWithoutMeseroInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
    sucursales?: SucursalCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioUncheckedCreateWithoutFacturasInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
    encargos?: PedidoUncheckedCreateNestedManyWithoutMeseroInput
    idPerfil: number
    sucursales?: SucursalUncheckedCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioCreateOrConnectWithoutFacturasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutFacturasInput, UsuarioUncheckedCreateWithoutFacturasInput>
  }

  export type TipoTarjetaUpsertWithoutFacturasInput = {
    update: XOR<TipoTarjetaUpdateWithoutFacturasInput, TipoTarjetaUncheckedUpdateWithoutFacturasInput>
    create: XOR<TipoTarjetaCreateWithoutFacturasInput, TipoTarjetaUncheckedCreateWithoutFacturasInput>
  }

  export type TipoTarjetaUpdateWithoutFacturasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoTarjetaUncheckedUpdateWithoutFacturasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_DetalleUpsertWithWhereUniqueWithoutFactura_EncabezadoInput = {
    where: Factura_DetalleWhereUniqueInput
    update: XOR<Factura_DetalleUpdateWithoutFactura_EncabezadoInput, Factura_DetalleUncheckedUpdateWithoutFactura_EncabezadoInput>
    create: XOR<Factura_DetalleCreateWithoutFactura_EncabezadoInput, Factura_DetalleUncheckedCreateWithoutFactura_EncabezadoInput>
  }

  export type Factura_DetalleUpdateWithWhereUniqueWithoutFactura_EncabezadoInput = {
    where: Factura_DetalleWhereUniqueInput
    data: XOR<Factura_DetalleUpdateWithoutFactura_EncabezadoInput, Factura_DetalleUncheckedUpdateWithoutFactura_EncabezadoInput>
  }

  export type Factura_DetalleUpdateManyWithWhereWithoutFactura_EncabezadoInput = {
    where: Factura_DetalleScalarWhereInput
    data: XOR<Factura_DetalleUpdateManyMutationInput, Factura_DetalleUncheckedUpdateManyWithoutDetallesInput>
  }

  export type FacturaEncabezadoTipoPagoUpsertWithWhereUniqueWithoutFactura_EncabezadoInput = {
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
    update: XOR<FacturaEncabezadoTipoPagoUpdateWithoutFactura_EncabezadoInput, FacturaEncabezadoTipoPagoUncheckedUpdateWithoutFactura_EncabezadoInput>
    create: XOR<FacturaEncabezadoTipoPagoCreateWithoutFactura_EncabezadoInput, FacturaEncabezadoTipoPagoUncheckedCreateWithoutFactura_EncabezadoInput>
  }

  export type FacturaEncabezadoTipoPagoUpdateWithWhereUniqueWithoutFactura_EncabezadoInput = {
    where: FacturaEncabezadoTipoPagoWhereUniqueInput
    data: XOR<FacturaEncabezadoTipoPagoUpdateWithoutFactura_EncabezadoInput, FacturaEncabezadoTipoPagoUncheckedUpdateWithoutFactura_EncabezadoInput>
  }

  export type FacturaEncabezadoTipoPagoUpdateManyWithWhereWithoutFactura_EncabezadoInput = {
    where: FacturaEncabezadoTipoPagoScalarWhereInput
    data: XOR<FacturaEncabezadoTipoPagoUpdateManyMutationInput, FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutTipoPagosInput>
  }

  export type UsuarioUpsertWithoutFacturasInput = {
    update: XOR<UsuarioUpdateWithoutFacturasInput, UsuarioUncheckedUpdateWithoutFacturasInput>
    create: XOR<UsuarioCreateWithoutFacturasInput, UsuarioUncheckedCreateWithoutFacturasInput>
  }

  export type UsuarioUpdateWithoutFacturasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUpdateManyWithoutMeseroNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
    sucursales?: SucursalUpdateManyWithoutMeserosNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutFacturasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUncheckedUpdateManyWithoutMeseroNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
    sucursales?: SucursalUncheckedUpdateManyWithoutMeserosNestedInput
  }

  export type Factura_EncabezadoCreateWithoutDetallesInput = {
    numero_tarjeta?: string | null
    TipoTarjeta?: TipoTarjetaCreateNestedOneWithoutFacturasInput
    fecha?: Date | string
    estado?: boolean
    tipoPagos?: FacturaEncabezadoTipoPagoCreateNestedManyWithoutFactura_EncabezadoInput
    Usuario: UsuarioCreateNestedOneWithoutFacturasInput
  }

  export type Factura_EncabezadoUncheckedCreateWithoutDetallesInput = {
    id?: number
    numero_tarjeta?: string | null
    idTipoTarjeta?: number | null
    fecha?: Date | string
    estado?: boolean
    tipoPagos?: FacturaEncabezadoTipoPagoUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    idUsuario: string
  }

  export type Factura_EncabezadoCreateOrConnectWithoutDetallesInput = {
    where: Factura_EncabezadoWhereUniqueInput
    create: XOR<Factura_EncabezadoCreateWithoutDetallesInput, Factura_EncabezadoUncheckedCreateWithoutDetallesInput>
  }

  export type ProductoCreateWithoutDetallesInput = {
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    Categoria_Producto: Categoria_ProductoCreateNestedOneWithoutProductosInput
    pedidos?: Pedido_ProductoCreateNestedManyWithoutProductoInput
    sucursales?: SucursalCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutDetallesInput = {
    id?: number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    idCategoria: number
    pedidos?: Pedido_ProductoUncheckedCreateNestedManyWithoutProductoInput
    sucursales?: SucursalUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoCreateOrConnectWithoutDetallesInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutDetallesInput, ProductoUncheckedCreateWithoutDetallesInput>
  }

  export type Factura_EncabezadoUpsertWithoutDetallesInput = {
    update: XOR<Factura_EncabezadoUpdateWithoutDetallesInput, Factura_EncabezadoUncheckedUpdateWithoutDetallesInput>
    create: XOR<Factura_EncabezadoCreateWithoutDetallesInput, Factura_EncabezadoUncheckedCreateWithoutDetallesInput>
  }

  export type Factura_EncabezadoUpdateWithoutDetallesInput = {
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    TipoTarjeta?: TipoTarjetaUpdateOneWithoutFacturasNestedInput
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    tipoPagos?: FacturaEncabezadoTipoPagoUpdateManyWithoutFactura_EncabezadoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateWithoutDetallesInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    idTipoTarjeta?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    tipoPagos?: FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoUpsertWithoutDetallesInput = {
    update: XOR<ProductoUpdateWithoutDetallesInput, ProductoUncheckedUpdateWithoutDetallesInput>
    create: XOR<ProductoCreateWithoutDetallesInput, ProductoUncheckedCreateWithoutDetallesInput>
  }

  export type ProductoUpdateWithoutDetallesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Categoria_Producto?: Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput
    pedidos?: Pedido_ProductoUpdateManyWithoutProductoNestedInput
    sucursales?: SucursalUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutDetallesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    pedidos?: Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput
    sucursales?: SucursalUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type Factura_EncabezadoCreateWithoutTipoPagosInput = {
    numero_tarjeta?: string | null
    TipoTarjeta?: TipoTarjetaCreateNestedOneWithoutFacturasInput
    fecha?: Date | string
    estado?: boolean
    detalles?: Factura_DetalleCreateNestedManyWithoutFactura_EncabezadoInput
    Usuario: UsuarioCreateNestedOneWithoutFacturasInput
  }

  export type Factura_EncabezadoUncheckedCreateWithoutTipoPagosInput = {
    id?: number
    numero_tarjeta?: string | null
    idTipoTarjeta?: number | null
    fecha?: Date | string
    estado?: boolean
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutFactura_EncabezadoInput
    idUsuario: string
  }

  export type Factura_EncabezadoCreateOrConnectWithoutTipoPagosInput = {
    where: Factura_EncabezadoWhereUniqueInput
    create: XOR<Factura_EncabezadoCreateWithoutTipoPagosInput, Factura_EncabezadoUncheckedCreateWithoutTipoPagosInput>
  }

  export type TipoPagoCreateWithoutFacturasEncabezadoInput = {
    id: number
    descripcion: string
  }

  export type TipoPagoUncheckedCreateWithoutFacturasEncabezadoInput = {
    id: number
    descripcion: string
  }

  export type TipoPagoCreateOrConnectWithoutFacturasEncabezadoInput = {
    where: TipoPagoWhereUniqueInput
    create: XOR<TipoPagoCreateWithoutFacturasEncabezadoInput, TipoPagoUncheckedCreateWithoutFacturasEncabezadoInput>
  }

  export type Factura_EncabezadoUpsertWithoutTipoPagosInput = {
    update: XOR<Factura_EncabezadoUpdateWithoutTipoPagosInput, Factura_EncabezadoUncheckedUpdateWithoutTipoPagosInput>
    create: XOR<Factura_EncabezadoCreateWithoutTipoPagosInput, Factura_EncabezadoUncheckedCreateWithoutTipoPagosInput>
  }

  export type Factura_EncabezadoUpdateWithoutTipoPagosInput = {
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    TipoTarjeta?: TipoTarjetaUpdateOneWithoutFacturasNestedInput
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUpdateManyWithoutFactura_EncabezadoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateWithoutTipoPagosInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    idTipoTarjeta?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type TipoPagoUpsertWithoutFacturasEncabezadoInput = {
    update: XOR<TipoPagoUpdateWithoutFacturasEncabezadoInput, TipoPagoUncheckedUpdateWithoutFacturasEncabezadoInput>
    create: XOR<TipoPagoCreateWithoutFacturasEncabezadoInput, TipoPagoUncheckedCreateWithoutFacturasEncabezadoInput>
  }

  export type TipoPagoUpdateWithoutFacturasEncabezadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoPagoUncheckedUpdateWithoutFacturasEncabezadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoCreateWithoutEstadoPedidoInput = {
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoCreateNestedManyWithoutPedidoInput
    Cliente: UsuarioCreateNestedOneWithoutPedidosInput
    Mesero?: UsuarioCreateNestedOneWithoutEncargosInput
    Sucursal: SucursalCreateNestedOneWithoutPedidosInput
    Mesa?: MesaCreateNestedOneWithoutPedidosInput
    TipoPedido: TipoPedidoCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutEstadoPedidoInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput
    idCliente: string
    idMesero?: string | null
    idSucursal: number
    idMesa?: number | null
    idTipoPedido: number
  }

  export type PedidoCreateOrConnectWithoutEstadoPedidoInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput>
  }

  export type PedidoCreateManyEstadoPedidoInputEnvelope = {
    data: Enumerable<PedidoCreateManyEstadoPedidoInput>
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithWhereUniqueWithoutEstadoPedidoInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutEstadoPedidoInput, PedidoUncheckedUpdateWithoutEstadoPedidoInput>
    create: XOR<PedidoCreateWithoutEstadoPedidoInput, PedidoUncheckedCreateWithoutEstadoPedidoInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutEstadoPedidoInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutEstadoPedidoInput, PedidoUncheckedUpdateWithoutEstadoPedidoInput>
  }

  export type PedidoUpdateManyWithWhereWithoutEstadoPedidoInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type PedidoCreateWithoutTipoPedidoInput = {
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoCreateNestedManyWithoutPedidoInput
    EstadoPedido: EstadoPedidoCreateNestedOneWithoutPedidosInput
    Cliente: UsuarioCreateNestedOneWithoutPedidosInput
    Mesero?: UsuarioCreateNestedOneWithoutEncargosInput
    Sucursal: SucursalCreateNestedOneWithoutPedidosInput
    Mesa?: MesaCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutTipoPedidoInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    detalles?: Pedido_ProductoUncheckedCreateNestedManyWithoutPedidoInput
    idEstado: number
    idCliente: string
    idMesero?: string | null
    idSucursal: number
    idMesa?: number | null
  }

  export type PedidoCreateOrConnectWithoutTipoPedidoInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutTipoPedidoInput, PedidoUncheckedCreateWithoutTipoPedidoInput>
  }

  export type PedidoCreateManyTipoPedidoInputEnvelope = {
    data: Enumerable<PedidoCreateManyTipoPedidoInput>
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithWhereUniqueWithoutTipoPedidoInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutTipoPedidoInput, PedidoUncheckedUpdateWithoutTipoPedidoInput>
    create: XOR<PedidoCreateWithoutTipoPedidoInput, PedidoUncheckedCreateWithoutTipoPedidoInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutTipoPedidoInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutTipoPedidoInput, PedidoUncheckedUpdateWithoutTipoPedidoInput>
  }

  export type PedidoUpdateManyWithWhereWithoutTipoPedidoInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type Pedido_ProductoCreateWithoutPedidoInput = {
    Producto: ProductoCreateNestedOneWithoutPedidosInput
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUncheckedCreateWithoutPedidoInput = {
    idProducto: number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoCreateOrConnectWithoutPedidoInput = {
    where: Pedido_ProductoWhereUniqueInput
    create: XOR<Pedido_ProductoCreateWithoutPedidoInput, Pedido_ProductoUncheckedCreateWithoutPedidoInput>
  }

  export type Pedido_ProductoCreateManyPedidoInputEnvelope = {
    data: Enumerable<Pedido_ProductoCreateManyPedidoInput>
    skipDuplicates?: boolean
  }

  export type EstadoPedidoCreateWithoutPedidosInput = {
    id: number
    descripcion: string
  }

  export type EstadoPedidoUncheckedCreateWithoutPedidosInput = {
    id: number
    descripcion: string
  }

  export type EstadoPedidoCreateOrConnectWithoutPedidosInput = {
    where: EstadoPedidoWhereUniqueInput
    create: XOR<EstadoPedidoCreateWithoutPedidosInput, EstadoPedidoUncheckedCreateWithoutPedidosInput>
  }

  export type UsuarioCreateWithoutPedidosInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    encargos?: PedidoCreateNestedManyWithoutMeseroInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
    sucursales?: SucursalCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioUncheckedCreateWithoutPedidosInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    encargos?: PedidoUncheckedCreateNestedManyWithoutMeseroInput
    idPerfil: number
    sucursales?: SucursalUncheckedCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioCreateOrConnectWithoutPedidosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type UsuarioCreateWithoutEncargosInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
    Perfil: PerfilCreateNestedOneWithoutUsuariosInput
    sucursales?: SucursalCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioUncheckedCreateWithoutEncargosInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutUsuarioInput
    facturas?: Factura_EncabezadoUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
    idPerfil: number
    sucursales?: SucursalUncheckedCreateNestedManyWithoutMeserosInput
  }

  export type UsuarioCreateOrConnectWithoutEncargosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEncargosInput, UsuarioUncheckedCreateWithoutEncargosInput>
  }

  export type SucursalCreateWithoutPedidosInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionCreateNestedManyWithoutSucursalInput
    productos?: ProductoCreateNestedManyWithoutSucursalesInput
    meseros?: UsuarioCreateNestedManyWithoutSucursalesInput
  }

  export type SucursalUncheckedCreateWithoutPedidosInput = {
    id: number
    codigo: string
    nombre: string
    ubicacion: string
    capacidad: number
    mesas?: MesaUncheckedCreateNestedManyWithoutSucursalInput
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutSucursalInput
    productos?: ProductoUncheckedCreateNestedManyWithoutSucursalesInput
    meseros?: UsuarioUncheckedCreateNestedManyWithoutSucursalesInput
  }

  export type SucursalCreateOrConnectWithoutPedidosInput = {
    where: SucursalWhereUniqueInput
    create: XOR<SucursalCreateWithoutPedidosInput, SucursalUncheckedCreateWithoutPedidosInput>
  }

  export type MesaCreateWithoutPedidosInput = {
    codigo: string
    capacidad: number
    estado?: boolean
    reservaciones?: ReservacionCreateNestedManyWithoutMesasInput
    Sucursal: SucursalCreateNestedOneWithoutMesasInput
    EstadoMesa?: DisponibilidadMesaCreateNestedOneWithoutMesasInput
  }

  export type MesaUncheckedCreateWithoutPedidosInput = {
    id?: number
    codigo: string
    capacidad: number
    estado?: boolean
    reservaciones?: ReservacionUncheckedCreateNestedManyWithoutMesasInput
    idSucursal: number
    idDisponibilidad?: number
  }

  export type MesaCreateOrConnectWithoutPedidosInput = {
    where: MesaWhereUniqueInput
    create: XOR<MesaCreateWithoutPedidosInput, MesaUncheckedCreateWithoutPedidosInput>
  }

  export type TipoPedidoCreateWithoutPedidosInput = {
    id: number
    descripcion: string
  }

  export type TipoPedidoUncheckedCreateWithoutPedidosInput = {
    id: number
    descripcion: string
  }

  export type TipoPedidoCreateOrConnectWithoutPedidosInput = {
    where: TipoPedidoWhereUniqueInput
    create: XOR<TipoPedidoCreateWithoutPedidosInput, TipoPedidoUncheckedCreateWithoutPedidosInput>
  }

  export type Pedido_ProductoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: Pedido_ProductoWhereUniqueInput
    update: XOR<Pedido_ProductoUpdateWithoutPedidoInput, Pedido_ProductoUncheckedUpdateWithoutPedidoInput>
    create: XOR<Pedido_ProductoCreateWithoutPedidoInput, Pedido_ProductoUncheckedCreateWithoutPedidoInput>
  }

  export type Pedido_ProductoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: Pedido_ProductoWhereUniqueInput
    data: XOR<Pedido_ProductoUpdateWithoutPedidoInput, Pedido_ProductoUncheckedUpdateWithoutPedidoInput>
  }

  export type Pedido_ProductoUpdateManyWithWhereWithoutPedidoInput = {
    where: Pedido_ProductoScalarWhereInput
    data: XOR<Pedido_ProductoUpdateManyMutationInput, Pedido_ProductoUncheckedUpdateManyWithoutDetallesInput>
  }

  export type EstadoPedidoUpsertWithoutPedidosInput = {
    update: XOR<EstadoPedidoUpdateWithoutPedidosInput, EstadoPedidoUncheckedUpdateWithoutPedidosInput>
    create: XOR<EstadoPedidoCreateWithoutPedidosInput, EstadoPedidoUncheckedCreateWithoutPedidosInput>
  }

  export type EstadoPedidoUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoPedidoUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUpsertWithoutPedidosInput = {
    update: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type UsuarioUpdateWithoutPedidosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    encargos?: PedidoUpdateManyWithoutMeseroNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
    sucursales?: SucursalUpdateManyWithoutMeserosNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPedidosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    encargos?: PedidoUncheckedUpdateManyWithoutMeseroNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
    sucursales?: SucursalUncheckedUpdateManyWithoutMeserosNestedInput
  }

  export type UsuarioUpsertWithoutEncargosInput = {
    update: XOR<UsuarioUpdateWithoutEncargosInput, UsuarioUncheckedUpdateWithoutEncargosInput>
    create: XOR<UsuarioCreateWithoutEncargosInput, UsuarioUncheckedCreateWithoutEncargosInput>
  }

  export type UsuarioUpdateWithoutEncargosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
    sucursales?: SucursalUpdateManyWithoutMeserosNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEncargosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
    sucursales?: SucursalUncheckedUpdateManyWithoutMeserosNestedInput
  }

  export type SucursalUpsertWithoutPedidosInput = {
    update: XOR<SucursalUpdateWithoutPedidosInput, SucursalUncheckedUpdateWithoutPedidosInput>
    create: XOR<SucursalCreateWithoutPedidosInput, SucursalUncheckedCreateWithoutPedidosInput>
  }

  export type SucursalUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUpdateManyWithoutSucursalesNestedInput
    meseros?: UsuarioUpdateManyWithoutSucursalesNestedInput
  }

  export type SucursalUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUncheckedUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUncheckedUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutSucursalesNestedInput
    meseros?: UsuarioUncheckedUpdateManyWithoutSucursalesNestedInput
  }

  export type MesaUpsertWithoutPedidosInput = {
    update: XOR<MesaUpdateWithoutPedidosInput, MesaUncheckedUpdateWithoutPedidosInput>
    create: XOR<MesaCreateWithoutPedidosInput, MesaUncheckedCreateWithoutPedidosInput>
  }

  export type MesaUpdateWithoutPedidosInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: ReservacionUpdateManyWithoutMesasNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutMesasNestedInput
    EstadoMesa?: DisponibilidadMesaUpdateOneRequiredWithoutMesasNestedInput
  }

  export type MesaUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: ReservacionUncheckedUpdateManyWithoutMesasNestedInput
    idSucursal?: IntFieldUpdateOperationsInput | number
    idDisponibilidad?: IntFieldUpdateOperationsInput | number
  }

  export type TipoPedidoUpsertWithoutPedidosInput = {
    update: XOR<TipoPedidoUpdateWithoutPedidosInput, TipoPedidoUncheckedUpdateWithoutPedidosInput>
    create: XOR<TipoPedidoCreateWithoutPedidosInput, TipoPedidoUncheckedCreateWithoutPedidosInput>
  }

  export type TipoPedidoUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoPedidoUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoCreateWithoutDetallesInput = {
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    EstadoPedido: EstadoPedidoCreateNestedOneWithoutPedidosInput
    Cliente: UsuarioCreateNestedOneWithoutPedidosInput
    Mesero?: UsuarioCreateNestedOneWithoutEncargosInput
    Sucursal: SucursalCreateNestedOneWithoutPedidosInput
    Mesa?: MesaCreateNestedOneWithoutPedidosInput
    TipoPedido: TipoPedidoCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutDetallesInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    idEstado: number
    idCliente: string
    idMesero?: string | null
    idSucursal: number
    idMesa?: number | null
    idTipoPedido: number
  }

  export type PedidoCreateOrConnectWithoutDetallesInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutDetallesInput, PedidoUncheckedCreateWithoutDetallesInput>
  }

  export type ProductoCreateWithoutPedidosInput = {
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    Categoria_Producto: Categoria_ProductoCreateNestedOneWithoutProductosInput
    detalles?: Factura_DetalleCreateNestedManyWithoutProductoInput
    sucursales?: SucursalCreateNestedManyWithoutProductosInput
  }

  export type ProductoUncheckedCreateWithoutPedidosInput = {
    id?: number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
    idCategoria: number
    detalles?: Factura_DetalleUncheckedCreateNestedManyWithoutProductoInput
    sucursales?: SucursalUncheckedCreateNestedManyWithoutProductosInput
  }

  export type ProductoCreateOrConnectWithoutPedidosInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutPedidosInput, ProductoUncheckedCreateWithoutPedidosInput>
  }

  export type PedidoUpsertWithoutDetallesInput = {
    update: XOR<PedidoUpdateWithoutDetallesInput, PedidoUncheckedUpdateWithoutDetallesInput>
    create: XOR<PedidoCreateWithoutDetallesInput, PedidoUncheckedCreateWithoutDetallesInput>
  }

  export type PedidoUpdateWithoutDetallesInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    EstadoPedido?: EstadoPedidoUpdateOneRequiredWithoutPedidosNestedInput
    Cliente?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    Mesero?: UsuarioUpdateOneWithoutEncargosNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutPedidosNestedInput
    Mesa?: MesaUpdateOneWithoutPedidosNestedInput
    TipoPedido?: TipoPedidoUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutDetallesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    idCliente?: StringFieldUpdateOperationsInput | string
    idMesero?: NullableStringFieldUpdateOperationsInput | string | null
    idSucursal?: IntFieldUpdateOperationsInput | number
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoUpsertWithoutPedidosInput = {
    update: XOR<ProductoUpdateWithoutPedidosInput, ProductoUncheckedUpdateWithoutPedidosInput>
    create: XOR<ProductoCreateWithoutPedidosInput, ProductoUncheckedCreateWithoutPedidosInput>
  }

  export type ProductoUpdateWithoutPedidosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Categoria_Producto?: Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput
    detalles?: Factura_DetalleUpdateManyWithoutProductoNestedInput
    sucursales?: SucursalUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput
    sucursales?: SucursalUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type UsuarioCreateManyPerfilInput = {
    id: string
    nombre: string
    apellido1: string
    apellido2: string
    correo: string
    username: string
    clave: string
    telefono: string
    direccion?: string | null
  }

  export type UsuarioUpdateWithoutPerfilInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUpdateManyWithoutMeseroNestedInput
    sucursales?: SucursalUpdateManyWithoutMeserosNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPerfilInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUncheckedUpdateManyWithoutMeseroNestedInput
    sucursales?: SucursalUncheckedUpdateManyWithoutMeserosNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservacionCreateManyUsuarioInput = {
    id?: number
    fecha_hora?: Date | string
    cantidad: number
    idSucursal: number
  }

  export type Factura_EncabezadoCreateManyUsuarioInput = {
    id?: number
    numero_tarjeta?: string | null
    idTipoTarjeta?: number | null
    fecha?: Date | string
    estado?: boolean
  }

  export type PedidoCreateManyClienteInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    idEstado: number
    idMesero?: string | null
    idSucursal: number
    idMesa?: number | null
    idTipoPedido: number
  }

  export type PedidoCreateManyMeseroInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    idEstado: number
    idCliente: string
    idSucursal: number
    idMesa?: number | null
    idTipoPedido: number
  }

  export type ReservacionUpdateWithoutUsuarioInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUpdateManyWithoutReservacionesNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutReservacionesNestedInput
  }

  export type ReservacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUncheckedUpdateManyWithoutReservacionesNestedInput
    idSucursal?: IntFieldUpdateOperationsInput | number
  }

  export type ReservacionUncheckedUpdateManyWithoutReservacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    idSucursal?: IntFieldUpdateOperationsInput | number
  }

  export type Factura_EncabezadoUpdateWithoutUsuarioInput = {
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    TipoTarjeta?: TipoTarjetaUpdateOneWithoutFacturasNestedInput
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUpdateManyWithoutFactura_EncabezadoNestedInput
    tipoPagos?: FacturaEncabezadoTipoPagoUpdateManyWithoutFactura_EncabezadoNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    idTipoTarjeta?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    tipoPagos?: FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateManyWithoutFacturasInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    idTipoTarjeta?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PedidoUpdateWithoutClienteInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUpdateManyWithoutPedidoNestedInput
    EstadoPedido?: EstadoPedidoUpdateOneRequiredWithoutPedidosNestedInput
    Mesero?: UsuarioUpdateOneWithoutEncargosNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutPedidosNestedInput
    Mesa?: MesaUpdateOneWithoutPedidosNestedInput
    TipoPedido?: TipoPedidoUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput
    idEstado?: IntFieldUpdateOperationsInput | number
    idMesero?: NullableStringFieldUpdateOperationsInput | string | null
    idSucursal?: IntFieldUpdateOperationsInput | number
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoUncheckedUpdateManyWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    idMesero?: NullableStringFieldUpdateOperationsInput | string | null
    idSucursal?: IntFieldUpdateOperationsInput | number
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoUpdateWithoutMeseroInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUpdateManyWithoutPedidoNestedInput
    EstadoPedido?: EstadoPedidoUpdateOneRequiredWithoutPedidosNestedInput
    Cliente?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutPedidosNestedInput
    Mesa?: MesaUpdateOneWithoutPedidosNestedInput
    TipoPedido?: TipoPedidoUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutMeseroInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput
    idEstado?: IntFieldUpdateOperationsInput | number
    idCliente?: StringFieldUpdateOperationsInput | string
    idSucursal?: IntFieldUpdateOperationsInput | number
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoUncheckedUpdateManyWithoutEncargosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    idEstado?: IntFieldUpdateOperationsInput | number
    idCliente?: StringFieldUpdateOperationsInput | string
    idSucursal?: IntFieldUpdateOperationsInput | number
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type SucursalUpdateWithoutMeserosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateWithoutMeserosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUncheckedUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUncheckedUpdateManyWithoutSucursalNestedInput
    productos?: ProductoUncheckedUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateManyWithoutSucursalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
  }

  export type MesaCreateManySucursalInput = {
    id?: number
    codigo: string
    capacidad: number
    estado?: boolean
    idDisponibilidad?: number
  }

  export type ReservacionCreateManySucursalInput = {
    id?: number
    fecha_hora?: Date | string
    cantidad: number
    idUsuario: string
  }

  export type PedidoCreateManySucursalInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    idEstado: number
    idCliente: string
    idMesero?: string | null
    idMesa?: number | null
    idTipoPedido: number
  }

  export type MesaUpdateWithoutSucursalInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: ReservacionUpdateManyWithoutMesasNestedInput
    pedidos?: PedidoUpdateManyWithoutMesaNestedInput
    EstadoMesa?: DisponibilidadMesaUpdateOneRequiredWithoutMesasNestedInput
  }

  export type MesaUncheckedUpdateWithoutSucursalInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: ReservacionUncheckedUpdateManyWithoutMesasNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutMesaNestedInput
    idDisponibilidad?: IntFieldUpdateOperationsInput | number
  }

  export type MesaUncheckedUpdateManyWithoutMesasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    idDisponibilidad?: IntFieldUpdateOperationsInput | number
  }

  export type ReservacionUpdateWithoutSucursalInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUpdateManyWithoutReservacionesNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReservacionesNestedInput
  }

  export type ReservacionUncheckedUpdateWithoutSucursalInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUncheckedUpdateManyWithoutReservacionesNestedInput
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoUpdateWithoutSucursalesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Categoria_Producto?: Categoria_ProductoUpdateOneRequiredWithoutProductosNestedInput
    detalles?: Factura_DetalleUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutSucursalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateManyWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    idCategoria?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUpdateWithoutSucursalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUpdateManyWithoutMeseroNestedInput
    Perfil?: PerfilUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutSucursalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    reservaciones?: ReservacionUncheckedUpdateManyWithoutUsuarioNestedInput
    facturas?: Factura_EncabezadoUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
    encargos?: PedidoUncheckedUpdateManyWithoutMeseroNestedInput
    idPerfil?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUncheckedUpdateManyWithoutMeserosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido1?: StringFieldUpdateOperationsInput | string
    apellido2?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    idPerfil?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoUpdateWithoutSucursalInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUpdateManyWithoutPedidoNestedInput
    EstadoPedido?: EstadoPedidoUpdateOneRequiredWithoutPedidosNestedInput
    Cliente?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    Mesero?: UsuarioUpdateOneWithoutEncargosNestedInput
    Mesa?: MesaUpdateOneWithoutPedidosNestedInput
    TipoPedido?: TipoPedidoUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutSucursalInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput
    idEstado?: IntFieldUpdateOperationsInput | number
    idCliente?: StringFieldUpdateOperationsInput | string
    idMesero?: NullableStringFieldUpdateOperationsInput | string | null
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoCreateManyMesaInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    idEstado: number
    idCliente: string
    idMesero?: string | null
    idSucursal: number
    idTipoPedido: number
  }

  export type ReservacionUpdateWithoutMesasInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    Sucursal?: SucursalUpdateOneRequiredWithoutReservacionesNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReservacionesNestedInput
  }

  export type ReservacionUncheckedUpdateWithoutMesasInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    idSucursal?: IntFieldUpdateOperationsInput | number
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoUpdateWithoutMesaInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUpdateManyWithoutPedidoNestedInput
    EstadoPedido?: EstadoPedidoUpdateOneRequiredWithoutPedidosNestedInput
    Cliente?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    Mesero?: UsuarioUpdateOneWithoutEncargosNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutPedidosNestedInput
    TipoPedido?: TipoPedidoUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutMesaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput
    idEstado?: IntFieldUpdateOperationsInput | number
    idCliente?: StringFieldUpdateOperationsInput | string
    idMesero?: NullableStringFieldUpdateOperationsInput | string | null
    idSucursal?: IntFieldUpdateOperationsInput | number
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type MesaCreateManyEstadoMesaInput = {
    id?: number
    codigo: string
    capacidad: number
    estado?: boolean
    idSucursal: number
  }

  export type MesaUpdateWithoutEstadoMesaInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: ReservacionUpdateManyWithoutMesasNestedInput
    pedidos?: PedidoUpdateManyWithoutMesaNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutMesasNestedInput
  }

  export type MesaUncheckedUpdateWithoutEstadoMesaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    reservaciones?: ReservacionUncheckedUpdateManyWithoutMesasNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutMesaNestedInput
    idSucursal?: IntFieldUpdateOperationsInput | number
  }

  export type MesaUpdateWithoutReservacionesInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pedidos?: PedidoUpdateManyWithoutMesaNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutMesasNestedInput
    EstadoMesa?: DisponibilidadMesaUpdateOneRequiredWithoutMesasNestedInput
  }

  export type MesaUncheckedUpdateWithoutReservacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    estado?: BoolFieldUpdateOperationsInput | boolean
    pedidos?: PedidoUncheckedUpdateManyWithoutMesaNestedInput
    idSucursal?: IntFieldUpdateOperationsInput | number
    idDisponibilidad?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoCreateManyCategoria_ProductoInput = {
    id?: number
    nombre: string
    descripcion: string
    ingredientes?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagen: string
    estado?: boolean
  }

  export type ProductoUpdateWithoutCategoria_ProductoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUpdateManyWithoutProductoNestedInput
    sucursales?: SucursalUpdateManyWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateWithoutCategoria_ProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    ingredientes?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagen?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutProductoNestedInput
    pedidos?: Pedido_ProductoUncheckedUpdateManyWithoutProductoNestedInput
    sucursales?: SucursalUncheckedUpdateManyWithoutProductosNestedInput
  }

  export type Factura_DetalleCreateManyProductoInput = {
    id?: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idFactura_Encabezado: number
  }

  export type Pedido_ProductoCreateManyProductoInput = {
    idPedido: number
    cantidad?: number
    notas: string
  }

  export type Factura_DetalleUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Factura_Encabezado?: Factura_EncabezadoUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type Factura_DetalleUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: IntFieldUpdateOperationsInput | number
  }

  export type Factura_DetalleUncheckedUpdateManyWithoutDetallesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idFactura_Encabezado?: IntFieldUpdateOperationsInput | number
  }

  export type Pedido_ProductoUpdateWithoutProductoInput = {
    Pedido?: PedidoUpdateOneRequiredWithoutDetallesNestedInput
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateWithoutProductoInput = {
    idPedido?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateManyWithoutPedidosInput = {
    idPedido?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type SucursalUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUpdateManyWithoutSucursalNestedInput
    meseros?: UsuarioUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUpdateManyWithoutSucursalNestedInput
  }

  export type SucursalUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    capacidad?: IntFieldUpdateOperationsInput | number
    mesas?: MesaUncheckedUpdateManyWithoutSucursalNestedInput
    reservaciones?: ReservacionUncheckedUpdateManyWithoutSucursalNestedInput
    meseros?: UsuarioUncheckedUpdateManyWithoutSucursalesNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type FacturaEncabezadoTipoPagoCreateManyTipoPagoInput = {
    idFactura_Encabezado: number
    monto: Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUpdateWithoutTipoPagoInput = {
    Factura_Encabezado?: Factura_EncabezadoUpdateOneRequiredWithoutTipoPagosNestedInput
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUncheckedUpdateWithoutTipoPagoInput = {
    idFactura_Encabezado?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutFacturasEncabezadoInput = {
    idFactura_Encabezado?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type Factura_EncabezadoCreateManyTipoTarjetaInput = {
    id?: number
    numero_tarjeta?: string | null
    fecha?: Date | string
    estado?: boolean
    idUsuario: string
  }

  export type Factura_EncabezadoUpdateWithoutTipoTarjetaInput = {
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUpdateManyWithoutFactura_EncabezadoNestedInput
    tipoPagos?: FacturaEncabezadoTipoPagoUpdateManyWithoutFactura_EncabezadoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type Factura_EncabezadoUncheckedUpdateWithoutTipoTarjetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    detalles?: Factura_DetalleUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    tipoPagos?: FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutFactura_EncabezadoNestedInput
    idUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type Factura_DetalleCreateManyFactura_EncabezadoInput = {
    id?: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    impuesto: Decimal | DecimalJsLike | number | string
    total_detalle: Decimal | DecimalJsLike | number | string
    idProducto: number
  }

  export type FacturaEncabezadoTipoPagoCreateManyFactura_EncabezadoInput = {
    idTipoPago: number
    monto: Decimal | DecimalJsLike | number | string
  }

  export type Factura_DetalleUpdateWithoutFactura_EncabezadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Producto?: ProductoUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type Factura_DetalleUncheckedUpdateWithoutFactura_EncabezadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    impuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_detalle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProducto?: IntFieldUpdateOperationsInput | number
  }

  export type FacturaEncabezadoTipoPagoUpdateWithoutFactura_EncabezadoInput = {
    TipoPago?: TipoPagoUpdateOneRequiredWithoutFacturasEncabezadoNestedInput
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUncheckedUpdateWithoutFactura_EncabezadoInput = {
    idTipoPago?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FacturaEncabezadoTipoPagoUncheckedUpdateManyWithoutTipoPagosInput = {
    idTipoPago?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PedidoCreateManyEstadoPedidoInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    idCliente: string
    idMesero?: string | null
    idSucursal: number
    idMesa?: number | null
    idTipoPedido: number
  }

  export type PedidoUpdateWithoutEstadoPedidoInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUpdateManyWithoutPedidoNestedInput
    Cliente?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    Mesero?: UsuarioUpdateOneWithoutEncargosNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutPedidosNestedInput
    Mesa?: MesaUpdateOneWithoutPedidosNestedInput
    TipoPedido?: TipoPedidoUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutEstadoPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput
    idCliente?: StringFieldUpdateOperationsInput | string
    idMesero?: NullableStringFieldUpdateOperationsInput | string | null
    idSucursal?: IntFieldUpdateOperationsInput | number
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
    idTipoPedido?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoCreateManyTipoPedidoInput = {
    id?: number
    nombre?: string | null
    precio?: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    idEstado: number
    idCliente: string
    idMesero?: string | null
    idSucursal: number
    idMesa?: number | null
  }

  export type PedidoUpdateWithoutTipoPedidoInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUpdateManyWithoutPedidoNestedInput
    EstadoPedido?: EstadoPedidoUpdateOneRequiredWithoutPedidosNestedInput
    Cliente?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    Mesero?: UsuarioUpdateOneWithoutEncargosNestedInput
    Sucursal?: SucursalUpdateOneRequiredWithoutPedidosNestedInput
    Mesa?: MesaUpdateOneWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutTipoPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: Pedido_ProductoUncheckedUpdateManyWithoutPedidoNestedInput
    idEstado?: IntFieldUpdateOperationsInput | number
    idCliente?: StringFieldUpdateOperationsInput | string
    idMesero?: NullableStringFieldUpdateOperationsInput | string | null
    idSucursal?: IntFieldUpdateOperationsInput | number
    idMesa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Pedido_ProductoCreateManyPedidoInput = {
    idProducto: number
    cantidad?: number
    notas: string
  }

  export type Pedido_ProductoUpdateWithoutPedidoInput = {
    Producto?: ProductoUpdateOneRequiredWithoutPedidosNestedInput
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateWithoutPedidoInput = {
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }

  export type Pedido_ProductoUncheckedUpdateManyWithoutDetallesInput = {
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    notas?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}